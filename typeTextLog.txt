commit 0a913549758dce27166ba99580609cc1ec1400b2
Author: kardelitaitu <adikaradwiatmaja@gmail.com>
Date:   Wed Feb 11 04:38:36 2026 +0700

    Initial commit - baseline before improvements

diff --git a/utils/human-interaction.js b/utils/human-interaction.js
new file mode 100644
index 0000000..e26e430
--- /dev/null
+++ b/utils/human-interaction.js
@@ -0,0 +1,461 @@
+/**
+ * Human Interaction Utilities
+ * Provides human-like behavior patterns for automation
+ * @module utils/human-interaction
+ */
+
+import { createLogger } from './logger.js';
+import { mathUtils } from './mathUtils.js';
+import { entropy } from './entropyController.js';
+
+const logger = createLogger('human-interaction.js');
+
+export class HumanInteraction {
+    constructor() {
+        this.debugMode = process.env.HUMAN_DEBUG === 'true';
+    }
+
+    /**
+     * Get random method based on weights
+     */
+    selectMethod(methods) {
+        const roll = Math.random() * 100;
+        let cumulative = 0;
+
+        for (const method of methods) {
+            cumulative += method.weight;
+            if (roll <= cumulative) {
+                this.logDebug(`[MethodSelect] Selected: ${method.name} (roll: ${roll.toFixed(1)}, threshold: ${cumulative.toFixed(1)})`);
+                return method;
+            }
+        }
+
+        return methods[0];
+    }
+
+    /**
+     * Human-like pre-action delay
+     */
+    async hesitation(min = 300, max = 1500) {
+        const delay = mathUtils.randomInRange(min, max);
+        this.logDebug(`[Hesitation] Waiting ${delay}ms before action...`);
+        await new Promise(resolve => setTimeout(resolve, delay));
+        return delay;
+    }
+
+    /**
+     * Human-like reading delay
+     */
+    async readingTime(min = 5000, max = 15000) {
+        const time = mathUtils.randomInRange(min, max);
+        this.logDebug(`[Reading] Reading for ${time}ms...`);
+        await new Promise(resolve => setTimeout(resolve, time));
+        return time;
+    }
+
+    /**
+     * Random scroll during reading (30% probability)
+     */
+    async maybeScroll(page, min = 100, max = 300) {
+        if (Math.random() < 0.3) {
+            const scrollAmount = mathUtils.randomInRange(min, max);
+            const direction = Math.random() < 0.5 ? scrollAmount : -scrollAmount;
+            this.logDebug(`[Scroll] Random scroll: ${direction}px`);
+            await page.evaluate((y) => window.scrollBy(0, y), direction);
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Micro mouse movement
+     */
+    async microMove(page, range = 20) {
+        const x = mathUtils.randomInRange(-range, range);
+        const y = mathUtils.randomInRange(-range, range);
+        this.logDebug(`[MicroMove] Mouse: ${x}, ${y}`);
+        await page.mouse.move(x, y);
+    }
+
+    /**
+     * Target fixation (pause before clicking)
+     */
+    async fixation(min = 200, max = 800) {
+        const time = mathUtils.randomInRange(min, max);
+        this.logDebug(`[Fixation] Fixating for ${time}ms...`);
+        await new Promise(resolve => setTimeout(resolve, time));
+        return time;
+    }
+
+    /**
+     * Find element with multiple selectors
+     * @returns {object} { element, selector, index }
+     */
+    async findElement(page, selectors, options = {}) {
+        const { visibleOnly = true, timeout = 5000 } = options;
+        const startTime = Date.now();
+
+        for (const selector of selectors) {
+            const elapsed = Date.now() - startTime;
+            if (elapsed > timeout) {
+                this.logDebug(`[FindElement] Timeout reached`);
+                break;
+            }
+
+            try {
+                const elements = await page.locator(selector).all();
+                this.logDebug(`[FindElement] Selector "${selector}": ${elements.length} elements`);
+
+                for (let i = 0; i < elements.length; i++) {
+                    try {
+                        const el = elements[i];
+                        if (visibleOnly) {
+                            if (await el.isVisible()) {
+                                this.logDebug(`[FindElement] Found visible element at index ${i}`);
+                                return { element: el, selector, index: i };
+                            }
+                        } else {
+                            return { element: el, selector, index: i };
+                        }
+                    } catch (e) {
+                        this.logDebug(`[FindElement] Element ${i} error: ${e.message}`);
+                    }
+                }
+            } catch (e) {
+                this.logDebug(`[FindElement] Selector "${selector}" error: ${e.message}`);
+            }
+        }
+
+        return { element: null, selector: null, index: -1 };
+    }
+
+    /**
+     * Verify composer is open and get the best textarea locator
+     */
+    async verifyComposerOpen(page) {
+        const composerSelectors = [
+            '[data-testid="tweetTextarea_0"]',
+            '[contenteditable="true"][role="textbox"]',
+            '[data-testid="tweetTextarea"]',
+            '[class*="composer"] textarea',
+            'textarea[placeholder*="Post your reply"]',
+            'textarea[placeholder*="What\'s happening"]',
+            '[role="textbox"][contenteditable="true"]'
+        ];
+
+        this.logDebug(`[Verify] Checking if composer is open...`);
+
+        // First, try to find the most reliable selector
+        for (const selector of composerSelectors) {
+            try {
+                const el = page.locator(selector).first();
+                if (await el.count() > 0) {
+                    const isVisible = await el.isVisible();
+                    const box = await el.boundingBox();
+                    
+                    this.logDebug(`[Verify] Selector "${selector}": visible=${isVisible}, box=${box ? 'found' : 'none'}`);
+                    
+                    if (isVisible && box && box.width > 50 && box.height > 20) {
+                        this.logDebug(`[Verify] Composer open with: ${selector}`);
+                        
+                        // Double check it's not a stale element
+                        const textContent = await el.inputValue().catch(() => '');
+                        this.logDebug(`[Verify] Element has value: ${textContent.length > 0 ? 'yes' : 'empty'}`);
+                        
+                        return { open: true, selector, locator: el };
+                    }
+                }
+            } catch (e) {
+                this.logDebug(`[Verify] Selector "${selector}" error: ${e.message}`);
+            }
+        }
+
+        // Try one more time with longer wait
+        await new Promise(resolve => setTimeout(resolve, 500));
+        
+        for (const selector of composerSelectors) {
+            try {
+                const el = page.locator(selector).first();
+                if (await el.count() > 0 && await el.isVisible()) {
+                    this.logDebug(`[Verify] Late detection: ${selector}`);
+                    return { open: true, selector, locator: el };
+                }
+            } catch {}
+        }
+
+        this.logDebug(`[Verify] Composer not open`);
+        return { open: false, selector: null, locator: null };
+    }
+
+    /**
+     * Verify post was sent (composer closed or confirmation shown)
+     */
+    async verifyPostSent(page) {
+        const checks = [
+            { selector: '[data-testid="toast"]', label: 'toast notification' },
+            { selector: '[aria-label*="Post"]', label: 'post aria' },
+            { selector: '[data-testid="tweetTextarea_0"]', label: 'composer closed', invert: true }
+        ];
+
+        this.logDebug(`[Verify] Checking if post was sent...`);
+
+        for (const check of checks) {
+            try {
+                const el = page.locator(check.selector).first();
+                const count = await el.count();
+
+                if (check.invert) {
+                    if (count === 0) {
+                        this.logDebug(`[Verify] ${check.label}: confirmed`);
+                        return { sent: true, method: check.label };
+                    }
+                } else {
+                    if (count > 0) {
+                        const text = await el.innerText().catch(() => '');
+                        this.logDebug(`[Verify] ${check.label}: found (${text.substring(0, 30)})`);
+                        return { sent: true, method: check.label };
+                    }
+                }
+            } catch (e) {}
+        }
+
+        // Check URL changed back
+        const url = page.url();
+        if (!url.includes('compose')) {
+            this.logDebug(`[Verify] URL no longer has compose: confirmed`);
+            return { sent: true, method: 'url_change' };
+        }
+
+        return { sent: false, method: null };
+    }
+
+    /**
+     * Type text with human-like delays and robust focus handling
+     */
+    async typeText(page, text, inputEl) {
+        // Step 1: Clear any existing text first
+        try {
+            await inputEl.click({ timeout: 3000 });
+            await page.keyboard.press('Control+a');
+            await new Promise(resolve => setTimeout(resolve, 200));
+        } catch (e) {
+            this.logDebug(`[Type] Clear text failed: ${e.message}`);
+        }
+
+        // Step 2: Multiple focus strategies
+        const focused = await this.ensureFocus(page, inputEl);
+        if (!focused) {
+            this.logWarn(`[Type] Could not focus element, trying alternative approach...`);
+            // Fallback: use keyboard to focus
+            await page.keyboard.press('Tab');
+            await new Promise(resolve => setTimeout(resolve, 300));
+        }
+
+        // Step 3: Verify we're focused by checking active element
+        const activeCheck = await page.evaluate(() => {
+            const el = document.activeElement;
+            return {
+                tagName: el?.tagName,
+                isContentEditable: el?.isContentEditable,
+                hasFocus: el === document.querySelector('[data-testid="tweetTextarea_0"]') || 
+                          el === document.querySelector('[contenteditable="true"]')
+            };
+        });
+        
+        this.logDebug(`[Type] Active element: ${activeCheck.tagName}, contentEditable: ${activeCheck.isContentEditable}`);
+
+        // If still not focused, try force clicking
+        if (!activeCheck.isContentEditable && !activeCheck.tagName?.toLowerCase().includes('textarea')) {
+            this.logDebug(`[Type] Not focused correctly, force clicking...`);
+            try {
+                await inputEl.click({ force: true });
+                await new Promise(resolve => setTimeout(resolve, 200));
+            } catch {}
+        }
+
+        // Human-like typing with variations
+        const baseDelay = mathUtils.randomInRange(80, 150);
+        const punctuationPause = mathUtils.randomInRange(200, 400);
+        const spacePause = mathUtils.randomInRange(100, 200);
+
+        this.logDebug(`[Type] Starting to type ${text.length} chars...`);
+
+        for (let i = 0; i < text.length; i++) {
+            const char = text[i];
+
+            if (char === ' ') {
+                await new Promise(resolve => setTimeout(resolve, spacePause));
+            } else if (['.', '!', '?', ',', ';', ':'].includes(char)) {
+                await new Promise(resolve => setTimeout(resolve, punctuationPause));
+            } else {
+                await new Promise(resolve => setTimeout(resolve, baseDelay));
+            }
+
+            // Occasional longer pause (thinking)
+            if (Math.random() < 0.05 && i < text.length - 1) {
+                const pause = mathUtils.randomInRange(300, 800);
+                this.logDebug(`[Type] Thinking pause: ${pause}ms`);
+                await new Promise(resolve => setTimeout(resolve, pause));
+            }
+
+            await page.keyboard.type(char);
+        }
+
+        const duration = mathUtils.randomInRange(500, 1000);
+        this.logDebug(`[Type] Finished typing`);
+        await new Promise(resolve => setTimeout(resolve, duration));
+    }
+
+    /**
+     * Ensure element is focused with multiple strategies
+     */
+    async ensureFocus(page, element) {
+        const focusStrategies = [
+            // Strategy 1: Regular click
+            async () => {
+                await element.click({ timeout: 3000 });
+                await new Promise(resolve => setTimeout(resolve, 200));
+                return true;
+            },
+            // Strategy 2: Focus method
+            async () => {
+                try {
+                    await element.focus();
+                    await new Promise(resolve => setTimeout(resolve, 200));
+                    return true;
+                } catch {
+                    return false;
+                }
+            },
+            // Strategy 3: Click with offset
+            async () => {
+                try {
+                    await element.click({ position: { x: 5, y: 5 } });
+                    await new Promise(resolve => setTimeout(resolve, 200));
+                    return true;
+                } catch {
+                    return false;
+                }
+            },
+            // Strategy 4: Double click
+            async () => {
+                try {
+                    await element.dblclick();
+                    await new Promise(resolve => setTimeout(resolve, 200));
+                    return true;
+                } catch {
+                    return false;
+                }
+            },
+            // Strategy 5: Force click
+            async () => {
+                try {
+                    await element.click({ force: true });
+                    await new Promise(resolve => setTimeout(resolve, 200));
+                    return true;
+                } catch {
+                    return false;
+                }
+            }
+        ];
+
+        for (let i = 0; i < focusStrategies.length; i++) {
+            try {
+                const result = await focusStrategies[i]();
+                if (result) {
+                    // Verify focus worked
+                    const isFocused = await page.evaluate(() => {
+                        const el = document.activeElement;
+                        return el?.isContentEditable || 
+                               el?.tagName === 'TEXTAREA' || 
+                               el?.tagName === 'INPUT';
+                    });
+                    
+                    if (isFocused) {
+                        this.logDebug(`[EnsureFocus] Strategy ${i + 1} succeeded`);
+                        return true;
+                    }
+                }
+            } catch (e) {
+                this.logDebug(`[EnsureFocus] Strategy ${i + 1} failed: ${e.message}`);
+            }
+        }
+
+        this.logDebug(`[EnsureFocus] All strategies failed`);
+        return false;
+    }
+
+    /**
+     * Post with Ctrl+Enter or fallback
+     */
+    async postTweet(page) {
+        this.logDebug(`[Post] Attempting to post...`);
+
+        // Try Ctrl+Enter first
+        await page.keyboard.press('Control+Enter');
+        await new Promise(resolve => setTimeout(resolve, 500));
+
+        // Verify
+        const result = await this.verifyPostSent(page);
+        if (result.sent) {
+            this.logDebug(`[Post] Success via ${result.method}`);
+            return { success: true, method: 'ctrl_enter' };
+        }
+
+        // Fallback: Click button
+        const postSelectors = [
+            '[data-testid="tweetButton"]',
+            '[data-testid="sendTweets"]',
+            '[aria-label="Post"]',
+            '[class*="post"]',
+            'button[type="submit"]'
+        ];
+
+        for (const selector of postSelectors) {
+            try {
+                const btn = page.locator(selector).first();
+                if (await btn.count() > 0 && await btn.isVisible()) {
+                    this.logDebug(`[Post] Clicking: ${selector}`);
+                    await btn.click();
+                    await new Promise(resolve => setTimeout(resolve, 500));
+
+                    const result2 = await this.verifyPostSent(page);
+                    if (result2.sent) {
+                        this.logDebug(`[Post] Success via button: ${selector}`);
+                        return { success: true, method: 'button_click' };
+                    }
+                }
+            } catch (e) {
+                this.logDebug(`[Post] Button "${selector}" error: ${e.message}`);
+            }
+        }
+
+        this.logDebug(`[Post] Failed - no method worked`);
+        return { success: false, reason: 'post_failed' };
+    }
+
+    /**
+     * Debug logging helper
+     */
+    logDebug(message) {
+        if (this.debugMode) {
+            logger.debug(message);
+        }
+    }
+
+    /**
+     * Warning logging helper
+     */
+    logWarn(message) {
+        logger.warn(message);
+    }
+
+    /**
+     * Log step in a sequence
+     */
+    logStep(stepName, details = '') {
+        logger.debug(`[STEP] ${stepName}${details ? ': ' + details : ''}`);
+    }
+}
+
+export default HumanInteraction;
