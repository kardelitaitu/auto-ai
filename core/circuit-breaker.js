/**
 * @fileoverview Circuit Breaker for Model Health Monitoring
 * @module core/circuit-breaker
 */

import { createLogger } from '../utils/logger.js';

const logger = createLogger('circuit-breaker.js');

const STATE_CLOSED = 'CLOSED';
const STATE_OPEN = 'OPEN';
const STATE_HALF_OPEN = 'HALF_OPEN';

class CircuitOpenError extends Error {
    constructor(modelId, waitTime) {
        super(`Circuit breaker OPEN for ${modelId}. Retry after ${Math.ceil(waitTime / 1000)}s`);
        this.code = 'CIRCUIT_OPEN';
        this.modelId = modelId;
        this.retryAfter = waitTime;
    }
}

/**
 * @class CircuitBreaker
 * @description Prevents cascading failures by monitoring model health and tripping when failure threshold reached
 */
class CircuitBreaker {
    constructor(options = {}) {
        this.failureThreshold = options.failureThreshold || 50;
        this.successThreshold = options.successThreshold || 2;
        this.halfOpenTime = options.halfOpenTime || 30000;
        this.monitoringWindow = options.monitoringWindow || 60000;
        this.minSamples = options.minSamples || 5;

        this.breakers = new Map();
    }

    /**
     * Get or create a circuit breaker for a model
     * @param {string} modelId - Unique model identifier
     * @returns {object} Circuit breaker instance
     */
    getBreaker(modelId) {
        if (!this.breakers.has(modelId)) {
            this.breakers.set(modelId, this._createBreaker());
        }
        return this.breakers.get(modelId);
    }

    /**
     * Create a new breaker instance
     * @private
     */
    _createBreaker() {
        return {
            state: STATE_CLOSED,
            failures: 0,
            successes: 0,
            lastFailure: null,
            lastSuccess: null,
            nextAttempt: null,
            history: []
        };
    }

    /**
     * Execute a function through the circuit breaker
     * @param {string} modelId - Model identifier
     * @param {Function} fn - Async function to execute
     * @param {object} options - Execution options
     * @returns {Promise<any>} Function result
     */
    async execute(modelId, fn, options = {}) {
        const breaker = this.getBreaker(modelId);

        if (breaker.state === STATE_OPEN) {
            if (Date.now() < breaker.nextAttempt) {
                const waitTime = breaker.nextAttempt - Date.now();
                throw new CircuitOpenError(modelId, waitTime);
            } else {
                breaker.state = STATE_HALF_OPEN;
                logger.info(`[${modelId}] Circuit breaker transitioning to HALF_OPEN`);
            }
        }

        try {
            const result = await fn();
            this._recordSuccess(breaker, modelId);

            return result;
        } catch (error) {
            this._recordFailure(breaker, modelId, error);
            throw error;
        }
    }

    /**
     * Check if circuit is open
     * @private
     */
    _isOpen(breaker) {
        if (breaker.state === STATE_OPEN) {
            if (Date.now() >= breaker.nextAttempt) {
                return false;
            }
        }
        return breaker.state === STATE_OPEN;
    }

    /**
     * Record successful execution
     * @private
     */
    _recordSuccess(breaker, modelId) {
        breaker.successes++;
        breaker.lastSuccess = Date.now();
        breaker.history.push({ time: Date.now(), type: 'success' });
        this._cleanupHistory(breaker);

        if (breaker.state === STATE_HALF_OPEN) {
            if (breaker.successes >= this.successThreshold) {
                breaker.state = STATE_CLOSED;
                breaker.failures = 0;
                breaker.successes = 0;
                logger.info(`[${modelId}] Circuit breaker CLOSED (recovered)`);
            }
        }
    }

    /**
     * Record failed execution
     * @private
     */
    _recordFailure(breaker, modelId, error) {
        breaker.failures++;
        breaker.lastFailure = Date.now();
        breaker.history.push({ time: Date.now(), type: 'failure', error: error.message });
        this._cleanupHistory(breaker);

        const failureRate = this._calculateFailureRate(breaker);

        if (breaker.state === STATE_HALF_OPEN) {
            breaker.state = STATE_OPEN;
            breaker.nextAttempt = Date.now() + this.halfOpenTime;
            logger.warn(`[${modelId}] Circuit breaker OPEN (failed in HALF_OPEN, rate: ${failureRate}%)`);
        } else if (breaker.state === STATE_CLOSED && failureRate >= this.failureThreshold) {
            breaker.state = STATE_OPEN;
            breaker.nextAttempt = Date.now() + this.halfOpenTime;
            logger.warn(`[${modelId}] Circuit breaker OPEN (failure rate: ${failureRate}%)`);
        }
    }

    /**
     * Calculate failure rate percentage
     * @private
     */
    _calculateFailureRate(breaker) {
        const windowStart = Date.now() - this.monitoringWindow;
        const recentHistory = breaker.history.filter(h => h.time >= windowStart);

        if (recentHistory.length === 0 || recentHistory.length < this.minSamples) return 0;

        const failures = recentHistory.filter(h => h.type === 'failure').length;
        return Math.round((failures / recentHistory.length) * 100);
    }

    /**
     * Clean up old history entries
     * @private
     */
    _cleanupHistory(breaker) {
        const windowStart = Date.now() - this.monitoringWindow;
        breaker.history = breaker.history.filter(h => h.time >= windowStart);

        if (breaker.history.length > 100) {
            breaker.history = breaker.history.slice(-100);
        }
    }

    /**
     * Get health status of a model
     * @param {string} modelId - Model identifier
     * @returns {object}
     */
    getHealth(modelId) {
        const breaker = this.breakers.get(modelId);

        if (!breaker) {
            return { status: 'unknown', modelId };
        }

        const failureRate = this._calculateFailureRate(breaker);
        const windowStart = Date.now() - this.monitoringWindow;
        const recentHistory = breaker.history.filter(h => h.time >= windowStart);

        return {
            status: breaker.state,
            modelId,
            failureRate,
            recentOperations: recentHistory.length,
            lastSuccess: breaker.lastSuccess,
            lastFailure: breaker.lastFailure,
            nextAttempt: breaker.nextAttempt
        };
    }

    /**
     * Get status of all breakers
     * @returns {object}
     */
    getAllStatus() {
        const status = {};

        for (const [modelId, breaker] of this.breakers) {
            const failureRate = this._calculateFailureRate(breaker);
            status[modelId] = {
                state: breaker.state,
                failureRate: `${failureRate}%`,
                failures: breaker.failures,
                successes: breaker.successes
            };
        }

        return status;
    }

    /**
     * Reset a specific breaker
     * @param {string} modelId - Model identifier
     */
    reset(modelId) {
        if (this.breakers.has(modelId)) {
            this.breakers.set(modelId, this._createBreaker());
            logger.info(`[${modelId}] Circuit breaker reset`);
        }
    }

    /**
     * Reset all breakers
     */
    resetAll() {
        this.breakers.clear();
        logger.info('All circuit breakers reset');
    }

    /**
     * Force open a breaker (for maintenance)
     * @param {string} modelId - Model identifier
     */
    forceOpen(modelId) {
        const breaker = this.getBreaker(modelId);
        breaker.state = STATE_OPEN;
        breaker.nextAttempt = Date.now() + this.halfOpenTime;
        logger.info(`[${modelId}] Circuit breaker FORCED OPEN`);
    }

    /**
     * Force close a breaker (for recovery)
     * @param {string} modelId - Model identifier
     */
    forceClose(modelId) {
        const breaker = this.getBreaker(modelId);
        breaker.state = STATE_CLOSED;
        breaker.failures = 0;
        breaker.successes = 0;
        logger.info(`[${modelId}] Circuit breaker FORCED CLOSED`);
    }
}

export default CircuitBreaker;
