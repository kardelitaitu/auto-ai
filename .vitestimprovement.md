# Vitest Coverage Mastery: The 100% Playbook

**Role:** Senior QA Automation Engineer  
**Objective:** Systematically achieve 100% code coverage by eliminating "dark zones" through surgical testing strategies.

---

## Rules of Engagement

Strict adherence to these rules is required to maintain codebase integrity while increasing coverage.

* **Zero Regression:** Never modify or delete an existing passing test to "fix" coverage. We only add new cases.
* **Config Sanctity:** Do **NOT** modify `vitest.config.js`. We fix the tests, we don't hide the code.
* **Precision Targeting:** Do not write broad, generic tests. Target the specific line numbers listed in the failure report.
* **Mock Externalities:** If an uncovered line involves a database or API call, you **MUST** use mocks (`vi.mock`, `vi.spyOn`). Do not test the network.
* **Javascript Focus:** This guide assumes a `.js` codebase. Types are loose; runtime values (`null`, `undefined`) must be tested.

---

## Available MCP Tools

The agent is equipped with the following Model Context Protocol (MCP) tools to execute this workflow:

* **Filesystem:** For reading source/test files and writing new test cases.
* **Desktop Commander:** For executing terminal commands (`npx vitest ...`).
* **Sequential Thinking:** For analyzing complex logic branches before writing code.
* **File Context Server:** For managing file context.
* **Fetch:** For retrieving external documentation if needed.
* **Tavily & DuckDuckGo Search Server:** For searching Vitest/Jest specific syntax patterns.
* **Memory:** For recalling project-specific context across steps.
* **context7:** Additional context management.

---

## The Toolbelt (Terminal)

Ensure these CLI tools are available for the agent to invoke via **Desktop Commander**:

* **Test Runner:** `vitest`
* **Coverage Provider:** `@vitest/coverage-v8` (Preferred for speed) or `@vitest/coverage-istanbul` (Preferred for precision).
* **Reporters:** `text` (For quick terminal analysis/Line numbers).
* **Mocking Utilities:** `vi.fn()`, `vi.spyOn()`, `vi.mock()`.

---

## Phase 1: Precision Diagnostics

Stop guessing. Use specific reporters to locate the exact coordinates of missing coverage.

### 1. The Terminal Heatmap
Run this command to get the raw data:
```powershell
npm run test:coverage -- --coverage.reporter=text > coverage_report.txt 2>&1
```

### 2. Reading the "Uncovered Line #" Column
Ignore the percentages. Focus entirely on the Uncovered Line # column.

14-18: A contiguous block (likely an if block or loop).

42: A single line (likely a ternary logic branch or specific variable assignment).

## Phase 2: Tactical Execution (The Loop)

### Step 1: Pattern Recognition
Identify why the line is uncovered. Match it to these common patterns:

Pattern             | Code Example                    | Why it's uncovered
--------------------|---------------------------------|--------------------------------------
Default Args        | func(a = 10)                    | You only called func(5). No default test.
Ternary             | const x = active ? 'A' : 'B'    | You only tested true. 'B' is red.
Optional Chain      | user?.address?.zip              | You always provided a full user object.
Error Guard         | if (err) return                 | Your mocks always return success.

### Step 2: Targeted Implementation (Cheatsheet)

Scenario A: Covering Default Arguments
Code: export const add = (a, b = 0) => a + b;
Fix: Call it without the second argument.
expect(add(5)).toBe(5); // Triggers the 'b = 0' logic

Scenario B: Covering Error/Catch Blocks
Code: try { await api.get() } catch (e) { logger.error(e) }
Fix: Force the mock to explode.
vi.spyOn(api, 'get').mockRejectedValueOnce(new Error('Boom'));
expect(logger.error).toHaveBeenCalled();

Scenario C: Covering Conditional Branches (If/Else)
Code: if (user.age < 18) return 'minor';
Fix: Create two explicit test cases.
it('returns minor for under 18', () => { ... });
it('returns adult for 18+', () => { ... });

### Step 3: Verification
Isolate the run to save time:
npx vitest run src/utils/targetFile.test.js --coverage

---

## Phase 3: The "Lazy" Automation (AI Workflow)

1. Generate the Context
npx vitest run --coverage --reporter=text > coverage_report.txt 2>&1

2. The Engineer's Prompt
"Context: I am fixing code coverage for a JavaScript project. Attached is coverage_report.txt.
Task:
1. Find the file with lowest coverage.
2. Open source file (.js) and identify logic at 'Uncovered Line #s'.
3. Write a new standalone test case in the .test.js file.
Rules:
- CRITICAL: Do NOT modify vitest.config.js.
- If uncovered line is an error handler, use vi.spyOn().mockRejectedValue().
- Output ONLY the new test code snippet."

---

## Phase 4: Troubleshooting & Maintenance

"The line is covered but still red!"
Cause: V8 coverage imprecision.
Fix: Switch provider to 'istanbul' in vitest.config.js (if approved).

"This code is unreachable."
Cause: Defensive coding for impossible math/logic.
Fix: Use ignore comments.
/* v8 ignore next 3 */
if (!user) { throw new Error('Never happens'); }

CI Gatekeeper
Add to package.json to fail builds if coverage drops:
"test:ci": "vitest run --coverage --coverage.thresholds.lines 100"