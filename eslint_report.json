[{"filePath":"C:\\My Script\\auto-ai\\tests\\edge-cases\\index.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'phase1Validation' is not defined.","line":26,"column":44,"messageId":"undef","endLine":26,"endColumn":60},{"ruleId":"no-undef","severity":2,"message":"'multilineTweet' is not defined.","line":27,"column":45,"messageId":"undef","endLine":27,"endColumn":59},{"ruleId":"no-undef","severity":2,"message":"'models' is not defined.","line":28,"column":36,"messageId":"undef","endLine":28,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'diveLock' is not defined.","line":29,"column":39,"messageId":"undef","endLine":29,"endColumn":47}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Edge Case Tests Index\r\n * \r\n * This file re-exports all edge case tests for aggregated testing.\r\n * Import paths using @tests alias:\r\n *   import { describe, it, expect } from 'vitest';\r\n *   import * as edgeCaseTests from '@tests/edge-cases';\r\n */\r\n\r\nexport { default as phase1Validation } from './phase1-3-validation.js';\r\nexport { default as multilineTweet } from './test-multiline-tweet.js';\r\nexport { default as models } from './test-models.js';\r\nexport { default as diveLock } from './test-dive-lock.js';\r\n\r\n/**\r\n * Run all edge case tests\r\n */\r\nexport async function runAllEdgeCaseTests() {\r\n  const results = {\r\n    passed: 0,\r\n    failed: 0,\r\n    tests: []\r\n  };\r\n\r\n  const testModules = [\r\n    { name: 'phase1-3-validation', module: phase1Validation },\r\n    { name: 'test-multiline-tweet', module: multilineTweet },\r\n    { name: 'test-models', module: models },\r\n    { name: 'test-dive-lock', module: diveLock }\r\n  ];\r\n\r\n  for (const { name, module } of testModules) {\r\n    try {\r\n      // Module is loaded, tests will be discovered by vitest\r\n      results.tests.push({ name, status: 'loaded' });\r\n      results.passed++;\r\n    } catch (error) {\r\n      results.tests.push({ name, status: 'failed', error: error.message });\r\n      results.failed++;\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\My Script\\auto-ai\\tests\\integration\\index.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'agentConnectorHealth' is not defined.","line":34,"column":47,"messageId":"undef","endLine":34,"endColumn":67},{"ruleId":"no-undef","severity":2,"message":"'circuitBreaker' is not defined.","line":35,"column":40,"messageId":"undef","endLine":35,"endColumn":54},{"ruleId":"no-undef","severity":2,"message":"'requestQueue' is not defined.","line":36,"column":38,"messageId":"undef","endLine":36,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'coreModules' is not defined.","line":37,"column":37,"messageId":"undef","endLine":37,"endColumn":48},{"ruleId":"no-undef","severity":2,"message":"'dedupe' is not defined.","line":38,"column":31,"messageId":"undef","endLine":38,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'aiReplyEngine' is not defined.","line":39,"column":40,"messageId":"undef","endLine":39,"endColumn":53},{"ruleId":"no-undef","severity":2,"message":"'cloudPromptFix' is not defined.","line":40,"column":41,"messageId":"undef","endLine":40,"endColumn":55},{"ruleId":"no-undef","severity":2,"message":"'cloudClientMulti' is not defined.","line":41,"column":43,"messageId":"undef","endLine":41,"endColumn":59},{"ruleId":"no-undef","severity":2,"message":"'multiApi' is not defined.","line":42,"column":34,"messageId":"undef","endLine":42,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'cloudApi' is not defined.","line":43,"column":34,"messageId":"undef","endLine":43,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'cloudClient' is not defined.","line":44,"column":37,"messageId":"undef","endLine":44,"endColumn":48},{"ruleId":"no-undef","severity":2,"message":"'agentConnector' is not defined.","line":45,"column":40,"messageId":"undef","endLine":45,"endColumn":54}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Integration Tests Index\r\n * \r\n * This file re-exports all integration tests for aggregated testing.\r\n * Import paths using @tests alias:\r\n *   import { describe, it, expect } from 'vitest';\r\n *   import * as integrationTests from '@tests/integration';\r\n */\r\n\r\nexport { default as agentConnectorHealth } from './agent-connector-health.test.js';\r\nexport { default as circuitBreaker } from './circuit-breaker.test.js';\r\nexport { default as requestQueue } from './request-queue.test.js';\r\nexport { default as coreModules } from './test-core-modules.js';\r\nexport { default as dedupe } from './test-dedupe.js';\r\nexport { default as aiReplyEngine } from './test-ai-reply-engine.js';\r\nexport { default as cloudPromptFix } from './test-cloud-prompt-fix.js';\r\nexport { default as cloudClientMulti } from './test-cloud-client-multi.js';\r\nexport { default as multiApi } from './test-multi-api.js';\r\nexport { default as cloudApi } from './test-cloud-api.js';\r\nexport { default as cloudClient } from './cloud-client.test.js';\r\nexport { default as agentConnector } from './agent-connector.test.js';\r\n\r\n/**\r\n * Run all integration tests\r\n */\r\nexport async function runAllIntegrationTests() {\r\n  const results = {\r\n    passed: 0,\r\n    failed: 0,\r\n    tests: []\r\n  };\r\n\r\n  const testModules = [\r\n    { name: 'agent-connector-health', module: agentConnectorHealth },\r\n    { name: 'circuit-breaker', module: circuitBreaker },\r\n    { name: 'request-queue', module: requestQueue },\r\n    { name: 'core-modules', module: coreModules },\r\n    { name: 'dedupe', module: dedupe },\r\n    { name: 'ai-reply-engine', module: aiReplyEngine },\r\n    { name: 'cloud-prompt-fix', module: cloudPromptFix },\r\n    { name: 'cloud-client-multi', module: cloudClientMulti },\r\n    { name: 'multi-api', module: multiApi },\r\n    { name: 'cloud-api', module: cloudApi },\r\n    { name: 'cloud-client', module: cloudClient },\r\n    { name: 'agent-connector', module: agentConnector }\r\n  ];\r\n\r\n  for (const { name, module } of testModules) {\r\n    try {\r\n      // Module is loaded, tests will be discovered by vitest\r\n      results.tests.push({ name, status: 'loaded' });\r\n      results.passed++;\r\n    } catch (error) {\r\n      results.tests.push({ name, status: 'failed', error: error.message });\r\n      results.failed++;\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\My Script\\auto-ai\\tests\\unit\\ai-twitter-activity.test.js","messages":[{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":739,"column":11,"messageId":"unnecessaryAssignment","endLine":739,"endColumn":27},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":743,"column":7,"messageId":"unnecessaryAssignment","endLine":743,"endColumn":23},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":870,"column":11,"messageId":"unnecessaryAssignment","endLine":870,"endColumn":28},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":885,"column":11,"messageId":"unnecessaryAssignment","endLine":885,"endColumn":22},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":899,"column":11,"messageId":"unnecessaryAssignment","endLine":899,"endColumn":22},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":913,"column":11,"messageId":"unnecessaryAssignment","endLine":913,"endColumn":22},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":928,"column":11,"messageId":"unnecessaryAssignment","endLine":928,"endColumn":23},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":970,"column":11,"messageId":"unnecessaryAssignment","endLine":970,"endColumn":27},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":971,"column":11,"messageId":"unnecessaryAssignment","endLine":971,"endColumn":27},{"ruleId":"preserve-caught-error","severity":2,"message":"There is no `cause` attached to the symptom error being thrown.","line":978,"column":11,"messageId":"missingCause","endLine":978,"endColumn":42,"suggestions":[{"messageId":"includeCause","fix":{"range":[32122,32122],"text":", { cause: inner }"},"desc":"Include the original caught error as the `cause` of the symptom error."}]},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":1030,"column":11,"messageId":"unnecessaryAssignment","endLine":1030,"endColumn":23},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":1056,"column":11,"messageId":"unnecessaryAssignment","endLine":1056,"endColumn":23},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":1072,"column":11,"messageId":"unnecessaryAssignment","endLine":1072,"endColumn":26},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":1082,"column":11,"messageId":"unnecessaryAssignment","endLine":1082,"endColumn":31},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":1083,"column":11,"messageId":"unnecessaryAssignment","endLine":1083,"endColumn":27},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":1172,"column":11,"messageId":"unnecessaryAssignment","endLine":1172,"endColumn":27},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":1208,"column":11,"messageId":"unnecessaryAssignment","endLine":1208,"endColumn":22},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":1221,"column":11,"messageId":"unnecessaryAssignment","endLine":1221,"endColumn":26}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview Unit tests for ai-twitterActivity task\r\n * Tests configuration, initialization, execution, and cleanup flows\r\n * @module tests/unit/ai-twitter-activity.test\r\n */\r\n\r\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\r\n\r\n// Mock dependencies before imports\r\nconst mockPage = {\r\n  emulateMedia: vi.fn().mockResolvedValue(undefined),\r\n  goto: vi.fn().mockResolvedValue(undefined),\r\n  waitForSelector: vi.fn().mockResolvedValue(undefined),\r\n  waitForLoadState: vi.fn().mockResolvedValue(undefined),\r\n  waitForTimeout: vi.fn().mockResolvedValue(undefined),\r\n  setExtraHTTPHeaders: vi.fn().mockResolvedValue(undefined),\r\n  url: vi.fn().mockReturnValue('https://x.com/home'),\r\n  isClosed: vi.fn().mockReturnValue(false),\r\n  close: vi.fn().mockResolvedValue(undefined)\r\n};\r\n\r\nconst mockPayload = {\r\n  browserInfo: 'test-profile',\r\n  profileId: 'test-profile-123',\r\n  cycles: 5,\r\n  minDuration: 300,\r\n  maxDuration: 500,\r\n  taskTimeoutMs: 600000\r\n};\r\n\r\nconst mockConfig = {\r\n  init: vi.fn().mockResolvedValue(undefined),\r\n  getEngagementLimits: vi.fn().mockResolvedValue({\r\n    replies: 3,\r\n    retweets: 1,\r\n    quotes: 1,\r\n    likes: 5,\r\n    follows: 2,\r\n    bookmarks: 2\r\n  }),\r\n  getTwitterActivity: vi.fn().mockResolvedValue({\r\n    defaultCycles: 10,\r\n    defaultMinDuration: 300,\r\n    defaultMaxDuration: 540\r\n  }),\r\n  getTiming: vi.fn().mockResolvedValue({\r\n    warmupMin: 2000,\r\n    warmupMax: 15000\r\n  })\r\n};\r\n\r\nconst mockSettings = {\r\n  twitter: {\r\n    reply: { probability: 0.5 },\r\n    quote: { probability: 0.5 }\r\n  }\r\n};\r\n\r\nconst mockAgent = {\r\n  checkLoginState: vi.fn().mockResolvedValue(true),\r\n  runSession: vi.fn().mockResolvedValue(undefined),\r\n  state: {\r\n    follows: 2,\r\n    likes: 5,\r\n    retweets: 1,\r\n    tweets: 0\r\n  },\r\n  getAIStats: vi.fn().mockReturnValue({ attempts: 10, successes: 8 }),\r\n  engagementTracker: {\r\n    getSummary: vi.fn().mockReturnValue('likes: 5/5, replies: 3/3')\r\n  },\r\n  diveQueue: {\r\n    getFullStatus: vi.fn().mockReturnValue({\r\n      queue: { queueLength: 0, activeCount: 0, utilizationPercent: 0 },\r\n      engagement: {\r\n        likes: { current: 5, limit: 5 },\r\n        replies: { current: 3, limit: 3 },\r\n        bookmarks: { current: 2, limit: 2 }\r\n      }\r\n    }),\r\n    getEngagementProgress: vi.fn().mockReturnValue({\r\n      likes: { current: 5, limit: 5 },\r\n      replies: { current: 3, limit: 3 },\r\n      bookmarks: { current: 2, limit: 2 }\r\n    })\r\n  },\r\n  sessionStart: Date.now()\r\n};\r\n\r\nconst mockLogger = {\r\n  info: vi.fn(),\r\n  warn: vi.fn(),\r\n  error: vi.fn(),\r\n  debug: vi.fn()\r\n};\r\n\r\n// Create module mocks\r\nconst mockModuleImports = {\r\n  '../utils/logger.js': {\r\n    createLogger: vi.fn(() => mockLogger)\r\n  },\r\n  '../utils/configLoader.js': {\r\n    getSettings: vi.fn().mockResolvedValue(mockSettings)\r\n  },\r\n  '../utils/logging-config.js': {\r\n    getLoggingConfig: vi.fn().mockResolvedValue({\r\n      queueMonitor: { enabled: true, interval: 30000 },\r\n      finalStats: { showQueueStatus: true, showEngagement: true },\r\n      engagementProgress: { enabled: true }\r\n    }),\r\n    formatEngagementLine: vi.fn((action, data) => `${action}: ${data.current}/${data.limit}`)\r\n  },\r\n  '../utils/ai-twitterAgent.js': {\r\n    AITwitterAgent: vi.fn().mockImplementation(() => mockAgent)\r\n  },\r\n  '../utils/profileManager.js': {\r\n    getById: vi.fn().mockReturnValue({\r\n      id: 'test-profile-123',\r\n      type: 'engagement',\r\n      inputMethod: 'balanced',\r\n      inputMethodPct: 50,\r\n      probabilities: { dive: 30, like: 40, follow: 10 }\r\n    }),\r\n    getStarter: vi.fn().mockReturnValue({\r\n      id: 'starter-profile',\r\n      type: 'engagement',\r\n      inputMethod: 'balanced',\r\n      inputMethodPct: 50,\r\n      probabilities: { dive: 30, like: 40, follow: 10 }\r\n    })\r\n  },\r\n  '../utils/mathUtils.js': {\r\n    randomInRange: vi.fn((min, max) => (min + max) / 2)\r\n  },\r\n  '../utils/ghostCursor.js': {\r\n    GhostCursor: vi.fn().mockImplementation(() => ({}))\r\n  },\r\n  '../utils/entropyController.js': {\r\n    retryDelay: vi.fn().mockReturnValue(1000)\r\n  },\r\n  '../utils/urlReferrer.js': {\r\n    ReferrerEngine: vi.fn().mockImplementation(() => ({\r\n      generateContext: vi.fn().mockReturnValue({\r\n        headers: { 'User-Agent': 'Mozilla/5.0' },\r\n        referrer: 'https://google.com',\r\n        strategy: 'search'\r\n      })\r\n    }))\r\n  },\r\n  '../utils/metrics.js': {\r\n    default: {\r\n      recordSocialAction: vi.fn()\r\n    },\r\n    recordSocialAction: vi.fn()\r\n  },\r\n  '../utils/browserPatch.js': {\r\n    applyHumanizationPatch: vi.fn().mockResolvedValue(undefined)\r\n  },\r\n  '../utils/session-phases.js': {\r\n    sessionPhases: vi.fn().mockReturnValue({ warmup: true, active: true, cooldown: true })\r\n  },\r\n  '../utils/human-timing.js': {\r\n    getWarmupDelay: vi.fn().mockReturnValue(5000),\r\n    formatDuration: vi.fn().mockReturnValue('5s')\r\n  },\r\n  '../utils/config-service.js': {\r\n    config: mockConfig\r\n  },\r\n  '../constants/twitter-timeouts.js': {\r\n    TWITTER_TIMEOUTS: {\r\n      ELEMENT_VISIBLE: 5000,\r\n      NAVIGATION: 30000,\r\n      PAGE_LOAD: 30000\r\n    }\r\n  }\r\n};\r\n\r\n// Define constants for testing\r\nconst TARGET_URL = 'https://x.com';\r\nconst DEFAULT_CYCLES = 10;\r\nconst DEFAULT_MIN_DURATION = 300;\r\nconst DEFAULT_MAX_DURATION = 540;\r\nconst WARMUP_MIN = 2000;\r\nconst WARMUP_MAX = 15000;\r\nconst SCROLL_MIN = 300;\r\nconst SCROLL_MAX = 700;\r\nconst SESSION_PHASES = {\r\n  warmupPercent: 0.10,\r\n  activePercent: 0.70,\r\n  cooldownPercent: 0.20\r\n};\r\nconst MAX_RETRIES = 2;\r\nconst LOGIN_CHECK_LOOPS = 3;\r\nconst LOGIN_CHECK_DELAY = 3000;\r\n\r\ndescribe('ai-twitterActivity Task', () => {\r\n  describe('Configuration', () => {\r\n    it('should have correct default constants', () => {\r\n      // Test that constants are properly defined\r\n      expect(typeof TARGET_URL).toBe('string');\r\n      expect(TARGET_URL).toBe('https://x.com');\r\n      \r\n      expect(typeof DEFAULT_CYCLES).toBe('number');\r\n      expect(DEFAULT_CYCLES).toBe(10);\r\n      \r\n      expect(typeof DEFAULT_MIN_DURATION).toBe('number');\r\n      expect(DEFAULT_MIN_DURATION).toBe(300);\r\n      \r\n      expect(typeof DEFAULT_MAX_DURATION).toBe('number');\r\n      expect(DEFAULT_MAX_DURATION).toBe(540);\r\n    });\r\n\r\n    it('should have timing constants', () => {\r\n      expect(typeof WARMUP_MIN).toBe('number');\r\n      expect(WARMUP_MIN).toBe(2000);\r\n      \r\n      expect(typeof WARMUP_MAX).toBe('number');\r\n      expect(WARMUP_MAX).toBe(15000);\r\n      \r\n      expect(typeof SCROLL_MIN).toBe('number');\r\n      expect(SCROLL_MIN).toBe(300);\r\n      \r\n      expect(typeof SCROLL_MAX).toBe('number');\r\n      expect(SCROLL_MAX).toBe(700);\r\n    });\r\n\r\n    it('should have session phase settings', () => {\r\n      expect(SESSION_PHASES.warmupPercent).toBe(0.10);\r\n      expect(SESSION_PHASES.activePercent).toBe(0.70);\r\n      expect(SESSION_PHASES.cooldownPercent).toBe(0.20);\r\n    });\r\n\r\n    it('should have retry settings', () => {\r\n      expect(typeof MAX_RETRIES).toBe('number');\r\n      expect(MAX_RETRIES).toBe(2);\r\n      \r\n      expect(typeof LOGIN_CHECK_LOOPS).toBe('number');\r\n      expect(LOGIN_CHECK_LOOPS).toBe(3);\r\n      \r\n      expect(typeof LOGIN_CHECK_DELAY).toBe('number');\r\n      expect(LOGIN_CHECK_DELAY).toBe(3000);\r\n    });\r\n  });\r\n\r\n  describe('Engagement Limits Validation', () => {\r\n    it('should validate correct engagement limits', () => {\r\n      const validLimits = {\r\n        replies: 3,\r\n        retweets: 1,\r\n        quotes: 1,\r\n        likes: 5,\r\n        follows: 2,\r\n        bookmarks: 2\r\n      };\r\n      \r\n      const validated = {\r\n        replies: typeof validLimits.replies === 'number' && validLimits.replies > 0 ? validLimits.replies : 3,\r\n        retweets: typeof validLimits.retweets === 'number' && validLimits.retweets > 0 ? validLimits.retweets : 1,\r\n        quotes: typeof validLimits.quotes === 'number' && validLimits.quotes > 0 ? validLimits.quotes : 1,\r\n        likes: typeof validLimits.likes === 'number' && validLimits.likes > 0 ? validLimits.likes : 5,\r\n        follows: typeof validLimits.follows === 'number' && validLimits.follows > 0 ? validLimits.follows : 2,\r\n        bookmarks: typeof validLimits.bookmarks === 'number' && validLimits.bookmarks > 0 ? validLimits.bookmarks : 2\r\n      };\r\n      \r\n      expect(validated.replies).toBe(3);\r\n      expect(validated.likes).toBe(5);\r\n      expect(validated.follows).toBe(2);\r\n    });\r\n\r\n    it('should use defaults for invalid engagement limits', () => {\r\n      const invalidLimits = {\r\n        replies: -1,\r\n        retweets: 0,\r\n        quotes: null,\r\n        likes: undefined,\r\n        follows: 'invalid',\r\n        bookmarks: {}\r\n      };\r\n      \r\n      const validated = {\r\n        replies: typeof invalidLimits.replies === 'number' && invalidLimits.replies > 0 ? invalidLimits.replies : 3,\r\n        retweets: typeof invalidLimits.retweets === 'number' && invalidLimits.retweets > 0 ? invalidLimits.retweets : 1,\r\n        quotes: typeof invalidLimits.quotes === 'number' && invalidLimits.quotes > 0 ? invalidLimits.quotes : 1,\r\n        likes: typeof invalidLimits.likes === 'number' && invalidLimits.likes > 0 ? invalidLimits.likes : 5,\r\n        follows: typeof invalidLimits.follows === 'number' && invalidLimits.follows > 0 ? invalidLimits.follows : 2,\r\n        bookmarks: typeof invalidLimits.bookmarks === 'number' && invalidLimits.bookmarks > 0 ? invalidLimits.bookmarks : 2\r\n      };\r\n      \r\n      expect(validated.replies).toBe(3); // Default for negative\r\n      expect(validated.retweets).toBe(1); // Default for 0\r\n      expect(validated.quotes).toBe(1); // Default for null\r\n      expect(validated.likes).toBe(5); // Default for undefined\r\n      expect(validated.follows).toBe(2); // Default for string\r\n      expect(validated.bookmarks).toBe(2); // Default for object\r\n    });\r\n  });\r\n\r\n  describe('Probability Configuration', () => {\r\n    it('should extract reply probability from settings', () => {\r\n      const twitterSettings = { reply: { probability: 0.6 }, quote: { probability: 0.2 } };\r\n      const REPLY_PROBABILITY = twitterSettings.reply?.probability ?? 0.5;\r\n      expect(REPLY_PROBABILITY).toBe(0.6);\r\n    });\r\n\r\n    it('should use default probability when not set', () => {\r\n      const twitterSettings = {};\r\n      const REPLY_PROBABILITY = twitterSettings.reply?.probability ?? 0.5;\r\n      expect(REPLY_PROBABILITY).toBe(0.5);\r\n    });\r\n\r\n    it('should extract quote probability from settings', () => {\r\n      const twitterSettings = { reply: { probability: 0.5 }, quote: { probability: 0.3 } };\r\n      const QUOTE_PROBABILITY = twitterSettings.quote?.probability ?? 0.5;\r\n      expect(QUOTE_PROBABILITY).toBe(0.3);\r\n    });\r\n  });\r\n\r\n  describe('Payload Processing', () => {\r\n    it('should use payload cycles when provided', () => {\r\n      const payload = { cycles: 15 };\r\n      const cycles = typeof payload.cycles === 'number' ? payload.cycles : 10;\r\n      expect(cycles).toBe(15);\r\n    });\r\n\r\n    it('should use default cycles when not provided', () => {\r\n      const payload = {};\r\n      const cycles = typeof payload.cycles === 'number' ? payload.cycles : 10;\r\n      expect(cycles).toBe(10);\r\n    });\r\n\r\n    it('should use payload duration when provided', () => {\r\n      const payload = { minDuration: 600, maxDuration: 900 };\r\n      const minDuration = typeof payload.minDuration === 'number' ? payload.minDuration : 300;\r\n      const maxDuration = typeof payload.maxDuration === 'number' ? payload.maxDuration : 540;\r\n      expect(minDuration).toBe(600);\r\n      expect(maxDuration).toBe(900);\r\n    });\r\n\r\n    it('should use defaults when duration not provided', () => {\r\n      const payload = {};\r\n      const minDuration = typeof payload.minDuration === 'number' ? payload.minDuration : 300;\r\n      const maxDuration = typeof payload.maxDuration === 'number' ? payload.maxDuration : 540;\r\n      expect(minDuration).toBe(300);\r\n      expect(maxDuration).toBe(540);\r\n    });\r\n\r\n    it('should use browserInfo from payload', () => {\r\n      const payload = { browserInfo: 'test-browser-123' };\r\n      const browserInfo = payload.browserInfo || \"unknown_profile\";\r\n      expect(browserInfo).toBe('test-browser-123');\r\n    });\r\n\r\n    it('should use default browserInfo when not provided', () => {\r\n      const payload = {};\r\n      const browserInfo = payload.browserInfo || \"unknown_profile\";\r\n      expect(browserInfo).toBe(\"unknown_profile\");\r\n    });\r\n  });\r\n\r\n  describe('Timeout Calculations', () => {\r\n    it('should calculate hard timeout from payload', () => {\r\n      const payload = { taskTimeoutMs: 600000 };\r\n      const DEFAULT_MIN_DURATION = 300;\r\n      const DEFAULT_MAX_DURATION = 540;\r\n      const hardTimeoutMs = payload.taskTimeoutMs || (DEFAULT_MIN_DURATION + DEFAULT_MAX_DURATION) * 1000;\r\n      expect(hardTimeoutMs).toBe(600000);\r\n    });\r\n\r\n    it('should calculate default hard timeout', () => {\r\n      const payload = {};\r\n      const DEFAULT_MIN_DURATION = 300;\r\n      const DEFAULT_MAX_DURATION = 540;\r\n      const hardTimeoutMs = payload.taskTimeoutMs || (DEFAULT_MIN_DURATION + DEFAULT_MAX_DURATION) * 1000;\r\n      expect(hardTimeoutMs).toBe(840000);\r\n    });\r\n  });\r\n\r\n  describe('Retry Logic', () => {\r\n    it('should have correct retry count', () => {\r\n      const MAX_RETRIES = 2;\r\n      const attempts = MAX_RETRIES + 1; // Initial + retries\r\n      expect(attempts).toBe(3);\r\n    });\r\n\r\n    it('should calculate exponential backoff delays', () => {\r\n      const delays = [1, 2, 4].map(d => d * 1000); // 1s, 2s, 4s\r\n      expect(delays[0]).toBe(1000);\r\n      expect(delays[1]).toBe(2000);\r\n      expect(delays[2]).toBe(4000);\r\n    });\r\n  });\r\n\r\n  describe('Login Check Logic', () => {\r\n    it('should calculate progressive login check delays', () => {\r\n      let loginCheckDelay = 3000;\r\n      const delays = [];\r\n      \r\n      for (let i = 0; i < 3; i++) {\r\n        delays.push(loginCheckDelay);\r\n        if (i < 2) { // Only increase if not last iteration\r\n          loginCheckDelay = Math.min(loginCheckDelay + 1000, 5000);\r\n        }\r\n      }\r\n      \r\n      expect(delays[0]).toBe(3000); // Initial delay\r\n      expect(delays[1]).toBe(4000); // 3000 + 1000\r\n      expect(delays[2]).toBe(5000); // No increase on last iteration (stays at 5000)\r\n    });\r\n\r\n    it('should stop login check when logged in', () => {\r\n      let loggedIn = false;\r\n      const checks = [];\r\n      \r\n      for (let i = 0; i < 3; i++) {\r\n        if (loggedIn) {\r\n          checks.push({ index: i, loggedIn: true, stopped: true });\r\n          break;\r\n        }\r\n        checks.push({ index: i, loggedIn: false, stopped: false });\r\n        if (i === 0) loggedIn = true; // Simulate login on first check (after first iteration)\r\n      }\r\n      \r\n      expect(checks[0].stopped).toBe(false); // First check not stopped yet\r\n      expect(checks[1].stopped).toBe(true); // Second check should be stopped\r\n    });\r\n  });\r\n\r\n  describe('Queue Monitoring Configuration', () => {\r\n    it('should calculate monitoring interval from config', () => {\r\n      const logConfig = { queueMonitor: { interval: 60000 } };\r\n      const interval = logConfig?.queueMonitor?.interval || 30000;\r\n      expect(interval).toBe(60000);\r\n    });\r\n\r\n    it('should use default interval when not configured', () => {\r\n      const logConfig = {};\r\n      const interval = logConfig?.queueMonitor?.interval || 30000;\r\n      expect(interval).toBe(30000);\r\n    });\r\n\r\n    it('should stop monitoring after 3 errors', () => {\r\n      let monitorErrorCount = 0;\r\n      const maxErrors = 3;\r\n      \r\n      for (let i = 0; i < 5; i++) {\r\n        if (i < 3) monitorErrorCount++;\r\n      }\r\n      \r\n      expect(monitorErrorCount).toBe(3);\r\n      expect(monitorErrorCount >= maxErrors).toBe(true);\r\n    });\r\n  });\r\n\r\n  describe('Cleanup Logic', () => {\r\n    it('should track cleanup state', () => {\r\n      let cleanupPerformed = false;\r\n      \r\n      // First call should perform cleanup\r\n      if (!cleanupPerformed) {\r\n        cleanupPerformed = true;\r\n      }\r\n      \r\n      expect(cleanupPerformed).toBe(true);\r\n      \r\n      // Second call should skip cleanup\r\n      if (cleanupPerformed) return;\r\n      \r\n      expect(true).toBe(true); // Should reach here if logic is correct\r\n    });\r\n\r\n    it('should clear queue monitoring interval', () => {\r\n      const queueMonitorInterval = setInterval(() => {}, 30000);\r\n      \r\n      // Simulate clearing\r\n      clearInterval(queueMonitorInterval);\r\n      \r\n      expect(queueMonitorInterval).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('Profile Selection', () => {\r\n    it('should load profile by ID when provided', () => {\r\n      const payload = { profileId: 'test-123' };\r\n      const profile = payload.profileId\r\n        ? { id: 'test-123', type: 'engagement' }\r\n        : { id: 'starter', type: 'engagement' };\r\n      \r\n      expect(profile.id).toBe('test-123');\r\n    });\r\n\r\n    it('should use starter profile when no ID provided', () => {\r\n      const payload = {};\r\n      const profile = payload.profileId\r\n        ? { id: payload.profileId }\r\n        : { id: 'starter', type: 'engagement' };\r\n      \r\n      expect(profile.id).toBe('starter');\r\n    });\r\n  });\r\n\r\n  describe('Theme Configuration', () => {\r\n    it('should extract theme from profile', () => {\r\n      const profile = { theme: 'dark' };\r\n      const theme = profile?.theme || 'dark';\r\n      expect(theme).toBe('dark');\r\n    });\r\n\r\n    it('should default to dark theme when not set', () => {\r\n      const profile = {};\r\n      const theme = profile?.theme || 'dark';\r\n      expect(theme).toBe('dark');\r\n    });\r\n  });\r\n\r\n  describe('Duration Formatting', () => {\r\n    it('should format session duration correctly', () => {\r\n      const sessionStart = Date.now() - 600000; // 10 minutes ago\r\n      const duration = ((Date.now() - sessionStart) / 1000 / 60).toFixed(1);\r\n      expect(parseFloat(duration)).toBeCloseTo(10, 0);\r\n    });\r\n\r\n    it('should format total task duration correctly', () => {\r\n      const startTime = process.hrtime.bigint();\r\n      const endTime = startTime + BigInt(5 * 1000000000); // 5 seconds\r\n      const duration = (Number(endTime - startTime) / 1e9).toFixed(2);\r\n      expect(parseFloat(duration)).toBeCloseTo(5, 0);\r\n    });\r\n  });\r\n\r\n  describe('Metrics Recording', () => {\r\n    it('should record social actions when above threshold', () => {\r\n      const state = { follows: 2, likes: 5, retweets: 1, tweets: 0 };\r\n      \r\n      const actionsToRecord = [];\r\n      if (state.follows > 0) actionsToRecord.push('follow');\r\n      if (state.likes > 0) actionsToRecord.push('like');\r\n      if (state.retweets > 0) actionsToRecord.push('retweet');\r\n      if (state.tweets > 0) actionsToRecord.push('tweet');\r\n      \r\n      expect(actionsToRecord).toContain('follow');\r\n      expect(actionsToRecord).toContain('like');\r\n      expect(actionsToRecord).toContain('retweet');\r\n      expect(actionsToRecord).not.toContain('tweet');\r\n    });\r\n\r\n    it('should not record zero-value actions', () => {\r\n      const state = { follows: 0, likes: 0, retweets: 0, tweets: 0 };\r\n      \r\n      const actionsToRecord = [];\r\n      if (state.follows > 0) actionsToRecord.push('follow');\r\n      if (state.likes > 0) actionsToRecord.push('like');\r\n      if (state.retweets > 0) actionsToRecord.push('retweet');\r\n      if (state.tweets > 0) actionsToRecord.push('tweet');\r\n      \r\n      expect(actionsToRecord.length).toBe(0);\r\n    });\r\n  });\r\n\r\n  describe('Engagement Progress Logging', () => {\r\n    it('should format engagement line correctly', () => {\r\n      const action = 'likes';\r\n      const data = { current: 5, limit: 5 };\r\n      const line = `${action}: ${data.current}/${data.limit}`;\r\n      expect(line).toBe('likes: 5/5');\r\n    });\r\n\r\n    it('should handle partial engagement', () => {\r\n      const action = 'replies';\r\n      const data = { current: 2, limit: 3 };\r\n      const line = `${action}: ${data.current}/${data.limit}`;\r\n      expect(line).toBe('replies: 2/3');\r\n    });\r\n\r\n    it('should calculate engagement percentage', () => {\r\n      const current = 3;\r\n      const limit = 5;\r\n      const percentage = (current / limit) * 100;\r\n      expect(percentage).toBe(60);\r\n    });\r\n  });\r\n\r\n  describe('Queue Health Checks', () => {\r\n    it('should detect healthy queue', () => {\r\n      const queueStatus = {\r\n        queue: { utilizationPercent: 50 },\r\n        failedCount: 0,\r\n        timedOutCount: 0\r\n      };\r\n      \r\n      const isHealthy = queueStatus.failedCount === 0 && queueStatus.timedOutCount === 0;\r\n      expect(isHealthy).toBe(true);\r\n    });\r\n\r\n    it('should detect unhealthy queue', () => {\r\n      const queueStatus = {\r\n        queue: { utilizationPercent: 85 },\r\n        failedCount: 3,\r\n        timedOutCount: 2\r\n      };\r\n      \r\n      const isHealthy = queueStatus.failedCount === 0 && queueStatus.timedOutCount === 0;\r\n      expect(isHealthy).toBe(false);\r\n    });\r\n\r\n    it('should detect high utilization', () => {\r\n      const utilizationPercent = 85;\r\n      const isHighUtilization = utilizationPercent > 80;\r\n      expect(isHighUtilization).toBe(true);\r\n    });\r\n\r\n    it('should not flag normal utilization as high', () => {\r\n      const utilizationPercent = 60;\r\n      const isHighUtilization = utilizationPercent > 80;\r\n      expect(isHighUtilization).toBe(false);\r\n    });\r\n  });\r\n\r\n  describe('Session Duration Validation', () => {\r\n    it('should have valid min/max duration relationship', () => {\r\n      const minDuration = 300;\r\n      const maxDuration = 540;\r\n      expect(maxDuration).toBeGreaterThan(minDuration);\r\n    });\r\n\r\n    it('should calculate average duration', () => {\r\n      const minDuration = 300;\r\n      const maxDuration = 540;\r\n      const average = (minDuration + maxDuration) / 2;\r\n      expect(average).toBe(420);\r\n    });\r\n  });\r\n\r\n  describe('Error Handling', () => {\r\n    it('should handle errors during execution', () => {\r\n      const error = new Error('Test error');\r\n      const errorMessage = error.message;\r\n      expect(errorMessage).toBe('Test error');\r\n    });\r\n\r\n    it('should preserve error context', () => {\r\n      const innerError = new Error('Navigation failed');\r\n      const wrappedError = new Error(`Attempt failed: ${innerError.message}`);\r\n      expect(wrappedError.message).toContain('Navigation failed');\r\n    });\r\n\r\n    it('should handle null error gracefully', () => {\r\n      const error = null;\r\n      const errorMessage = error?.message || 'Unknown error';\r\n      expect(errorMessage).toBe('Unknown error');\r\n    });\r\n  });\r\n\r\n  describe('Payload Override Logic', () => {\r\n    it('should prioritize payload values over defaults', () => {\r\n      const payload = {\r\n        cycles: 20,\r\n        minDuration: 600,\r\n        maxDuration: 900,\r\n        taskTimeoutMs: 1200000\r\n      };\r\n      \r\n      const cycles = typeof payload.cycles === 'number' ? payload.cycles : 10;\r\n      const minDuration = typeof payload.minDuration === 'number' ? payload.minDuration : 300;\r\n      const maxDuration = typeof payload.maxDuration === 'number' ? payload.maxDuration : 540;\r\n      const taskTimeoutMs = payload.taskTimeoutMs || (minDuration + maxDuration) * 1000;\r\n      \r\n      expect(cycles).toBe(20);\r\n      expect(minDuration).toBe(600);\r\n      expect(maxDuration).toBe(900);\r\n      expect(taskTimeoutMs).toBe(1200000);\r\n    });\r\n  });\r\n});\r\n\r\ndescribe('ai-twitterActivity Integration Scenarios', () => {\r\n  describe('Successful Session Flow', () => {\r\n    it('should complete full session successfully', async () => {\r\n      // Simulate successful flow\r\n      const state = {\r\n        configLoaded: true,\r\n        agentInitialized: true,\r\n        pageNavigated: true,\r\n        loggedIn: true,\r\n        sessionStarted: true,\r\n        sessionCompleted: true,\r\n        cleanedUp: true\r\n      };\r\n      \r\n      const allSuccess = Object.values(state).every(v => v === true);\r\n      expect(allSuccess).toBe(true);\r\n    });\r\n\r\n    it('should handle early login detection', () => {\r\n      const loginChecks = 3;\r\n      let loginDetectedAt = 1; // Found on first check\r\n      \r\n      const checks = Array(loginChecks).fill(0).map((_, i) => ({\r\n        check: i + 1,\r\n        found: i + 1 <= loginDetectedAt\r\n      }));\r\n      \r\n      const successfulChecks = checks.filter(c => c.found).length;\r\n      expect(successfulChecks).toBe(1);\r\n    });\r\n  });\r\n\r\n  describe('Retry Scenario', () => {\r\n    it('should retry on failure and succeed', () => {\r\n      const MAX_RETRIES = 2;\r\n      let attempt = 0;\r\n      let succeeded = false;\r\n      \r\n      while (attempt <= MAX_RETRIES && !succeeded) {\r\n        attempt++;\r\n        if (attempt === 2) succeeded = true; // Succeed on second attempt\r\n      }\r\n      \r\n      expect(attempt).toBe(2);\r\n      expect(succeeded).toBe(true);\r\n    });\r\n\r\n    it('should fail after all retries exhausted', () => {\r\n      const MAX_RETRIES = 2;\r\n      let attempt = 0;\r\n      let failed = false;\r\n      \r\n      while (attempt <= MAX_RETRIES) {\r\n        attempt++;\r\n        if (attempt > MAX_RETRIES) failed = true;\r\n      }\r\n      \r\n      expect(attempt).toBe(3);\r\n      expect(failed).toBe(true);\r\n    });\r\n  });\r\n\r\n  describe('Queue Monitoring During Session', () => {\r\n    it('should start and stop monitoring', () => {\r\n      let monitoringActive = true;\r\n      let interval = setInterval(() => {}, 1000);\r\n      \r\n      // Simulate session start\r\n      monitoringActive = true;\r\n      \r\n      // Simulate session end\r\n      clearInterval(interval);\r\n      monitoringActive = false;\r\n      \r\n      expect(monitoringActive).toBe(false);\r\n    });\r\n\r\n    it('should handle monitoring errors gracefully', () => {\r\n      const errors = [null, new Error('Test error'), null];\r\n      const handledErrors = errors.map(err => {\r\n        if (err) {\r\n          return { handled: true, message: err.message };\r\n        }\r\n        return { handled: false };\r\n      });\r\n      \r\n      expect(handledErrors[0].handled).toBe(false);\r\n      expect(handledErrors[1].handled).toBe(true);\r\n    });\r\n  });\r\n\r\n  describe('Final Stats Reporting', () => {\r\n    it('should calculate engagement totals correctly', () => {\r\n      const agent = {\r\n        state: {\r\n          follows: 2,\r\n          likes: 5,\r\n          retweets: 1,\r\n          tweets: 0\r\n        }\r\n      };\r\n      \r\n      const totalEngagements = \r\n        agent.state.follows + \r\n        agent.state.likes + \r\n        agent.state.retweets + \r\n        agent.state.tweets;\r\n      \r\n      expect(totalEngagements).toBe(8);\r\n    });\r\n\r\n    it('should report AI stats structure', () => {\r\n      const aiStats = {\r\n        attempts: 15,\r\n        successes: 12,\r\n        failures: 3,\r\n        successRate: '80%'\r\n      };\r\n      \r\n      expect(aiStats).toHaveProperty('attempts');\r\n      expect(aiStats).toHaveProperty('successes');\r\n      expect(aiStats).toHaveProperty('failures');\r\n      expect(aiStats).toHaveProperty('successRate');\r\n    });\r\n  });\r\n});\r\n\r\ndescribe('ai-twitterActivity Edge Cases', () => {\r\n  describe('Empty Payload', () => {\r\n    it('should handle empty payload', () => {\r\n      const payload = {};\r\n      const browserInfo = payload.browserInfo || \"unknown_profile\";\r\n      const cycles = typeof payload.cycles === 'number' ? payload.cycles : 10;\r\n      \r\n      expect(browserInfo).toBe(\"unknown_profile\");\r\n      expect(cycles).toBe(10);\r\n    });\r\n  });\r\n\r\n  describe('Partial Configuration', () => {\r\n    it('should handle partial twitter settings', () => {\r\n      const twitterSettings = { reply: { probability: 0.8 } };\r\n      \r\n      const REPLY_PROBABILITY = twitterSettings.reply?.probability ?? 0.5;\r\n      const QUOTE_PROBABILITY = twitterSettings.quote?.probability ?? 0.5;\r\n      \r\n      expect(REPLY_PROBABILITY).toBe(0.8);\r\n      expect(QUOTE_PROBABILITY).toBe(0.5); // Default\r\n    });\r\n  });\r\n\r\n  describe('Zero Values', () => {\r\n    it('should handle zero engagement limits', () => {\r\n      const engagementLimits = {\r\n        replies: 0,\r\n        retweets: 0,\r\n        quotes: 0,\r\n        likes: 0,\r\n        follows: 0,\r\n        bookmarks: 0\r\n      };\r\n      \r\n      const validatedLimits = {\r\n        replies: typeof engagementLimits.replies === 'number' && engagementLimits.replies > 0 ? engagementLimits.replies : 3,\r\n        likes: typeof engagementLimits.likes === 'number' && engagementLimits.likes > 0 ? engagementLimits.likes : 5\r\n      };\r\n      \r\n      expect(validatedLimits.replies).toBe(3); // Default\r\n      expect(validatedLimits.likes).toBe(5); // Default\r\n    });\r\n  });\r\n\r\n  describe('Timeout Handling', () => {\r\n    it('should handle timeout edge case', () => {\r\n      const hardTimeoutMs = 0;\r\n      const fallbackTimeout = 1000;\r\n      const effectiveTimeout = hardTimeoutMs || fallbackTimeout;\r\n      \r\n      expect(effectiveTimeout).toBe(fallbackTimeout);\r\n    });\r\n\r\n    it('should handle very large timeout', () => {\r\n      const hardTimeoutMs = 3600000; // 1 hour\r\n      const effectiveTimeout = hardTimeoutMs || 840000;\r\n      \r\n      expect(effectiveTimeout).toBe(3600000);\r\n    });\r\n  });\r\n});\r\n\r\ndescribe('ai-twitterActivity Error Boundary Scenarios', () => {\r\n  describe('Session Error Recovery', () => {\r\n    it('should handle session error and attempt recovery', async () => {\r\n      // Simulate session error with recovery attempt\r\n      let sessionError = new Error('Test session error');\r\n      let recoveryAttempted = false;\r\n      \r\n      try {\r\n        throw sessionError;\r\n      } catch (error) {\r\n        // Simulate recovery attempt\r\n        recoveryAttempted = true;\r\n      }\r\n      \r\n      expect(recoveryAttempted).toBe(true);\r\n    });\r\n\r\n    it('should handle page close error gracefully', () => {\r\n      // Simulate page close error\r\n      const closeError = new Error('Page close failed');\r\n      let errorLogged = false;\r\n      \r\n      try {\r\n        throw closeError;\r\n      } catch (error) {\r\n        errorLogged = true;\r\n      }\r\n      \r\n      expect(errorLogged).toBe(true);\r\n    });\r\n\r\n    it('should handle navigation error during recovery', () => {\r\n      // Simulate navigation error during recovery\r\n      const navError = new Error('Navigation failed');\r\n      let errorCaught = false;\r\n      \r\n      try {\r\n        throw navError;\r\n      } catch (error) {\r\n        errorCaught = true;\r\n      }\r\n      \r\n      expect(errorCaught).toBe(true);\r\n    });\r\n\r\n    it('should not crash when agent is null during cleanup', () => {\r\n      // Simulate cleanup with null agent\r\n      const agent = null;\r\n      let cleanupSafe = false;\r\n      \r\n      if (agent) {\r\n        // This should not execute\r\n        cleanupSafe = false;\r\n      } else {\r\n        cleanupSafe = true;\r\n      }\r\n      \r\n      expect(cleanupSafe).toBe(true);\r\n    });\r\n\r\n    it('should handle page.isClosed() error gracefully', () => {\r\n      // Simulate page.isClosed() error\r\n      const pageError = new Error('Page context error');\r\n      let errorHandled = false;\r\n      \r\n      try {\r\n        throw pageError;\r\n      } catch {\r\n        errorHandled = true;\r\n      }\r\n      \r\n      expect(errorHandled).toBe(true);\r\n    });\r\n  });\r\n\r\n  describe('Error Boundary Flow', () => {\r\n    it('should complete error boundary flow correctly', () => {\r\n      // Simulate error boundary flow\r\n      const flow = {\r\n        tryEntered: false,\r\n        catchEntered: false,\r\n        finallyEntered: false,\r\n        recoveryAttempted: false,\r\n        recoverySucceeded: false\r\n      };\r\n\r\n      try {\r\n        flow.tryEntered = true;\r\n        throw new Error('Test error');\r\n      } catch (error) {\r\n        flow.catchEntered = true;\r\n        flow.recoveryAttempted = true;\r\n        flow.recoverySucceeded = true; // Simulated success\r\n      } finally {\r\n        flow.finallyEntered = true;\r\n      }\r\n\r\n      expect(flow.tryEntered).toBe(true);\r\n      expect(flow.catchEntered).toBe(true);\r\n      expect(flow.finallyEntered).toBe(true);\r\n      expect(flow.recoveryAttempted).toBe(true);\r\n      expect(flow.recoverySucceeded).toBe(true);\r\n    });\r\n\r\n    it('should handle nested error scenarios', () => {\r\n      let innerErrorCaught = false;\r\n      let outerErrorCaught = false;\r\n\r\n      try {\r\n        throw new Error('Inner error');\r\n      } catch (inner) {\r\n        innerErrorCaught = true;\r\n        try {\r\n          throw new Error('Outer error');\r\n        } catch (outer) {\r\n          outerErrorCaught = true;\r\n        }\r\n      }\r\n\r\n      expect(innerErrorCaught).toBe(true);\r\n      expect(outerErrorCaught).toBe(true);\r\n    });\r\n  });\r\n});\r\n\r\ndescribe('ai-twitterActivity Queue Monitoring Scenarios', () => {\r\n  describe('Queue Monitor Error Handling', () => {\r\n    it('should stop monitoring after 3 errors', () => {\r\n      let errorCount = 0;\r\n      const maxErrors = 3;\r\n      let monitoringStopped = false;\r\n\r\n      // Simulate 3 errors\r\n      for (let i = 0; i < 5; i++) {\r\n        if (!monitoringStopped) {\r\n          errorCount++;\r\n          if (errorCount >= maxErrors) {\r\n            monitoringStopped = true;\r\n          }\r\n        }\r\n      }\r\n\r\n      expect(errorCount).toBe(3);\r\n      expect(monitoringStopped).toBe(true);\r\n    });\r\n\r\n    it('should reset error count on success', () => {\r\n      let errorCount = 0;\r\n      const maxErrors = 3;\r\n\r\n      // First failure\r\n      errorCount++;\r\n      expect(errorCount).toBe(1);\r\n\r\n      // Success resets\r\n      errorCount = 0;\r\n\r\n      // Second failure\r\n      errorCount++;\r\n      expect(errorCount).toBe(1);\r\n    });\r\n\r\n    it('should handle queue status error gracefully', () => {\r\n      // Simulate queue status error\r\n      const queueError = new Error('Queue status unavailable');\r\n      let errorHandled = false;\r\n\r\n      try {\r\n        throw queueError;\r\n      } catch {\r\n        errorHandled = true;\r\n      }\r\n\r\n      expect(errorHandled).toBe(true);\r\n    });\r\n\r\n    it('should handle diveQueue null gracefully', () => {\r\n      // Simulate diveQueue being null\r\n      const agent = { diveQueue: null };\r\n      let errorCount = 0;\r\n\r\n      if (!agent || !agent.diveQueue) {\r\n        errorCount++;\r\n      }\r\n\r\n      expect(errorCount).toBe(1);\r\n    });\r\n\r\n    it('should handle getFullStatus error', () => {\r\n      // Simulate getFullStatus error\r\n      const statusError = new Error('getFullStatus failed');\r\n      let errorHandled = false;\r\n\r\n      try {\r\n        throw statusError;\r\n      } catch {\r\n        errorHandled = true;\r\n      }\r\n\r\n      expect(errorHandled).toBe(true);\r\n    });\r\n  });\r\n\r\n  describe('Queue Monitor Duplicate Prevention', () => {\r\n    it('should clear existing interval before starting new one', () => {\r\n      // Simulate clearing existing interval\r\n      let existingInterval = setInterval(() => {}, 30000);\r\n      let intervalCleared = false;\r\n\r\n      // Clear before starting new\r\n      clearInterval(existingInterval);\r\n      intervalCleared = true;\r\n\r\n      expect(intervalCleared).toBe(true);\r\n    });\r\n\r\n    it('should track monitoring state correctly', () => {\r\n      let queueMonitorInterval = null;\r\n      let monitoringActive = false;\r\n\r\n      // Start monitoring\r\n      queueMonitorInterval = setInterval(() => {}, 30000);\r\n      monitoringActive = true;\r\n\r\n      expect(monitoringActive).toBe(true);\r\n      expect(queueMonitorInterval).not.toBeNull();\r\n\r\n      // Stop monitoring\r\n      clearInterval(queueMonitorInterval);\r\n      queueMonitorInterval = null;\r\n      monitoringActive = false;\r\n\r\n      expect(monitoringActive).toBe(false);\r\n      expect(queueMonitorInterval).toBeNull();\r\n    });\r\n  });\r\n\r\n  describe('Queue Monitor High Utilization', () => {\r\n    it('should detect high queue utilization', () => {\r\n      const utilizationPercent = 85;\r\n      const isHighUtilization = utilizationPercent > 80;\r\n\r\n      expect(isHighUtilization).toBe(true);\r\n    });\r\n\r\n    it('should not flag normal utilization as high', () => {\r\n      const utilizationPercent = 60;\r\n      const isHighUtilization = utilizationPercent > 80;\r\n\r\n      expect(isHighUtilization).toBe(false);\r\n    });\r\n\r\n    it('should handle utilization calculation edge case', () => {\r\n      const queueStats = {\r\n        queueLength: 0,\r\n        activeCount: 0,\r\n        utilizationPercent: 0\r\n      };\r\n\r\n      const isHealthy = queueStats.utilizationPercent <= 80;\r\n\r\n      expect(isHealthy).toBe(true);\r\n    });\r\n  });\r\n});\r\n\r\ndescribe('ai-twitterActivity Session Duration Edge Cases', () => {\r\n  describe('Duration Calculation', () => {\r\n    it('should calculate duration when sessionStart is valid', () => {\r\n      const sessionStart = Date.now() - 600000; // 10 minutes ago\r\n      const duration = ((Date.now() - sessionStart) / 1000 / 60).toFixed(1);\r\n\r\n      expect(parseFloat(duration)).toBeCloseTo(10, 0);\r\n    });\r\n\r\n    it('should handle undefined sessionStart', () => {\r\n      const sessionStart = undefined;\r\n      const sessionStartTime = sessionStart || Date.now();\r\n      const duration = ((Date.now() - sessionStartTime) / 1000 / 60).toFixed(1);\r\n\r\n      // Should calculate 0 duration (or very close to 0)\r\n      expect(parseFloat(duration)).toBeLessThanOrEqual(0.1);\r\n    });\r\n\r\n    it('should handle null sessionStart', () => {\r\n      const sessionStart = null;\r\n      const sessionStartTime = sessionStart || Date.now();\r\n      const duration = ((Date.now() - sessionStartTime) / 1000 / 60).toFixed(1);\r\n\r\n      // Should calculate 0 duration (or very close to 0)\r\n      expect(parseFloat(duration)).toBeLessThanOrEqual(0.1);\r\n    });\r\n\r\n    it('should handle zero sessionStart', () => {\r\n      const sessionStart = 0;\r\n      const sessionStartTime = sessionStart || Date.now();\r\n      const duration = ((Date.now() - sessionStartTime) / 1000 / 60).toFixed(1);\r\n\r\n      // Should calculate 0 duration (or very close to 0)\r\n      expect(parseFloat(duration)).toBeLessThanOrEqual(0.1);\r\n    });\r\n  });\r\n});\r\n\r\ndescribe('ai-twitterActivity Cleanup Scenarios', () => {\r\n  describe('Cleanup Race Condition Prevention', () => {\r\n    it('should set cleanupPerformed flag before cleanup logic', () => {\r\n      let cleanupPerformed = false;\r\n      let cleanupLogicRan = false;\r\n\r\n      // Simulate correct order: flag first, then cleanup\r\n      cleanupPerformed = true;\r\n      \r\n      if (cleanupPerformed) {\r\n        cleanupLogicRan = true;\r\n      }\r\n\r\n      expect(cleanupLogicRan).toBe(true);\r\n    });\r\n\r\n    it('should not run cleanup twice when flag is set', () => {\r\n      let cleanupCount = 0;\r\n      let cleanupPerformed = false;\r\n\r\n      // Simulate cleanup function with guard clause\r\n      const runCleanup = () => {\r\n        if (cleanupPerformed) return; // Guard: skip if already performed\r\n        cleanupPerformed = true;\r\n        cleanupCount++;\r\n      };\r\n\r\n      // First cleanup\r\n      runCleanup();\r\n      expect(cleanupCount).toBe(1);\r\n      expect(cleanupPerformed).toBe(true);\r\n\r\n      // Second cleanup attempt - should not run due to guard\r\n      runCleanup();\r\n      expect(cleanupCount).toBe(1); // Still 1, not incremented\r\n    });\r\n\r\n    it('should handle cleanup with null agent', () => {\r\n      let agent = null;\r\n      let cleanupSafe = false;\r\n\r\n      if (agent) {\r\n        cleanupSafe = false;\r\n      } else {\r\n        cleanupSafe = true;\r\n      }\r\n\r\n      expect(cleanupSafe).toBe(true);\r\n    });\r\n\r\n    it('should handle cleanup with null diveQueue', () => {\r\n      const agent = { diveQueue: null };\r\n      let diveQueueExists = false;\r\n\r\n      if (agent.diveQueue) {\r\n        diveQueueExists = true;\r\n      } else {\r\n        diveQueueExists = false;\r\n      }\r\n\r\n      expect(diveQueueExists).toBe(false);\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\My Script\\auto-ai\\tests\\unit\\index.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'aiTwitterActivity' is not defined.","line":35,"column":44,"messageId":"undef","endLine":35,"endColumn":61},{"ruleId":"no-undef","severity":2,"message":"'aiTwitterAgent' is not defined.","line":36,"column":41,"messageId":"undef","endLine":36,"endColumn":55},{"ruleId":"no-undef","severity":2,"message":"'asyncQueue' is not defined.","line":37,"column":36,"messageId":"undef","endLine":37,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'configService' is not defined.","line":38,"column":39,"messageId":"undef","endLine":38,"endColumn":52},{"ruleId":"no-undef","severity":2,"message":"'engagementLimits' is not defined.","line":39,"column":42,"messageId":"undef","endLine":39,"endColumn":58},{"ruleId":"no-undef","severity":2,"message":"'humanInteraction' is not defined.","line":40,"column":42,"messageId":"undef","endLine":40,"endColumn":58},{"ruleId":"no-undef","severity":2,"message":"'smartProb' is not defined.","line":41,"column":35,"messageId":"undef","endLine":41,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'actionConfig' is not defined.","line":42,"column":38,"messageId":"undef","endLine":42,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'actions' is not defined.","line":43,"column":32,"messageId":"undef","endLine":43,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'simpleDive' is not defined.","line":44,"column":36,"messageId":"undef","endLine":44,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'humanMethods' is not defined.","line":45,"column":38,"messageId":"undef","endLine":45,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'modularMethods' is not defined.","line":46,"column":40,"messageId":"undef","endLine":46,"endColumn":54},{"ruleId":"no-undef","severity":2,"message":"'replyMethod' is not defined.","line":47,"column":37,"messageId":"undef","endLine":47,"endColumn":48}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Unit Tests Index\r\n * \r\n * This file re-exports all unit tests for aggregated testing.\r\n * Import paths using @tests alias:\r\n *   import { describe, it, expect } from 'vitest';\r\n *   import * as unitTests from '@tests/unit';\r\n */\r\n\r\nexport { default as aiTwitterActivity } from './ai-twitter-activity.test.js';\r\nexport { default as aiTwitterAgent } from './ai-twitterAgent.test.js';\r\nexport { default as asyncQueue } from './async-queue.test.js';\r\nexport { default as configService } from './config-service.test.js';\r\nexport { default as engagementLimits } from './engagement-limits.test.js';\r\nexport { default as humanInteraction } from './human-interaction.test.js';\r\nexport { default as smartProb } from './test-smart-prob.js';\r\nexport { default as actionConfig } from './test-action-config.js';\r\nexport { default as actions } from './test-actions.js';\r\nexport { default as simpleDive } from './test-simple-dive.js';\r\nexport { default as humanMethods } from './test-human-methods.js';\r\nexport { default as modularMethods } from './test-modular-methods.js';\r\nexport { default as replyMethod } from './test-reply-method.js';\r\n\r\n/**\r\n * Run all unit tests\r\n */\r\nexport async function runAllUnitTests() {\r\n  const results = {\r\n    passed: 0,\r\n    failed: 0,\r\n    tests: []\r\n  };\r\n\r\n  const testModules = [\r\n    { name: 'ai-twitter-activity', module: aiTwitterActivity },\r\n    { name: 'ai-twitter-agent', module: aiTwitterAgent },\r\n    { name: 'async-queue', module: asyncQueue },\r\n    { name: 'config-service', module: configService },\r\n    { name: 'engagement-limits', module: engagementLimits },\r\n    { name: 'human-interaction', module: humanInteraction },\r\n    { name: 'smart-prob', module: smartProb },\r\n    { name: 'action-config', module: actionConfig },\r\n    { name: 'actions', module: actions },\r\n    { name: 'simple-dive', module: simpleDive },\r\n    { name: 'human-methods', module: humanMethods },\r\n    { name: 'modular-methods', module: modularMethods },\r\n    { name: 'reply-method', module: replyMethod }\r\n  ];\r\n\r\n  for (const { name, module } of testModules) {\r\n    try {\r\n      results.tests.push({ name, status: 'loaded' });\r\n      results.passed++;\r\n    } catch (error) {\r\n      results.tests.push({ name, status: 'failed', error: error.message });\r\n      results.failed++;\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\My Script\\auto-ai\\utils\\ai-context-engine.js","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":462,"column":24,"messageId":"unnecessaryEscape","endLine":462,"endColumn":25,"suggestions":[{"messageId":"removeEscape","fix":{"range":[17407,17408],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[17407,17407],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":545,"column":18,"messageId":"unnecessaryEscape","endLine":545,"endColumn":19,"suggestions":[{"messageId":"removeEscape","fix":{"range":[20364,20365],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[20364,20364],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":659,"column":17,"messageId":"unexpected","endLine":659,"endColumn":19,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[24380,24380],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Enhanced AI Context Engine\n * Provides richer context extraction including sentiment, tone, and engagement metrics\n * @module utils/ai-context-engine\n */\n\nimport { createLogger } from './logger.js';\nimport { mathUtils } from './mathUtils.js';\nimport { config } from './config-service.js';\n\nconst logger = createLogger('ai-context-engine.js');\n\nexport class AIContextEngine {\n  constructor(options = {}) {\n    this.logger = createLogger('ai-context-engine.js');\n    \n    // Sentiment indicators (simple keyword-based)\n    this.sentimentIndicators = {\n      positive: [\n        'love', 'great', 'amazing', 'awesome', 'beautiful', 'wonderful',\n        'fantastic', 'excellent', 'happy', 'excited', 'glad', 'blessed',\n        'perfect', 'best', 'incredible', ' stunning', 'brilliant',\n        'favorite', 'appreciate', 'thanks', 'thank', 'grateful', 'yay',\n        'woohoo', '', '', '', '', '', '', '', ''\n      ],\n      negative: [\n        'hate', 'terrible', 'awful', 'horrible', 'worst', 'bad', 'sad',\n        'angry', 'frustrated', 'annoyed', 'disappointed', 'upset',\n        'sucks', 'pathetic', 'disgusting', 'ridiculous', 'furious',\n        'crying', 'tears', 'death', 'died', 'lost', 'gone', 'miss',\n        '', '', '', '', '', ''\n      ],\n      humorous: [\n        'lol', 'lmao', 'rofl', 'haha', 'ahaha', 'funny', 'lolol',\n        '', '', '', '', '', ' '\n      ],\n      informational: [\n        'update', 'breaking', 'news', 'report', 'according to', 'source',\n        'announced', 'revealed', 'confirmed', 'official', 'statement',\n        'here\\'s why', 'here\\'s what', 'did you know', 'tip:', 'guide'\n      ],\n      emotional: [\n        'feel', 'feeling', 'heart', 'soul', 'struggle', 'journey',\n        'overcome', 'proud', 'accomplish', 'dream', 'hope', 'wish',\n        'pray', 'believe', 'faith', 'moment', 'memory', 'remind'\n      ]\n    };\n\n    this.config = {\n      maxReplies: options.maxReplies ?? 50,\n      sentimentThreshold: options.sentimentThreshold ?? 0.3,\n      includeMetrics: options.includeMetrics ?? true\n    };\n  }\n\n  /**\n   * Extract comprehensive context from tweet page\n   * @param {object} page - Playwright page\n   * @param {string} tweetUrl - Current tweet URL\n   * @param {string} tweetText - Main tweet text\n   * @param {string} authorUsername - Tweet author\n   * @returns {Promise<object>} Enhanced context\n   */\n  async extractEnhancedContext(page, tweetUrl, tweetText, authorUsername) {\n    const context = {\n      url: tweetUrl,\n      tweetText: tweetText,\n      author: authorUsername,\n      replies: [],\n      metrics: null,\n      sentiment: null,\n      tone: null,\n      conversationType: null,\n      replySentiment: null,\n      engagementLevel: 'unknown',\n      extractedAt: new Date().toISOString()\n    };\n\n    try {\n      // Extract engagement metrics\n      if (this.config.includeMetrics) {\n        context.metrics = await this.extractMetrics(page);\n        context.engagementLevel = this.calculateEngagementLevel(context.metrics);\n      }\n\n      // Extract replies\n      const extractedReplies = await this.extractRepliesSmart(page);\n      context.replies = extractedReplies.slice(0, this.config.maxReplies);\n\n      // Analyze main tweet\n      context.sentiment = this.analyzeSentiment(tweetText);\n      context.tone = this.detectTone(tweetText);\n      context.conversationType = this.classifyConversation(tweetText, context.replies);\n\n      // Analyze replies\n      context.replySentiment = this.analyzeReplySentiment(context.replies);\n\n      // Check for images and capture screenshot if present\n      const hasImage = await this.checkForTweetImage(page);\n      if (hasImage) {\n        context.screenshot = await this.captureTweetScreenshot(page);\n        this.logger.info(`[Context] Captured screenshot of tweet with image`);\n      }\n\n      this.logger.info(`[Context] Enhanced context: ${context.sentiment?.overall}, tone: ${context.tone?.primary}, ${context.replies.length} replies, ${context.engagementLevel} engagement`);\n\n    } catch (error) {\n      this.logger.warn(`[Context] Enhanced extraction failed: ${error.message}`);\n    }\n\n    return context;\n  }\n\n  /**\n   * Extract engagement metrics from tweet\n   */\n  async extractMetrics(page) {\n    const metrics = {\n      likes: 0,\n      retweets: 0,\n      replies: 0,\n      views: 0,\n      bookmarks: 0\n    };\n\n    try {\n      // Look for metrics in the DOM\n      const metricsText = await page.evaluate(() => {\n        const elements = document.querySelectorAll('[data-testid], [aria-label*=\"like\"], [aria-label*=\"retweet\"], [aria-label*=\"reply\"], [aria-label*=\"view\"]');\n        return Array.from(elements).map(el => ({\n          aria: el.getAttribute('aria-label') || '',\n          text: el instanceof HTMLElement ? el.innerText : ''\n        }));\n      });\n\n      // Parse metrics from aria-labels and text\n      for (const item of metricsText) {\n        const text = item.text || item.aria;\n        \n        // Extract numbers with K/M suffixes\n        const numberMatch = text.match(/[\\d,.]+[KM]?/);\n        if (numberMatch) {\n          const num = this.parseNumber(numberMatch[0]);\n          \n          if (text.toLowerCase().includes('like') && metrics.likes === 0) {\n            metrics.likes = num;\n          } else if (text.toLowerCase().includes('retweet') && metrics.retweets === 0) {\n            metrics.retweets = num;\n          } else if (text.toLowerCase().includes('reply') && metrics.replies === 0) {\n            metrics.replies = num;\n          } else if ((text.toLowerCase().includes('view') || text.toLowerCase().includes('impression')) && metrics.views === 0) {\n            metrics.views = num;\n          } else if (text.toLowerCase().includes('bookmark') && metrics.bookmarks === 0) {\n            metrics.bookmarks = num;\n          }\n        }\n      }\n\n    } catch (error) {\n      this.logger.debug(`[Context] Metrics extraction: ${error.message}`);\n    }\n\n    return metrics;\n  }\n\n  /**\n   * Parse number with K/M suffixes\n   */\n  parseNumber(str) {\n    if (!str) return 0;\n    str = str.toUpperCase().replace(/,/g, '');\n    \n    if (str.includes('K')) {\n      return Math.floor(parseFloat(str) * 1000);\n    } else if (str.includes('M')) {\n      return Math.floor(parseFloat(str) * 1000000);\n    }\n    return parseInt(str) || 0;\n  }\n\n  /**\n   * Calculate engagement level from metrics\n   */\n  calculateEngagementLevel(metrics) {\n    if (!metrics) return 'unknown';\n    \n    const total = (metrics.likes || 0) + (metrics.retweets || 0) + (metrics.replies || 0);\n    const views = metrics.views || 0;\n    \n    if (views > 100000) return 'viral';\n    if (total > 1000) return 'high';\n    if (total > 100) return 'medium';\n    if (total > 10) return 'low';\n    return 'minimal';\n  }\n\n  /**\n   * Check if the main tweet contains an image\n   * @param {object} page - Playwright page\n   * @returns {Promise<boolean>}\n   */\n  async checkForTweetImage(page) {\n    try {\n      return await page.evaluate(() => {\n        // Check for tweet photos or video thumbnails in the first article (main tweet)\n        const mainTweet = document.querySelector('article');\n        if (!mainTweet) return false;\n        \n        const hasPhoto = mainTweet.querySelector('[data-testid=\"tweetPhoto\"]') !== null;\n        const hasVideo = mainTweet.querySelector('[data-testid=\"videoPlayer\"]') !== null;\n        const hasCard = mainTweet.querySelector('[data-testid=\"card.wrapper\"]') !== null;\n        \n        return hasPhoto || hasVideo || hasCard;\n      });\n    } catch (error) {\n      this.logger.debug(`[Context] Image check failed: ${error.message}`);\n      return false;\n    }\n  }\n\n  /**\n   * Capture screenshot of the main tweet\n   * @param {object} page - Playwright page\n   * @returns {Promise<Buffer>}\n   */\n  async captureTweetScreenshot(page) {\n    try {\n      // Scroll to top to ensure tweet is visible\n      await page.evaluate(() => window.scrollTo(0, 0));\n      await page.waitForTimeout(500); // Wait for scroll/render\n      \n      // Try to capture just the tweet element first\n      const tweetElement = await page.$('article');\n      if (tweetElement) {\n        return await tweetElement.screenshot({ type: 'jpeg', quality: 80 });\n      }\n      \n      // Fallback to viewport screenshot\n      return await page.screenshot({ type: 'jpeg', quality: 80, fullPage: false });\n    } catch (error) {\n      this.logger.warn(`[Context] Screenshot capture failed: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\n   * Smart reply extraction with deduplication\n   * Now properly scrolls and extracts 15-30 replies for LLM context\n   */\n  async extractRepliesSmart(page) {\n    const replies = [];\n    const seenTexts = new Set();\n\n    try {\n      this.logger.info(`[Context] Starting comprehensive reply extraction...`);\n\n      // Step 1: Scroll to bottom slowly to trigger lazy loading (human-like)\n      this.logger.debug(`[Context] Step 1: Slowly scrolling to load all replies...`);\n      \n      for (let scroll = 0; scroll < 10; scroll++) {\n        await page.evaluate(() => window.scrollBy(0, 500)); // Scroll incrementally\n        await page.waitForTimeout(mathUtils.randomInRange(800, 1500)); // Slow delay\n      }\n\n      // Step 2: Wait for content to settle\n      await page.waitForTimeout(1000);\n\n      // Step 3: Now scroll UP through the page while extracting\n      this.logger.debug(`[Context] Step 2: Extracting while scrolling up...`);\n      \n      const viewportHeight = await page.evaluate(() => window.innerHeight);\n      const scrollHeight = await page.evaluate(() => document.body.scrollHeight);\n      const extractSteps = Math.min(20, Math.ceil(scrollHeight / viewportHeight));\n\n      for (let step = 0; step < extractSteps; step++) {\n        // Extract visible tweet texts at current scroll position\n        const visibleTexts = await page.evaluate(() => {\n          const found = [];\n          const seen = new Set();\n          \n          // Multiple selectors for current Twitter DOM\n          const selectors = [\n            '[data-testid=\"tweetText\"]',\n            '[class*=\"tweetText\"]',\n            '[class*=\"replyText\"]',\n            'article [dir=\"auto\"]',\n            '[role=\"article\"] span'\n          ];\n          \n          for (const selector of selectors) {\n            const elements = document.querySelectorAll(selector);\n            elements.forEach(el => {\n              const text = el instanceof HTMLElement ? el.innerText.trim() : '';\n              // Relaxed requirement: allow any meaningful text, not just @mentions\n              // This helps with Korean/Japanese tweets that may not use @mentions\n              if (text && text.length > 3 && text.length < 300) {\n                const key = text.substring(0, 50).toLowerCase();\n                if (!seen.has(key)) {\n                  seen.add(key);\n                  found.push(text);\n                }\n              }\n            });\n          }\n          return found;\n        });\n\n        for (const text of visibleTexts) {\n          const key = text.toLowerCase().substring(0, 50);\n          if (seenTexts.has(key)) continue;\n          \n          // Extract author from @mention if present, otherwise use DOM hierarchy\n          const mentionMatch = text.match(/@(\\w+)/);\n          let author = mentionMatch ? mentionMatch[1] : 'unknown';\n          \n          // If no @mention, try to extract author from DOM context\n          if (author === 'unknown') {\n            author = await this.extractAuthorFromVisibleText(page, text);\n          }\n          \n          // Clean the reply text - preserve @mentions that are in-content\n          const cleaned = this.cleanReplyText(text);\n          \n          // Accept shorter replies (3+ chars) to capture short responses\n          if (cleaned.length > 3) {\n            seenTexts.add(key);\n            replies.push({\n              author: author,\n              text: cleaned,\n              length: cleaned.length,\n              hasMention: mentionMatch !== null\n            });\n          }\n        }\n\n        // Scroll up for next extraction (slow and human-like)\n        if (step < extractSteps - 1) {\n          await page.evaluate(({ step, totalSteps }) => {\n            const pos = (document.body.scrollHeight / totalSteps) * step;\n            window.scrollTo(0, document.body.scrollHeight - pos);\n          }, { step, totalSteps: extractSteps });\n          await page.waitForTimeout(mathUtils.randomInRange(600, 1200)); // Slower extraction\n        }\n\n        if (replies.length >= 30) {\n          this.logger.debug(`[Context] Target reached: ${replies.length} replies`);\n          break;\n        }\n      }\n\n      // Step 4: Final scroll to top and extract any remaining\n      await page.evaluate(() => window.scrollTo(0, 0));\n      await page.waitForTimeout(500);\n\n      // Strategy 1: Use article elements (most reliable) - but filter out main tweet\n      if (replies.length < 15) {\n        this.logger.debug(`[Context] Strategy 1: Extracting from article elements...`);\n        const articles = await page.$$('article');\n        this.logger.debug(`[Context] Found ${articles.length} articles`);\n\n        for (const article of articles.slice(0, 50)) {\n          try {\n            // Skip if this is the main tweet (usually first/largest article)\n            const articleHeight = await article.evaluate(el => el.getBoundingClientRect().height);\n            if (articleHeight < 100) continue; // Skip very small articles (likely engagement counts)\n\n            const data = await this.extractReplyFromArticle(article);\n            if (data && data.text && data.text.length > 3 && data.author !== 'unknown') {\n              const key = data.text.toLowerCase().substring(0, 50);\n              if (!seenTexts.has(key)) {\n                seenTexts.add(key);\n                replies.push(data);\n                this.logger.debug(`[Context] Extracted reply from article: @${data.author}: \"${data.text.substring(0, 30)}...\"`);\n              }\n            }\n          } catch (e) {\n            this.logger.debug(`[Context] Article extraction error: ${e.message}`);\n          }\n        }\n        this.logger.debug(`[Context] Strategy 1 extracted ${replies.length} replies`);\n      }\n\n      // Strategy 2: Fallback to tweetText elements\n      if (replies.length < 15) {\n        this.logger.debug(`[Context] Strategy 2: Using tweetText selectors...`);\n        const tweetTexts = await page.$$('[data-testid=\"tweetText\"]');\n        \n        for (const el of tweetTexts.slice(1, 60)) {\n          try {\n            const text = await el.innerText().catch(() => '');\n            if (text && text.length > 3) {\n              const key = text.toLowerCase().substring(0, 50);\n              if (!seenTexts.has(key)) {\n                seenTexts.add(key);\n                const mentionMatch = text.match(/@(\\w+)/);\n                replies.push({\n                  author: mentionMatch ? mentionMatch[1] : 'unknown',\n                  text: this.cleanReplyText(text),\n                  length: text.length,\n                  hasMention: text.includes('@')\n                });\n              }\n            }\n          } catch (error) {\n            this.logger.debug(`[Context] Tweet text extraction failed: ${error.message}`);\n          }\n        }\n      }\n\n      // Strategy 3: Deep DOM extraction if still few replies\n      if (replies.length < 10) {\n        this.logger.debug(`[Context] Strategy 3: Deep DOM extraction...`);\n        \n        // For deep extraction, accept any text that looks like a reply\n        // Not just @mentions - includes Korean, Japanese, emoji-heavy replies\n        const deepTexts = await page.evaluate(() => {\n          const found = [];\n          const seen = new Set();\n          \n          // Look for text in article elements (replies are always in articles)\n          const articles = document.querySelectorAll('article');\n          \n          articles.forEach((article, index) => {\n            // Skip the first article (main tweet)\n            if (index === 0) return;\n            \n            // Get all text content from the article\n            const textContent = [];\n            const paragraphs = article.querySelectorAll('[data-testid=\"tweetText\"], [dir=\"auto\"]');\n            \n            paragraphs.forEach(p => {\n              if (!(p instanceof HTMLElement)) return;\n              const text = p.innerText.trim();\n              if (text && text.length > 3 && text.length < 300) {\n                const key = text.substring(0, 30).toLowerCase();\n                if (!seen.has(key)) {\n                  seen.add(key);\n                  textContent.push(text);\n                }\n              }\n            });\n            \n            if (textContent.length > 0) {\n              // Join multiple paragraphs and take the longest\n              const joined = textContent.join(' ').substring(0, 280);\n              found.push(joined);\n            }\n          });\n          \n          return found;\n        });\n\n        for (const text of deepTexts) {\n          const key = text.toLowerCase().substring(0, 50);\n          if (!seenTexts.has(key)) {\n            seenTexts.add(key);\n            // Extract author from @mention or use 'unknown'\n            const mentionMatch = text.match(/@([a-zA-Z0-9_]+)/);\n            const author = mentionMatch ? mentionMatch[1] : 'unknown';\n            \n            // Filter out pure numbers/engagement metrics\n            if (!/^[\\d,\\.\\sK]+$/.test(text)) {\n              replies.push({\n                author: author,\n                text: this.cleanReplyText(text),\n                length: text.length,\n                hasMention: mentionMatch !== null\n              });\n            }\n          }\n        }\n        this.logger.debug(`[Context] Strategy 3 extracted ${deepTexts.length} potential replies`);\n      }\n\n      // Filter and sort replies - take longest for richer LLM context\n      // Also allow shorter replies (2+ chars) to capture emoji reactions, short confirmations\n      const finalReplies = replies\n        .filter(r => r.text && r.text.length > 2 && r.text.length < 280)\n        // Remove duplicates based on text content\n        .filter((reply, index, self) => \n          index === self.findIndex((r) => \n            r.text.toLowerCase().substring(0, 50) === reply.text.toLowerCase().substring(0, 50)\n          )\n        )\n        .sort((a, b) => b.text.length - a.text.length)\n        .slice(0, 30);\n\n      this.logger.info(`[Context] Final reply count: ${finalReplies.length} (from ${replies.length} candidates)`);\n\n      return finalReplies;\n\n    } catch (error) {\n      this.logger.debug(`[Context] Smart reply extraction: ${error.message}`);\n      return replies.slice(0, 10);\n    }\n  }\n\n    /**\n     * Extract author from visible text when no @mention is present\n     * Useful for Korean/Japanese tweets\n     */\n    async extractAuthorFromVisibleText(page, text) {\n      try {\n        // Try to find the author from the DOM context near tweet text\n        const authorInfo = await page.evaluate((searchText) => {\n          const elements = document.querySelectorAll('[data-testid=\"User-Name\"], [class*=\"UserName\"], [class*=\"author\"]');\n          for (const el of elements) {\n            const elText = el instanceof HTMLElement ? el.innerText : '';\n            if (elText.includes('@')) {\n              const match = elText.match(/@([a-zA-Z0-9_]+)/);\n              if (match) return match[1];\n            }\n          }\n          return null;\n        }, text);\n        \n        return authorInfo || 'unknown';\n      } catch {\n        return 'unknown';\n      }\n    }\n\n    /**\n     * Extract reply data from article element\n    */\n   async extractReplyFromArticle(article) {\n     try {\n       // Get tweet text\n       const textEl = await article.$('[data-testid=\"tweetText\"], [dir=\"auto\"]');\n       const text = textEl ? await textEl.innerText().catch(() => '') : '';\n\n       if (!text || text.length < 5) {\n         this.logger.debug(`[extractReplyFromArticle] No text found or too short`);\n         return null;\n       }\n\n       // Get author\n       const author = await this.extractAuthorFromArticle(article);\n       this.logger.debug(`[extractReplyFromArticle] Extracted: @${author}: \"${text.substring(0, 30)}...\"`);\n\n       // Clean text\n       const cleaned = this.cleanReplyText(text);\n\n       // Filter out engagement metrics (just numbers)\n       if (/^[\\d,\\.\\sK]+$/.test(cleaned)) {\n         this.logger.debug(`[extractReplyFromArticle] Skipping engagement metrics: \"${cleaned}\"`);\n         return null;\n       }\n\n       return {\n         author: author,\n         text: cleaned,\n         length: cleaned.length,\n         hasMention: cleaned.includes('@')\n       };\n\n     } catch (error) {\n       this.logger.debug(`[extractReplyFromArticle] Error: ${error.message}`);\n       return null;\n     }\n   }\n\n    /**\n     * Extract author from article\n     */\n    async extractAuthorFromArticle(article) {\n      try {\n        // Strategy 1: Find username in header links (most reliable)\n        const headerSelectors = [\n          'a[href^=\"/\"][role=\"link\"]',\n          'a[href*=\"/status/\"]',\n          '[class*=\"UserName\"] a',\n          '[class*=\"userName\"] a',\n          '[data-testid=\"User-Name\"] a'\n        ];\n        \n        for (const selector of headerSelectors) {\n          try {\n            const headerLink = await article.$(selector);\n            if (headerLink) {\n              const href = await headerLink.getAttribute('href');\n              if (href) {\n                // Handle various URL formats: /username, /username/status/123\n                const username = href.replace(/^\\/|\\/$/g, '').split('/')[0];\n                // Username validation: alphanumeric + underscores, 4-15 chars\n                if (username && /^[a-zA-Z0-9_]{4,15}$/.test(username) && \n                    !username.match(/^\\d+$/)) { // Exclude pure numbers\n                  return username;\n                }\n              }\n            }\n          } catch (error) {\n            this.logger.debug(`[Context] Header selector lookup failed: ${error.message}`);\n          }\n        }\n\n        // Strategy 2: Extract from display name containing @username\n        const nameEl = await article.$('[data-testid=\"User-Name\"], [class*=\"username\"], [class*=\"screenName\"]');\n        if (nameEl) {\n          try {\n            const nameText = await nameEl.innerText();\n            const match = nameText.match(/@([a-zA-Z0-9_]+)/);\n            if (match && match[1].length >= 4) return match[1];\n          } catch (error) {\n            this.logger.debug(`[Context] Display name lookup failed: ${error.message}`);\n          }\n        }\n\n        // Strategy 3: Look for any link with /username pattern\n        try {\n          const allLinks = await article.$$('a[href^=\"/\"]');\n          for (const link of allLinks.slice(0, 5)) {\n            const href = await link.getAttribute('href');\n            if (href && href.startsWith('/') && !href.includes('status')) {\n              const username = href.replace(/^\\/|\\/$/g, '');\n              if (/^[a-zA-Z0-9_]{4,15}$/.test(username) && !username.match(/^\\d+$/)) {\n                return username;\n              }\n            }\n          }\n        } catch (error) {\n          this.logger.debug(`[Context] Username link scan failed: ${error.message}`);\n        }\n\n        // Strategy 4: Fallback - try to find any @mention in the article\n        try {\n          const articleText = await article.innerText();\n          const match = articleText.match(/@([a-zA-Z0-9_]{4,15})/);\n          if (match) return match[1];\n        } catch (error) {\n          this.logger.debug(`[Context] Timeline reply extraction failed: ${error.message}`);\n        }\n\n        return 'unknown';\n      } catch {\n        return 'unknown';\n      }\n    }\n\n  /**\n   * Extract replies from timeline\n   */\n  async extractFromTimeline(page) {\n    const replies = [];\n\n    try {\n      const tweetTexts = await page.$$('[data-testid=\"tweetText\"]');\n      \n      for (const el of tweetTexts.slice(1, 40)) { // Skip first (main tweet)\n        try {\n          const text = await el.innerText().catch(() => '');\n          if (text && text.length > 3) {\n            const mentionMatch = text.match(/@(\\w+)/);\n            replies.push({\n              author: mentionMatch ? mentionMatch[1] : 'unknown',\n              text: this.cleanReplyText(text)\n            });\n          }\n        } catch {}\n      }\n    } catch (error) {\n      this.logger.debug(`[Context] Timeline extraction: ${error.message}`);\n    }\n\n    return replies;\n  }\n\n   /**\n    * Clean reply text - preserve meaningful content\n    */\n   cleanReplyText(text) {\n     if (!text) return '';\n     \n     // Preserve @mentions that are in-content (not just leading)\n     // Remove only excessive whitespace and truncate\n     return text\n       .replace(/\\n+/g, ' ')    // Normalize newlines to spaces\n       .replace(/\\s+/g, ' ')    // Collapse multiple spaces\n       .trim()\n       .substring(0, 280);\n   }\n\n  /**\n   * Analyze sentiment of text\n   */\n  analyzeSentiment(text) {\n    if (!text) return { overall: 'neutral', positive: 0, negative: 0, score: 0 };\n\n    const lower = text.toLowerCase();\n    let positiveCount = 0;\n    let negativeCount = 0;\n\n    for (const word of this.sentimentIndicators.positive) {\n      if (lower.includes(word)) positiveCount++;\n    }\n    for (const word of this.sentimentIndicators.negative) {\n      if (lower.includes(word)) negativeCount++;\n    }\n\n    const total = positiveCount + negativeCount;\n    let score = 0;\n    let overall = 'neutral';\n\n    if (total > 0) {\n      score = (positiveCount - negativeCount) / total;\n      overall = score > 0.2 ? 'positive' : score < -0.2 ? 'negative' : 'neutral';\n    }\n\n    return {\n      overall,\n      positive: positiveCount,\n      negative: negativeCount,\n      score: Math.round(score * 100) / 100\n    };\n  }\n\n  /**\n   * Detect tone of text\n   */\n  detectTone(text) {\n    if (!text) return { primary: 'neutral', secondary: null, confidence: 0 };\n\n    const lower = text.toLowerCase();\n    const tones = {\n      humorous: 0,\n      informational: 0,\n      emotional: 0,\n      serious: 0,\n      promotional: 0\n    };\n\n    // Count indicators\n    for (const word of this.sentimentIndicators.humorous) {\n      if (lower.includes(word)) tones.humorous++;\n    }\n    for (const word of this.sentimentIndicators.informational) {\n      if (lower.includes(word)) tones.informational++;\n    }\n    for (const word of this.sentimentIndicators.emotional) {\n      if (lower.includes(word)) tones.emotional++;\n    }\n\n    // Check for promotional content\n    if (lower.includes('link in bio') || lower.includes('check out') || \n        lower.includes('sign up') || lower.includes('buy now') ||\n        lower.includes('limited time') || lower.includes('offer')) {\n      tones.promotional++;\n    }\n\n    // Default to serious if nothing detected\n    if (Object.values(tones).every(v => v === 0)) {\n      tones.serious = 1;\n    }\n\n    // Find primary tone\n    let primary = 'neutral';\n    let maxScore = 0;\n    for (const [tone, score] of Object.entries(tones)) {\n      if (score > maxScore) {\n        maxScore = score;\n        primary = tone;\n      }\n    }\n\n    return {\n      primary,\n      secondary: maxScore > 2 ? null : 'neutral',\n      confidence: Math.min(maxScore / 3, 1),\n      scores: tones\n    };\n  }\n\n  /**\n   * Classify conversation type\n   */\n  classifyConversation(tweetText, replies) {\n    if (!tweetText) return 'general';\n\n    const lower = tweetText.toLowerCase();\n\n    // Question detection\n    if (lower.includes('?') || lower.includes('what') || lower.includes('how') ||\n        lower.includes('why') || lower.includes('when') || lower.includes('who')) {\n      return 'question';\n    }\n\n    // News/Announcement\n    if (lower.includes('breaking') || lower.includes('update') || \n        lower.includes('just announced') || lower.includes('official statement')) {\n      return 'news';\n    }\n\n    // Opinion/Thought\n    if (replies.length > 3 && replies.some(r => \n        r.text.toLowerCase().includes('agree') || \n        r.text.toLowerCase().includes('disagree') ||\n        r.text.toLowerCase().includes('think'))) {\n      return 'discussion';\n    }\n\n    // Fan/Reaction\n    if (replies.length > 5 && replies.some(r => \n        r.author !== 'unknown' && r.text.length < 50)) {\n      return 'reaction';\n    }\n\n    return 'general';\n  }\n\n  /**\n   * Analyze sentiment of all replies\n   */\n  analyzeReplySentiment(replies) {\n    if (!replies || replies.length === 0) {\n      return { overall: 'neutral', positive: 0, negative: 0, distribution: { positive: 0, neutral: 0, negative: 0 } };\n    }\n\n    let positive = 0;\n    let negative = 0;\n    let neutral = 0;\n\n    for (const reply of replies) {\n      const sentiment = this.analyzeSentiment(reply.text);\n      if (sentiment.overall === 'positive') positive++;\n      else if (sentiment.overall === 'negative') negative++;\n      else neutral++;\n    }\n\n    const total = replies.length;\n\n    return {\n      overall: positive > negative ? 'positive' : negative > positive ? 'negative' : 'neutral',\n      positive: Math.round(positive / total * 100),\n      negative: Math.round(negative / total * 100),\n      neutral: Math.round(neutral / total * 100),\n      distribution: { positive, neutral, negative }\n    };\n  }\n\n  /**\n   * Build enhanced prompt with all context\n   */\n  buildEnhancedPrompt(context, systemPrompt) {\n    const { tweetText, author, replies, sentiment, tone, conversationType, replySentiment, engagementLevel, metrics } = context;\n\n    let enhancedPrompt = systemPrompt + '\\n\\n=== CONTEXT ===\\n';\n\n    // Author info\n    enhancedPrompt += `Tweet from: @${author}\\n`;\n\n    // Sentiment\n    enhancedPrompt += `Tweet sentiment: ${sentiment.overall} (score: ${sentiment.score})\\n`;\n\n    // Tone\n    enhancedPrompt += `Tweet tone: ${tone.primary}${tone.confidence > 0.5 ? ' (confident)' : ''}\\n`;\n\n    // Conversation type\n    enhancedPrompt += `Conversation type: ${conversationType}\\n`;\n\n    // Engagement level\n    if (metrics) {\n      enhancedPrompt += `Engagement: ${engagementLevel} (${metrics.likes} likes, ${metrics.retweets} RTs, ${metrics.replies} replies)\\n`;\n    }\n\n    // Reply sentiment summary\n    if (replySentiment) {\n      enhancedPrompt += `Reply vibe: ${replySentiment.overall} (${replySentiment.positive}% positive, ${replySentiment.negative}% negative)\\n`;\n    }\n\n    // Add reply examples - pick longest 30 for richer context\n    if (replies.length > 0) {\n      const sortedReplies = replies\n        .filter(r => r.text && r.text.length > 5)\n        .sort((a, b) => (b.text?.length || 0) - (a.text?.length || 0))\n        .slice(0, 30);\n      \n      enhancedPrompt += `\\nRecent replies:\\n`;\n      for (const reply of sortedReplies) {\n        enhancedPrompt += `- @${reply.author}: \"${reply.text.substring(0, 150)}\"\\n`;\n      }\n    }\n\n    enhancedPrompt += '\\n=== TASK ===\\n';\n    enhancedPrompt += `Generate a reply that:\\n`;\n    enhancedPrompt += `- Matches the ${tone.primary} tone\\n`;\n    enhancedPrompt += `- Fits the ${conversationType} conversation type\\n`;\n    enhancedPrompt += `- Aligns with the ${sentiment.overall} sentiment\\n`;\n    enhancedPrompt += `- Is appropriate given the reply sentiment (${replySentiment.overall})\\n`;\n    enhancedPrompt += `- Stays within 280 characters\\n`;\n    enhancedPrompt += `- Sounds natural and human-like\\n`;\n\n    return enhancedPrompt;\n  }\n}\n\nexport default AIContextEngine;\n","usedDeprecatedRules":[]},{"filePath":"C:\\My Script\\auto-ai\\utils\\ai-twitterAgent.js","messages":[{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":945,"column":29,"messageId":"unexpected","endLine":945,"endColumn":32,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[38326,38327],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":994,"column":21,"messageId":"unnecessaryAssignment","endLine":994,"endColumn":27},{"ruleId":"no-dupe-class-members","severity":2,"message":"Duplicate name '_diveTweetWithAI'.","line":1140,"column":11,"messageId":"unexpected","endLine":1140,"endColumn":27},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":1334,"column":29,"messageId":"unexpected","endLine":1334,"endColumn":32,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[56158,56159],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":1712,"column":32,"messageId":"unnecessaryAssignment","endLine":1712,"endColumn":38},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":1921,"column":17,"messageId":"unexpected","endLine":1921,"endColumn":118,"suggestions":[{"messageId":"addBrackets","fix":{"range":[82247,82888],"text":"{ const canReply = this.engagementTracker.canPerform('replies') && this.diveQueue.canEngage('replies');\r\n                if (!canReply) {\r\n                    this.log(`[AI-Replies] Skipped (engagement limit reached - tracker: ${this.engagementTracker.canPerform('replies')}, queue: ${this.diveQueue.canEngage('replies')})`);\r\n                    this.aiStats.skips++;\r\n                    return;\r\n                }\r\n                this.log(`[AI-Replies] Generating reply: \"${decision.reply?.substring(0, 30)}...\"`);\r\n                await this.executeAIReply(decision.reply);\r\n                this.aiStats.replies++;\r\n                break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":2202,"column":25,"messageId":"unexpected","endLine":2202,"endColumn":62,"suggestions":[{"messageId":"addBrackets","fix":{"range":[94248,95526],"text":"{ const charLower = char.toLowerCase();\r\n                        const adjacent = keyboardLayout[charLower];\r\n                        if (adjacent && Math.random() < 0.7) {\r\n                            const wrongChar = adjacent[Math.floor(Math.random() * adjacent.length)];\r\n                            // Type wrong char\r\n                            await this.page.keyboard.type(wrongChar, { delay: baseDelay });\r\n                            // Pause like human noticing\r\n                            await this.page.waitForTimeout(mathUtils.randomInRange(80, 200));\r\n                            // Backspace\r\n                            await this.page.keyboard.press('Backspace', { delay: mathUtils.randomInRange(40, 100) });\r\n                            // Brief pause before correct\r\n                            await this.page.waitForTimeout(mathUtils.randomInRange(30, 80));\r\n                            // Type correct\r\n                            await this.page.keyboard.type(char, { delay: baseDelay + mathUtils.randomInRange(20, 60) });\r\n                            consecutiveErrors++;\r\n                        } else {\r\n                            await this.page.keyboard.type(char, { delay: baseDelay });\r\n                        }\r\n                        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":2203,"column":25,"messageId":"unexpected","endLine":2203,"endColumn":68,"suggestions":[{"messageId":"addBrackets","fix":{"range":[94248,95526],"text":"{ const charLower = char.toLowerCase();\r\n                        const adjacent = keyboardLayout[charLower];\r\n                        if (adjacent && Math.random() < 0.7) {\r\n                            const wrongChar = adjacent[Math.floor(Math.random() * adjacent.length)];\r\n                            // Type wrong char\r\n                            await this.page.keyboard.type(wrongChar, { delay: baseDelay });\r\n                            // Pause like human noticing\r\n                            await this.page.waitForTimeout(mathUtils.randomInRange(80, 200));\r\n                            // Backspace\r\n                            await this.page.keyboard.press('Backspace', { delay: mathUtils.randomInRange(40, 100) });\r\n                            // Brief pause before correct\r\n                            await this.page.waitForTimeout(mathUtils.randomInRange(30, 80));\r\n                            // Type correct\r\n                            await this.page.keyboard.type(char, { delay: baseDelay + mathUtils.randomInRange(20, 60) });\r\n                            consecutiveErrors++;\r\n                        } else {\r\n                            await this.page.keyboard.type(char, { delay: baseDelay });\r\n                        }\r\n                        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":2299,"column":21,"messageId":"unexpected","endLine":2299,"endColumn":129,"suggestions":[{"messageId":"addBrackets","fix":{"range":[99412,100799],"text":"{ const canBookmark = this.engagementTracker.canPerform('bookmarks') && this.diveQueue.canEngage('bookmarks');\r\n                    if (!canBookmark) {\r\n                        this.log('[AI-Fallback] Bookmark limit reached, skipping');\r\n                        return;\r\n                    }\r\n\r\n                    const bm = this.page.locator('button[data-testid=\"bookmark\"]').first();\r\n                    if (await bm.count() > 0 && await bm.isVisible()) {\r\n                        this.log('[AI-Fallback] Bookmarking tweet');\r\n                        await this.humanClick(bm, 'Bookmark');\r\n\r\n                        if (this.engagementTracker.record('bookmarks')) {\r\n                            const progress = this.engagementTracker.getProgress('bookmarks');\r\n                            this.log(`[Engagement] ${progress} Bookmarks used`);\r\n                        }\r\n\r\n                        // Also record in dive queue\r\n                        if (this.diveQueue.canEngage('bookmarks')) {\r\n                            this.diveQueue.recordEngagement('bookmarks');\r\n                            const queueProgress = this.diveQueue.getEngagementProgress();\r\n                            this.log(`[DiveQueue-Engagement] Bookmarks: ${queueProgress.bookmarks.current}/${queueProgress.bookmarks.limit}`);\r\n                        }\r\n                    }\r\n                    break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":2305,"column":21,"messageId":"unexpected","endLine":2305,"endColumn":92,"suggestions":[{"messageId":"addBrackets","fix":{"range":[99412,100799],"text":"{ const canBookmark = this.engagementTracker.canPerform('bookmarks') && this.diveQueue.canEngage('bookmarks');\r\n                    if (!canBookmark) {\r\n                        this.log('[AI-Fallback] Bookmark limit reached, skipping');\r\n                        return;\r\n                    }\r\n\r\n                    const bm = this.page.locator('button[data-testid=\"bookmark\"]').first();\r\n                    if (await bm.count() > 0 && await bm.isVisible()) {\r\n                        this.log('[AI-Fallback] Bookmarking tweet');\r\n                        await this.humanClick(bm, 'Bookmark');\r\n\r\n                        if (this.engagementTracker.record('bookmarks')) {\r\n                            const progress = this.engagementTracker.getProgress('bookmarks');\r\n                            this.log(`[Engagement] ${progress} Bookmarks used`);\r\n                        }\r\n\r\n                        // Also record in dive queue\r\n                        if (this.diveQueue.canEngage('bookmarks')) {\r\n                            this.diveQueue.recordEngagement('bookmarks');\r\n                            const queueProgress = this.diveQueue.getEngagementProgress();\r\n                            this.log(`[DiveQueue-Engagement] Bookmarks: ${queueProgress.bookmarks.current}/${queueProgress.bookmarks.limit}`);\r\n                        }\r\n                    }\r\n                    break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":2423,"column":25,"messageId":"unexpected","endLine":2423,"endColumn":28,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[105112,105113],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":2438,"column":21,"messageId":"unexpected","endLine":2438,"endColumn":24,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[105724,105725],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":2447,"column":25,"messageId":"unexpected","endLine":2447,"endColumn":28,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[106174,106175],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":2482,"column":25,"messageId":"unexpected","endLine":2482,"endColumn":28,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[107780,107781],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":2577,"column":25,"messageId":"unexpected","endLine":2577,"endColumn":28,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[111734,111735],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":2592,"column":25,"messageId":"unexpected","endLine":2592,"endColumn":28,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[112342,112343],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":2627,"column":25,"messageId":"unexpected","endLine":2627,"endColumn":28,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[113935,113936],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":2777,"column":29,"messageId":"unexpected","endLine":2777,"endColumn":32,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[121044,121045],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-dupe-class-members","severity":2,"message":"Duplicate name 'getActionStats'.","line":2873,"column":5,"messageId":"unexpected","endLine":2873,"endColumn":19}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview AI-Enhanced Twitter Agent\r\n * Extends TwitterAgent with AI reply capability when diving into tweets\r\n * @module utils/ai-twitterAgent\r\n */\r\n\r\nimport { TwitterAgent } from './twitterAgent.js';\r\nimport { AIReplyEngine } from './ai-reply-engine.js';\r\nimport { AIQuoteEngine } from './ai-quote-engine.js';\r\nimport { AIContextEngine } from './ai-context-engine.js';\r\nimport { microInteractions } from './micro-interactions.js';\r\nimport { motorControl } from './motor-control.js';\r\nimport AgentConnector from '../core/agent-connector.js';\r\nimport { mathUtils } from './mathUtils.js';\r\nimport { entropy } from './entropyController.js';\r\nimport { engagementLimits } from './engagement-limits.js';\r\nimport { sessionPhases } from './session-phases.js';\r\nimport { sentimentService } from './sentiment-service.js';\r\nimport { buildEnhancedPrompt } from './twitter-reply-prompt.js';\r\nimport { scrollDown, scrollUp, scrollRandom } from './scroll-helper.js';\r\nimport { config } from './config-service.js';\r\nimport { DiveQueue } from './async-queue.js';\r\nimport { AIReplyAction } from './actions/ai-twitter-reply.js';\r\nimport { AIQuoteAction } from './actions/ai-twitter-quote.js';\r\nimport { LikeAction } from './actions/ai-twitter-like.js';\r\nimport { BookmarkAction } from './actions/ai-twitter-bookmark.js';\r\nimport { GoHomeAction } from './actions/ai-twitter-go-home.js';\r\nimport { ActionRunner } from './actions/index.js';\r\nimport { TWITTER_TIMEOUTS } from '../constants/twitter-timeouts.js';\r\nimport { HumanInteraction } from './human-interaction.js';\r\nimport { createBufferedLogger } from './logger.js';\r\n\r\n/**\r\n * @deprecated Use config.getEngagementLimits() instead (supports env overrides)\r\n */\r\nconst DEFAULT_ENGAGEMENT_LIMITS = {\r\n    replies: 3,\r\n    retweets: 1,\r\n    quotes: 1,\r\n    likes: 5,\r\n    follows: 2,\r\n    bookmarks: 2\r\n};\r\n\r\n/**\r\n * Page states for diving operation control\r\n */\r\nconst PAGE_STATE = {\r\n    HOME: 'HOME',                    // Home feed page\r\n    DIVING: 'DIVING',               // Currently diving into a tweet\r\n    TWEET_PAGE: 'TWEET_PAGE',       // Viewing a tweet page\r\n    RETURNING: 'RETURNING'           // Returning from tweet to home\r\n};\r\n\r\nexport class AITwitterAgent extends TwitterAgent {\r\n    constructor(page, initialProfile, logger, options = {}) {\r\n        super(page, initialProfile, logger);\r\n\r\n        // Store full twitter config for action handlers (separate from profile config)\r\n        this.twitterConfig = options.config || {};\r\n\r\n        // ================================================================\r\n        // DIVE LOCK MECHANISM - Prevents scroller interference\r\n        // ================================================================\r\n        this.pageState = PAGE_STATE.HOME;      // Current page state\r\n        this.scrollingEnabled = true;           // Scrolling allowed flag\r\n        this.operationLock = false;              // Operation in progress flag\r\n        this.diveLockAcquired = false;           // Dive operation lock\r\n        this.homeUrl = 'https://x.com/home';    // Home page URL\r\n\r\n        // Log buffering for wait messages (prevent log spam)\r\n        this.lastWaitLogTime = 0;               // Timestamp of last wait log\r\n        this.waitLogInterval = 10000;           // Log wait messages every 10s\r\n\r\n        // Initialize DiveQueue for race-condition-free tweet dives\r\n        // Force sequential processing (maxConcurrent: 1) to prevent overlapping dives\r\n        this.diveQueue = new DiveQueue({\r\n            maxConcurrent: 1,\r\n            maxQueueSize: 30,\r\n            defaultTimeout: 20000,\r\n            fallbackEngagement: false, // Disable autonomous fallbacks during AI dives\r\n            replies: options.engagementLimits?.replies ?? 3,\r\n            retweets: options.engagementLimits?.retweets ?? 1,\r\n            quotes: options.engagementLimits?.quotes ?? 1,\r\n            likes: options.engagementLimits?.likes ?? 5,\r\n            follows: options.engagementLimits?.follows ?? 2,\r\n            bookmarks: options.engagementLimits?.bookmarks ?? 2\r\n        });\r\n\r\n        // Quick mode flag for timeout scenarios\r\n        this.quickModeEnabled = false;\r\n\r\n        // Initialize AgentConnector for AI requests\r\n        this.agentConnector = new AgentConnector();\r\n\r\n        // Initialize AI Reply Engine with AgentConnector\r\n        // Values come from config/settings.json  ai-twitterActivity.js  here\r\n        this.replyEngine = new AIReplyEngine(this.agentConnector, {\r\n            replyProbability: options.replyProbability ?? 0.50, // Default from settings.json\r\n            maxRetries: options.maxRetries ?? 2\r\n        });\r\n\r\n        // Initialize AI Quote Engine with AgentConnector\r\n        // Values come from config/settings.json  ai-twitterActivity.js  here\r\n        this.quoteEngine = new AIQuoteEngine(this.agentConnector, {\r\n            quoteProbability: options.quoteProbability ?? 0.50, // Default from settings.json\r\n            maxRetries: options.maxRetries ?? 2\r\n        });\r\n\r\n        // Initialize Enhanced Context Engine for better AI replies\r\n        this.contextEngine = new AIContextEngine({\r\n            maxReplies: 30,\r\n            sentimentThreshold: 0.3,\r\n            includeMetrics: true\r\n        });\r\n\r\n        this.aiStats = {\r\n            attempts: 0,\r\n            replies: 0,\r\n            skips: 0,\r\n            safetyBlocks: 0,\r\n            errors: 0\r\n        };\r\n\r\n        // Initialize engagement limits tracker\r\n        const customLimits = options.engagementLimits || DEFAULT_ENGAGEMENT_LIMITS;\r\n        this.engagementTracker = engagementLimits.createEngagementTracker(customLimits);\r\n\r\n        // ================================================================\r\n        // ENGAGEMENT TRACKER SYNCHRONIZATION\r\n        // Override engagementTracker methods to delegate to DiveQueue\r\n        // This ensures both systems use the same counters to prevent over-engagement\r\n        // ================================================================\r\n        const originalCanPerform = this.engagementTracker.canPerform.bind(this.engagementTracker);\r\n        const originalRecord = this.engagementTracker.record.bind(this.engagementTracker);\r\n        const originalGetProgress = this.engagementTracker.getProgress.bind(this.engagementTracker);\r\n        const originalGetStatus = this.engagementTracker.getStatus.bind(this.engagementTracker);\r\n        const originalGetSummary = this.engagementTracker.getSummary.bind(this.engagementTracker);\r\n\r\n        // Override canPerform to check both trackers (conservative - requires both to allow)\r\n        this.engagementTracker.canPerform = (action) => {\r\n            const trackerAllows = originalCanPerform(action);\r\n            const queueAllows = this.diveQueue.canEngage(action);\r\n            return trackerAllows && queueAllows;\r\n        };\r\n\r\n        // Override record to update both systems atomically\r\n        this.engagementTracker.record = (action) => {\r\n            // Only record if both allow it\r\n            if (!originalCanPerform(action) || !this.diveQueue.canEngage(action)) {\r\n                return false;\r\n            }\r\n\r\n            // Record in both systems\r\n            const trackerResult = originalRecord(action);\r\n            const queueResult = this.diveQueue.recordEngagement(action);\r\n\r\n            // Return true only if both succeeded\r\n            return trackerResult && queueResult;\r\n        };\r\n\r\n        // Override getProgress to combine data from both\r\n        this.engagementTracker.getProgress = (action) => {\r\n            const trackerProgress = originalGetProgress(action);\r\n            const queueProgress = this.diveQueue.getEngagementProgress()[action];\r\n\r\n            // Use the more restrictive of the two\r\n            if (queueProgress) {\r\n                return `${queueProgress.current}/${queueProgress.limit}`;\r\n            }\r\n            return trackerProgress;\r\n        };\r\n\r\n        // Override getStatus to combine data from both\r\n        this.engagementTracker.getStatus = () => {\r\n            const trackerStatus = originalGetStatus();\r\n            const queueProgress = this.diveQueue.getEngagementProgress();\r\n\r\n            // Merge statuses, using DiveQueue data where available\r\n            const mergedStatus = { ...trackerStatus };\r\n            for (const [action, data] of Object.entries(queueProgress)) {\r\n                if (mergedStatus[action]) {\r\n                    mergedStatus[action].current = data.current;\r\n                    mergedStatus[action].limit = data.limit;\r\n                    mergedStatus[action].remaining = data.remaining;\r\n                    mergedStatus[action].percentage = data.percentUsed + '%';\r\n                }\r\n            }\r\n            return mergedStatus;\r\n        };\r\n\r\n        // Override getSummary to use DiveQueue data\r\n        this.engagementTracker.getSummary = () => {\r\n            const queueProgress = this.diveQueue.getEngagementProgress();\r\n            const summary = [];\r\n            for (const [action, data] of Object.entries(queueProgress)) {\r\n                if (data.limit !== Infinity && data.limit > 0) {\r\n                    summary.push(`${action}: ${data.current}/${data.limit}`);\r\n                }\r\n            }\r\n            return summary.join(', ') || originalGetSummary();\r\n        };\r\n\r\n        // Initialize Micro-Interactions handler\r\n        this.microHandler = microInteractions.createMicroInteractionHandler({\r\n            highlightChance: 0.03,\r\n            rightClickChance: 0.02,\r\n            logoClickChance: 0.05,\r\n            whitespaceClickChance: 0.04,\r\n            fidgetChance: 0.08,\r\n            fidgetInterval: { min: 15000, max: 45000 }\r\n        });\r\n\r\n        // Initialize Motor Control handler\r\n        this.motorHandler = motorControl.createMotorController({\r\n            layoutShiftThreshold: 5,\r\n            spiralSearchAttempts: 4,\r\n            retryDelay: 100,\r\n            maxRetries: 3,\r\n            targetTimeout: 5000\r\n        });\r\n\r\n        // Session phase tracking\r\n        this.sessionStart = Date.now();\r\n        this.sessionDuration = 0;\r\n        this.currentPhase = 'warmup';\r\n        this.lastPhaseLogged = null;\r\n\r\n        // Track processed tweets to avoid re-diving\r\n        this._processedTweetIds = new Set();\r\n\r\n        // Scroll tracking for exploration (fixes: re-diving same area, insufficient scroll)\r\n        this._lastScrollY = 0;\r\n        this._lastScrollTime = 0;\r\n        this._minScrollPerDive = 400;  // Minimum pixels to scroll before diving\r\n        this._scrollExplorationThreshold = 600;  // Exploration scroll distance\r\n\r\n        // Initialize Action Handlers (stateful per browser instance)\r\n        const actionInstances = {\r\n            reply: new AIReplyAction(this),\r\n            quote: new AIQuoteAction(this),\r\n            like: new LikeAction(this),\r\n            bookmark: new BookmarkAction(this),\r\n            goHome: new GoHomeAction(this)\r\n        };\r\n\r\n        // Initialize Action Runner for smart probability redistribution\r\n        this.actionRunner = new ActionRunner(this, actionInstances);\r\n\r\n        // Keep individual actions accessible\r\n        this.actions = actionInstances;\r\n\r\n        // Initialize HumanInteraction for fallback methods\r\n        this.humanInteraction = new HumanInteraction(page);\r\n\r\n        // Initialize BufferedLogger for high-frequency logs\r\n        this.queueLogger = createBufferedLogger('QueueMonitor', {\r\n            flushInterval: 10000,  // Flush every 10 seconds\r\n            maxBufferSize: 50,      // Max 50 entries before flush\r\n            groupByLevel: true\r\n        });\r\n\r\n        this.engagementLogger = createBufferedLogger('EngagementTracker', {\r\n            flushInterval: 30000,  // Flush every 30 seconds\r\n            maxBufferSize: 20,\r\n            groupByLevel: true\r\n        });\r\n\r\n        this.log(`[AITwitterAgent] Initialized (replyProbability: ${this.replyEngine.config.REPLY_PROBABILITY})`);\r\n        this.log(`[AITwitterAgent] Engagement limits: ${this.engagementTracker.getSummary()}`);\r\n        this.log(`[AITwitterAgent] Session phases: warmup(0-10%)  active(10-80%)  cooldown(80-100%)`);\r\n        this.log(`[DiveLock] State management initialized: HOME (scrolling enabled)`);\r\n        this.log(`[AITwitterAgent] Action handlers initialized: reply, quote, like, bookmark, goHome`);\r\n    }\r\n\r\n    // ================================================================\r\n    // DIVE LOCK MECHANISM - State Management Methods\r\n    // ================================================================\r\n\r\n    /**\r\n     * Start dive operation - acquires lock and disables scrolling\r\n     * Prevents scroller interference during tweet diving\r\n     */\r\n    async startDive() {\r\n        // Wait for any ongoing operations to complete\r\n        let firstWait = true;\r\n        while (this.operationLock) {\r\n            const now = Date.now();\r\n\r\n            // Only log every 10 seconds to prevent log spam\r\n            if (firstWait || now - this.lastWaitLogTime >= this.waitLogInterval) {\r\n                this.log(`[DiveLock]  Waiting for existing operation to complete... (${((now - this.lastWaitLogTime) / 1000).toFixed(0)}s since last check)`);\r\n                this.lastWaitLogTime = now;\r\n                firstWait = false;\r\n            }\r\n\r\n            await new Promise(resolve => setTimeout(resolve, 100));\r\n        }\r\n\r\n        // Acquire operation lock\r\n        this.operationLock = true;\r\n        this.diveLockAcquired = true;\r\n        this.pageState = PAGE_STATE.DIVING;\r\n        this.scrollingEnabled = false;\r\n        this.lastWaitLogTime = 0;  // Reset wait log timestamp\r\n\r\n        this.log(`[DiveLock]  Dive operation started - scrolling disabled (state: ${this.pageState})`);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * End dive operation - releases lock and optionally returns to home\r\n     * @param {boolean} success - Whether the dive was successful\r\n     * @param {boolean} returnHome - Whether to return to home page\r\n     */\r\n    async endDive(success = true, returnHome = false) {\r\n        if (returnHome) {\r\n            this.pageState = PAGE_STATE.RETURNING;\r\n            this.scrollingEnabled = false;\r\n\r\n            try {\r\n                // Navigate back to home\r\n                await this._safeNavigateHome();\r\n                // Reduced wait - let simulateReading() handle actual reading delay\r\n                await this.page.waitForTimeout(500);\r\n\r\n                // Verify we're on home page\r\n                const currentUrl = this.page.url();\r\n                if (currentUrl.includes('/home') || currentUrl === 'https://x.com/') {\r\n                    this.log(`[DiveLock]  Successfully returned to home`);\r\n                }\r\n            } catch (error) {\r\n                this.log(`[DiveLock] Warning: Failed to return to home: ${error.message}`);\r\n            }\r\n\r\n            // Reset to home state\r\n            this.pageState = PAGE_STATE.HOME;\r\n            this.scrollingEnabled = true;\r\n        } else {\r\n            // Just update state based on success\r\n            this.pageState = success ? PAGE_STATE.TWEET_PAGE : PAGE_STATE.HOME;\r\n        }\r\n\r\n        // Release operation lock\r\n        this.operationLock = false;\r\n        this.diveLockAcquired = false;\r\n        \r\n        // Always re-enable scrolling when dive ends\r\n        this.scrollingEnabled = true;\r\n\r\n        this.log(`[DiveLock]  Dive operation ended (success: ${success}, state: ${this.pageState})`);\r\n    }\r\n\r\n    /**\r\n     * Check if currently diving (operation in progress)\r\n     */\r\n    isDiving() {\r\n        return this.operationLock && this.pageState === PAGE_STATE.DIVING;\r\n    }\r\n\r\n    /**\r\n     * Check if currently on tweet page\r\n     */\r\n    isOnTweetPage() {\r\n        const url = this.page.url();\r\n        return url.includes('/status/') || this.pageState === PAGE_STATE.TWEET_PAGE;\r\n    }\r\n\r\n    /**\r\n     * Check if scrolling is allowed\r\n     */\r\n    canScroll() {\r\n        return this.scrollingEnabled && !this.operationLock;\r\n    }\r\n\r\n    /**\r\n     * Get current page state\r\n     */\r\n    getPageState() {\r\n        return {\r\n            state: this.pageState,\r\n            scrollingEnabled: this.scrollingEnabled,\r\n            operationLock: this.operationLock,\r\n            url: this.page.url()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Log current dive status\r\n     */\r\n    logDiveStatus() {\r\n        const status = this.getPageState();\r\n        this.log(`[DiveStatus] State: ${status.state}, Scrolling: ${status.scrollingEnabled}, Lock: ${status.operationLock}, URL: ${status.url}`);\r\n    }\r\n\r\n    /**\r\n     * Safe navigation to home page\r\n     */\r\n    async _safeNavigateHome() {\r\n        try {\r\n            const currentUrl = this.page.url();\r\n            if (currentUrl.includes('/home') || currentUrl === 'https://x.com/') {\r\n                this.log('[DiveLock] Already on home page');\r\n                return true;\r\n            }\r\n\r\n            // Use keyboard navigation first (Escape to close composer if open)\r\n            await this.page.keyboard.press('Escape');\r\n            await this.page.waitForTimeout(500);\r\n\r\n            // Try to navigate to home\r\n            await this.navigateHome();\r\n            return true;\r\n        } catch (error) {\r\n            this.log(`[DiveLock] Navigation error: ${error.message}`);\r\n            // Fallback: direct navigation\r\n            try {\r\n                await this.page.goto('https://x.com/home', { waitUntil: 'domcontentloaded', timeout: TWITTER_TIMEOUTS.NAVIGATION });\r\n                return true;\r\n            } catch (e) {\r\n                this.log(`[DiveLock] Fallback navigation failed: ${e.message}`);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wait for dive operation to complete\r\n     */\r\n    async waitForDiveComplete() {\r\n        while (this.operationLock) {\r\n            await new Promise(resolve => setTimeout(resolve, 100));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if session should continue (respecting dive operations)\r\n     */\r\n    shouldContinueSession() {\r\n        if (this.operationLock) {\r\n            this.log('[Session] Waiting for diving operation to complete...');\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Perform idle cursor movement when scrolling is disabled\r\n     * Maintains human-like behavior during dive operations\r\n     */\r\n    async performIdleCursorMovement() {\r\n        try {\r\n            const viewport = this.page.viewportSize() || { width: 1280, height: 720 };\r\n\r\n            // Small random cursor movements for human-like behavior\r\n            for (let i = 0; i < 3; i++) {\r\n                const x = Math.random() * (viewport.width - 200) + 100;\r\n                const y = Math.random() * (viewport.height - 200) + 100;\r\n                await this.page.mouse.move(x, y);\r\n                await this.page.waitForTimeout(Math.random() * 1000 + 500);\r\n            }\r\n        } catch (error) {\r\n            // Silent fail - cursor movement is optional\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Debug logging - only logs when debug mode is enabled\r\n     * @param {string} message - Message to log\r\n     */\r\n    logDebug(message) {\r\n        this.log(`[DEBUG] ${message}`);\r\n    }\r\n\r\n    logWarn(message) {\r\n        this.log(`[WARN] ${message}`);\r\n    }\r\n\r\n    /**\r\n     * Update session phase based on elapsed time\r\n     * Call this periodically during session\r\n     */\r\n    updateSessionPhase() {\r\n        this.sessionDuration = Date.now() - this.sessionStart;\r\n        const newPhase = sessionPhases.getSessionPhase(this.sessionDuration, this.sessionDuration * 1.25);\r\n\r\n        if (newPhase !== this.currentPhase) {\r\n            const phaseInfo = sessionPhases.getPhaseStats(newPhase);\r\n            this.log(`[Phase] Transition: ${this.currentPhase}  ${newPhase} (${phaseInfo.description})`);\r\n            this.currentPhase = newPhase;\r\n        }\r\n\r\n        return this.currentPhase;\r\n    }\r\n\r\n    /**\r\n     * Get phase-modified probability for an action\r\n     * Applies session phase modifiers to base probabilities\r\n     */\r\n    getPhaseModifiedProbability(action, baseProbability) {\r\n        this.updateSessionPhase();\r\n        const modifier = sessionPhases.getPhaseModifier(action, this.currentPhase);\r\n        const adjusted = baseProbability * modifier;\r\n\r\n        if (this.currentPhase !== 'active') {\r\n            this.log(`[PhaseMod] ${action}: ${(baseProbability * 100).toFixed(1)}%  ${modifier.toFixed(2)} = ${(adjusted * 100).toFixed(1)}% (${this.currentPhase})`);\r\n        }\r\n\r\n        return adjusted;\r\n    }\r\n\r\n    /**\r\n     * Get current session progress percentage\r\n     */\r\n    getSessionProgress() {\r\n        this.sessionDuration = Date.now() - this.sessionStart;\r\n        const estimatedTotal = this.sessionDuration * 1.25;\r\n        return Math.min(100, (this.sessionDuration / estimatedTotal) * 100);\r\n    }\r\n\r\n    /**\r\n     * Check if we're in cooldown phase (wind-down behavior)\r\n     */\r\n    isInCooldown() {\r\n        this.updateSessionPhase();\r\n        return this.currentPhase === 'cooldown';\r\n    }\r\n\r\n    /**\r\n     * Check if we're in warmup phase (cautious behavior)\r\n     */\r\n    isInWarmup() {\r\n        this.updateSessionPhase();\r\n        return this.currentPhase === 'warmup';\r\n    }\r\n\r\n    /**\r\n     * Trigger a micro-interaction during reading/pauses\r\n     * Adds human fidgeting behaviors\r\n     */\r\n    async triggerMicroInteraction(context = 'reading') {\r\n        try {\r\n            const roll = Math.random();\r\n            const actionThreshold = this.microHandler.config.highlightChance\r\n                + this.microHandler.config.rightClickChance\r\n                + this.microHandler.config.logoClickChance\r\n                + this.microHandler.config.whitespaceClickChance;\r\n\r\n            if (roll > actionThreshold) {\r\n                this.log(`[Micro] No micro-interaction triggered (${context})`);\r\n                return { success: false, reason: 'probability_skip' };\r\n            }\r\n\r\n            const result = await this.microHandler.executeMicroInteraction(this.page, {\r\n                logger: {\r\n                    info: (msg) => this.log(msg),\r\n                    error: (msg) => this.log(`[Micro-Error] ${msg}`)\r\n                }\r\n            });\r\n\r\n            if (result.success) {\r\n                this.log(`[Micro] Executed ${result.type} (${context})`);\r\n            }\r\n\r\n            return result;\r\n        } catch (error) {\r\n            this.log(`[Micro] Error during micro-interaction: ${error.message}`);\r\n            return { success: false, reason: error.message };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Text highlighting micro-interaction\r\n     * Simulates humans highlighting interesting text\r\n     */\r\n    async highlightText(selector = 'article [data-testid=\"tweetText\"]') {\r\n        return await this.microHandler.textHighlight(this.page, {\r\n            logger: {\r\n                info: (msg) => this.log(msg),\r\n                error: (msg) => this.log(`[Micro-Error] ${msg}`)\r\n            },\r\n            selector\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Start background fidget loop during long reads\r\n     */\r\n    startFidgetLoop() {\r\n        return this.microHandler.startFidgetLoop(this.page, {\r\n            logger: {\r\n                info: (msg) => this.log(msg),\r\n                error: (msg) => this.log(`[Micro-Error] ${msg}`)\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Stop background fidget loop\r\n     */\r\n    stopFidgetLoop() {\r\n        return this.microHandler.stopFidgetLoop();\r\n    }\r\n\r\n    /**\r\n     * Override simulateFidget to use micro-interactions module\r\n     * Replaces parent's TEXT_SELECT/MOUSE_WIGGLE/OVERSHOOT with:\r\n     * - Text highlighting\r\n     * - Random right-click\r\n     * - Logo clicks\r\n     * - Whitespace clicks\r\n     */\r\n    async simulateFidget() {\r\n        try {\r\n            const result = await this.microHandler.executeMicroInteraction(this.page, {\r\n                logger: {\r\n                    info: (msg) => this.log(msg.replace('[Micro]', '[Fidget]')),\r\n                    error: (msg) => this.log(`[Fidget-Error] ${msg}`)\r\n                }\r\n            });\r\n\r\n            if (!result.success) {\r\n                // Commented out - too noisy\r\n                // this.log(`[Fidget] Skipped: ${result.reason || 'no action'}`);\r\n            }\r\n        } catch (error) {\r\n            this.log(`[Fidget] Error: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Smart Click using motor control\r\n     * Uses continuous target tracking, overlap protection, and spiral recovery\r\n     */\r\n    async smartClick(context, options = {}) {\r\n        const {\r\n            verifySelector = null,\r\n            timeout = 5000\r\n        } = options;\r\n\r\n        try {\r\n            const result = await this.motorHandler.smartClick(this.page, null, {\r\n                logger: {\r\n                    info: (msg) => this.log(msg),\r\n                    warn: (msg) => this.log(msg),\r\n                    debug: (msg) => this.log(`[Motor-Debug] ${msg}`)\r\n                },\r\n                context,\r\n                verifySelector,\r\n                timeout\r\n            });\r\n\r\n            if (result.success) {\r\n                this.log(`[Motor] Smart click: ${context} @ (${Math.round(result.x)}, ${Math.round(result.y)}${result.recovered ? ', recovered' : ''}${result.usedFallback ? ', fallback' : ''})`);\r\n            } else {\r\n                this.log(`[Motor] Smart click failed: ${result.reason}`);\r\n            }\r\n\r\n            return result;\r\n        } catch (error) {\r\n            this.log(`[Motor] Error: ${error.message}`);\r\n            return { success: false, reason: error.message };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Click with smart selector fallback and verification\r\n     */\r\n    async smartClickElement(selector, fallbacks = [], options = {}) {\r\n        const {\r\n            verifySelector = null,\r\n            verifyTimeout = 500\r\n        } = options;\r\n\r\n        try {\r\n            const result = await this.motorHandler.smartClick(this.page, { primary: selector, fallbacks }, {\r\n                logger: {\r\n                    info: (msg) => this.log(msg),\r\n                    warn: (msg) => this.log(msg),\r\n                    debug: (msg) => this.log(`[Motor-Debug] ${msg}`)\r\n                },\r\n                verifySelector,\r\n                verifyTimeout\r\n            });\r\n\r\n            if (result.success) {\r\n                this.log(`[Motor] Clicked: ${result.selector} @ (${Math.round(result.x)}, ${Math.round(result.y)}${result.recovered ? ', recovered' : ''})`);\r\n            }\r\n\r\n            return result;\r\n        } catch (error) {\r\n            this.log(`[Motor] Click error: ${error.message}`);\r\n            return { success: false, reason: error.message };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Override diveTweet to use split-phase processing\r\n     * Phase 1: Scan (Find & Extract) - Locked by simple boolean\r\n     * Phase 2: Process (AI & Action) - Locked by DiveQueue (Timeout monitored)\r\n     */\r\n    async diveTweet() {\r\n        const diveId = `dive_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;\r\n        \r\n        // PHASE 1: SCANNING (Quick, no heavy timeout needed)\r\n        // --------------------------------------------------\r\n        if (this.isScanning) {\r\n            this.log(`[DiveLock]  Scan already in progress, skipping ${diveId}`);\r\n            return false;\r\n        }\r\n\r\n        this.isScanning = true;\r\n        \r\n        try {\r\n            this.log(`[DiveLock]  Starting SCAN phase for ${diveId}`);\r\n            \r\n            // Execute the dive logic. \r\n            // We pass a callback that wraps ONLY the AI/Action part in the heavy DiveQueue.\r\n            // The rest of the function (scrolling, extracting) runs immediately.\r\n            return await this._diveTweetWithAI(async (aiTask) => {\r\n                 this.log(`[DiveQueue]  Entering AI Processing Queue for ${diveId}`);\r\n                 return await this.diveQueue.addDive(\r\n                    aiTask,\r\n                    null, // No fallback for now\r\n                    {\r\n                        taskName: diveId,\r\n                        timeout: TWITTER_TIMEOUTS.DIVE_TIMEOUT, // 120s timeout applies ONLY here\r\n                        priority: 10\r\n                    }\r\n                );\r\n            });\r\n\r\n        } catch (error) {\r\n            this.log(`[DiveLock]  Error in diveTweet: ${error.message}`);\r\n            return false;\r\n        } finally {\r\n            this.isScanning = false;\r\n            // Note: _diveTweetWithAI handles endDive() internally, \r\n            // but we ensure cleanup if something crashed before that.\r\n            if (this.diveLockAcquired) {\r\n                 await this.endDive(false, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal method: diveTweet with AI reply (original logic)\r\n     * Now includes dive locking to prevent scroller interference\r\n     * @param {Function} queueWrapper - Optional wrapper for the AI execution phase\r\n     */\r\n    async _diveTweetWithAI(queueWrapper = null) {\r\n        try {\r\n            // ================================================================\r\n            // ACQUIRE DIVE LOCK - Prevents scroller interference\r\n            // ================================================================\r\n            await this.startDive();\r\n\r\n            // ENSURE EXPLORATION SCROLL - Prevent re-diving same area\r\n            await this._ensureExplorationScroll();\r\n\r\n            let targetTweet = null;\r\n\r\n            // Find suitable tweet with increased scroll distance\r\n            for (let attempt = 0; attempt < 3; attempt++) {\r\n                const tweets = this.page.locator('article[data-testid=\"tweet\"]');\r\n                const count = await tweets.count();\r\n\r\n                if (count > 0) {\r\n                    for (let i = 0; i < Math.min(count, 10); i++) {\r\n                        const t = tweets.nth(i);\r\n                        const box = await t.boundingBox();\r\n                        // Extended viewport range to catch more tweets\r\n                        if (box && box.height > 0 && box.y > -100 && box.y < 1200) {\r\n                            targetTweet = t;\r\n                            // Reduced early break probability (0.4 -> 0.2) for more exploration\r\n                            if (Math.random() > 0.2) break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (targetTweet) break;\r\n\r\n                this.log('[Dive] No suitable tweets. Scrolling...');\r\n                // Increased scroll distance (300 -> 600) with variance for natural behavior\r\n                const variance = 0.85 + Math.random() * 0.3;\r\n                const scrollAmount = Math.floor(600 * variance);\r\n                await scrollDown(this.page, scrollAmount);\r\n                await this.page.waitForTimeout(entropy.retryDelay(attempt));\r\n\r\n                // Update scroll tracking\r\n                this._lastScrollY = await this.page.evaluate(() => window.scrollY);\r\n                this._lastScrollTime = Date.now();\r\n            }\r\n\r\n            if (!targetTweet) {\r\n                this.log('[Dive] No suitable tweets found. Refreshing Home...');\r\n                await this.page.goto('https://x.com/');\r\n                await this.ensureForYouTab();\r\n                // Release lock before returning\r\n                await this.endDive(false, true);\r\n                return;\r\n            }\r\n\r\n            // Get username from tweet for URL construction\r\n            let username = 'unknown';\r\n            try {\r\n                const tweetTextEl = targetTweet.locator('[data-testid=\"tweetText\"]').first();\r\n                if (await tweetTextEl.count() > 0) {\r\n                    const parent = await tweetTextEl.$x('..');\r\n                    if (parent && parent[0]) {\r\n                        const link = await parent[0].$('a[href*=\"/\"]');\r\n                        if (link) {\r\n                            const href = await link.getAttribute('href');\r\n                            username = href?.replace(/^\\/|\\/$/g, '') || 'unknown';\r\n                        }\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                username = 'unknown';\r\n            }\r\n\r\n            // Determine click target\r\n            let clickTarget = null;\r\n            const timeStamp = targetTweet.locator('time').first();\r\n\r\n            const tweetTextEl = targetTweet.locator('[data-testid=\"tweetText\"]').first();\r\n\r\n            if (await tweetTextEl.count() > 0 && await tweetTextEl.isVisible()) {\r\n                clickTarget = tweetTextEl;\r\n                this.log('[Debug] Targeting tweet text body (Primary).');\r\n            } else if (await timeStamp.count() > 0 && await timeStamp.isVisible()) {\r\n                const parentLink = timeStamp.locator('xpath=./ancestor::a[1]');\r\n                clickTarget = (await parentLink.count() > 0) ? parentLink : timeStamp;\r\n                this.log('[Debug] Targeting tweet permalink/time (Fallback).');\r\n            } else {\r\n                clickTarget = targetTweet;\r\n                this.log('[Debug] Targeting entire tweet card (Last Resort).');\r\n            }\r\n\r\n            if (clickTarget) {\r\n                await clickTarget.evaluate(el => el.scrollIntoView({ block: 'center', inline: 'center' }));\r\n                await this.page.waitForTimeout(entropy.scrollSettleTime());\r\n\r\n                const dbgBox = await clickTarget.boundingBox();\r\n                this.log(`[Debug] Target: Box=${dbgBox ? `x:${Math.round(dbgBox.x)},y:${Math.round(dbgBox.y)}` : 'null'}`);\r\n\r\n                this.log('[Attempt] Ghost Click on Permalink...');\r\n                await this.humanClick(clickTarget, 'Tweet Permalink');\r\n            }\r\n\r\n            // Wait for navigation to tweet page\r\n            let tweetUrl = '';\r\n            let expanded = false;\r\n            try {\r\n                // Wait for URL to contain /status/\r\n                await this.page.waitForURL('**/status/**', { timeout: TWITTER_TIMEOUTS.NAVIGATION });\r\n                tweetUrl = this.page.url();\r\n                this.log('[Success] Navigated to tweet page.');\r\n                this.log(`[Debug] Tweet URL: ${tweetUrl}`);\r\n                expanded = true;\r\n            } catch (e) {\r\n                this.log('[Fail] Ghost Click did not navigate. Retrying with NATIVE click...');\r\n                if (clickTarget) {\r\n                    await clickTarget.click({ force: true });\r\n                }\r\n                try {\r\n                    await this.page.waitForURL('**/status/**', { timeout: TWITTER_TIMEOUTS.NAVIGATION });\r\n                    tweetUrl = this.page.url();\r\n                    this.log('[Success] Native Click navigated to tweet.');\r\n                    expanded = true;\r\n                } catch (e2) {\r\n                    this.log('[Fail] Failed to expand tweet. Aborting dive.');\r\n                    // Release lock before returning\r\n                    await this.endDive(false, true);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (!expanded) {\r\n                await this.endDive(false, true);\r\n                return;\r\n            }\r\n\r\n            // Skip if already processed this tweet\r\n            const tweetIdMatch = tweetUrl && tweetUrl.match(/status\\/(\\d+)/);\r\n            if (tweetIdMatch) {\r\n                const tweetId = tweetIdMatch[1];\r\n                if (this._processedTweetIds.has(tweetId)) {\r\n                    this.log(`[AI] Already processed tweet ${tweetId}, skipping...`);\r\n                    await this.endDive(true, true);\r\n                    return;\r\n                }\r\n                this._processedTweetIds.add(tweetId);\r\n                this.log(`[AI] Tracking new tweet ${tweetId}`);\r\n            }\r\n\r\n            // ================================================================\r\n            // EXTRACT TWEET CONTENT AFTER NAVIGATION (PRIMARY SOURCE)\r\n            // ================================================================\r\n            this.log('[AI] Extracting tweet content from full page...');\r\n\r\n            // Wait for tweet content to fully load\r\n            await this.page.waitForSelector('[data-testid=\"tweetText\"]', { timeout: TWITTER_TIMEOUTS.ELEMENT_VISIBLE }).catch(() => { });\r\n            await this.page.waitForTimeout(1000);  // Additional settle time\r\n\r\n            // Extract FRESH tweet text AFTER navigation\r\n            let tweetText = '';\r\n            const freshTextEl = this.page.locator('[data-testid=\"tweetText\"]').first();\r\n\r\n            if (await freshTextEl.count() > 0) {\r\n                tweetText = await freshTextEl.innerText().catch(() => '');\r\n                this.log(`[AI] Extracted tweet text (${tweetText.length} chars)`);\r\n\r\n                if (tweetText.length < 10) {\r\n                    this.log('[AI] Tweet text too short, trying alternative selectors...');\r\n                    // Try alternative selectors\r\n                    const alternatives = [\r\n                        '[data-testid=\"tweetText\"]',\r\n                        '[lang] > div',\r\n                        'article [role=\"group\"]',\r\n                        '.tweet-text'\r\n                    ];\r\n\r\n                    for (const selector of alternatives) {\r\n                        const altEl = this.page.locator(selector).first();\r\n                        if (await altEl.count() > 0) {\r\n                            const altText = await altEl.innerText().catch(() => '');\r\n                            if (altText.length > tweetText.length) {\r\n                                tweetText = altText;\r\n                                this.log(`[AI] Found better text (${altText.length} chars) with ${selector}`);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                this.log('[AI] WARNING: Could not find tweet text element!');\r\n            }\r\n\r\n            // Extract username from page URL\r\n            if (username === 'unknown') {\r\n                try {\r\n                    const url = this.page.url();\r\n                    const match = url && url.match(/x\\.com\\/(\\w+)\\/status/);\r\n                    if (match) username = match[1];\r\n                } catch (e) { }\r\n            }\r\n\r\n            // Validate we have tweet text\r\n            if (!tweetText || tweetText.length < 5) {\r\n                this.log('[AI] WARNING: Could not extract valid tweet text. Skipping AI reply.');\r\n                // Still read the page and return normally\r\n                await this._readExpandedTweet();\r\n                await this.endDive(true, true);\r\n                return;\r\n            }\r\n\r\n            // ================================================================\r\n            // AI DECISION: Use Action Runner for smart probability redistribution\r\n            // ================================================================\r\n            let selectedAction = null;\r\n            let actionSuccess = false;\r\n            let enhancedContext = {};\r\n\r\n            // 1. Select Action (Fast, probability based) - OUTSIDE QUEUE\r\n            // This prevents holding the queue lock just to decide what to do\r\n            selectedAction = this.actionRunner.selectAction();\r\n\r\n            if (selectedAction) {\r\n                this.log(`[AI-Engage] Selected: ${selectedAction.toUpperCase()}`);\r\n\r\n                // 2. Pre-fetch Context (Heavy scrolling) - OUTSIDE QUEUE\r\n                // This ensures we only block the queue for actual AI generation\r\n                if (selectedAction === 'reply' || selectedAction === 'quote') {\r\n                    this.log(`[AI-Engage] Pre-fetching context for ${selectedAction}...`);\r\n                    try {\r\n                        enhancedContext = await this.contextEngine.extractEnhancedContext(\r\n                            this.page,\r\n                            tweetUrl,\r\n                            tweetText,\r\n                            username\r\n                        );\r\n                    } catch (err) {\r\n                        this.log(`[AI-Engage] Context extraction failed: ${err.message}`);\r\n                    }\r\n                }\r\n            } else {\r\n                this.log(`[AI-Engage] No action selected (all at limits or disabled)`);\r\n            }\r\n\r\n            // Define the AI logic as a standalone async function\r\n            const executeAILogic = async () => {\r\n                const action = selectedAction;\r\n                let success = false;\r\n                let reason = '';\r\n\r\n                if (!action) {\r\n                    // Already logged above\r\n                } else {\r\n                    const context = {\r\n                        tweetText,\r\n                        username,\r\n                        tweetUrl,\r\n                        enhancedContext: enhancedContext // Pass pre-fetched context\r\n                    };\r\n\r\n                    const result = await this.actionRunner.executeAction(action, context);\r\n                    success = result.success && result.executed;\r\n                    reason = result.reason;\r\n\r\n                    if (success) {\r\n                        this.log(`[AI-Engage]  ${action} executed: ${reason}`);\r\n                    } else if (!result.executed) {\r\n                        this.log(`[AI-Engage]  ${action} skipped: ${reason}`);\r\n                    } else {\r\n                        this.log(`[AI-Engage]  ${action} failed: ${reason}`);\r\n                    }\r\n                }\r\n                return { action, success };\r\n            };\r\n\r\n            // Execute via wrapper (Queue) or directly\r\n            if (queueWrapper) {\r\n                const wrapperResult = await queueWrapper(executeAILogic);\r\n                if (wrapperResult.success) {\r\n                    selectedAction = wrapperResult.result.action;\r\n                    actionSuccess = wrapperResult.result.success;\r\n                } else {\r\n                     this.log(`[AI-Engage] Queue/AI failed: ${wrapperResult.error}`);\r\n                     actionSuccess = false;\r\n                }\r\n            } else {\r\n                // Legacy mode / Direct execution\r\n                const res = await executeAILogic();\r\n                selectedAction = res.action;\r\n                actionSuccess = res.success;\r\n            }\r\n\r\n            // Store tweet context for Post-Dive engagement (if needed for fallbacks)\r\n            this._lastTweetText = tweetText;\r\n            this._lastUsername = username;\r\n            this._lastTweetUrl = tweetUrl;\r\n\r\n            // ================================================================\r\n            // Read expanded tweet or navigate home immediately if successful\r\n            // ================================================================\r\n            if (actionSuccess) {\r\n                this.log(`[Dive] Action successful, skipping reading phase and returning home...`);\r\n            } else {\r\n                await this._readExpandedTweet();\r\n            }\r\n\r\n            // ================================================================\r\n            // RELEASE DIVE LOCK AND RETURN TO HOME\r\n            // ================================================================\r\n            // Only navigate home if action was NOT successful\r\n            if (!actionSuccess) {\r\n                await this.endDive(true, true);\r\n            } else {\r\n                // Action was successful, just release the lock\r\n                await this.endDive(true, false);\r\n            }\r\n\r\n        } catch (error) {\r\n            this.log('[Dive] Dive sequence failed: ' + error.message);\r\n            // Release lock on error\r\n            await this.endDive(false, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Quick fallback engagement when AI pipeline times out\r\n     * Performs basic engagement without AI processing\r\n     */\r\n    async _quickFallbackEngagement() {\r\n        try {\r\n            this.log('[DiveQueue-Fallback] Executing quick engagement (no AI)...');\r\n\r\n            const engagementRoll = Math.random();\r\n            const engagementType = engagementRoll < 0.4 ? 'like' :\r\n                engagementRoll < 0.7 ? 'bookmark' : 'none';\r\n\r\n            if (engagementType === 'like') {\r\n                if (this.diveQueue.canEngage('likes')) {\r\n                    await this.handleLike();\r\n                    this.diveQueue.recordEngagement('likes');\r\n                    return { engagementType: 'like', success: true };\r\n                }\r\n            } else if (engagementType === 'bookmark') {\r\n                if (this.diveQueue.canEngage('bookmarks')) {\r\n                    await this.handleBookmark();\r\n                    this.diveQueue.recordEngagement('bookmarks');\r\n                    return { engagementType: 'bookmark', success: true };\r\n                }\r\n            }\r\n\r\n            this.log('[DiveQueue-Fallback] No engagement performed (limits reached)');\r\n            return { engagementType: 'none', success: true };\r\n\r\n        } catch (error) {\r\n            this.log(`[DiveQueue-Fallback] Engagement failed: ${error.message}`);\r\n            return { engagementType: 'error', success: false, error: error.message };\r\n        }\r\n    }\r\n\r\n    /**\r\n         * Ensure sufficient exploration scroll before diving\r\n         * Prevents re-diving into the same feed area\r\n         */\r\n    async _ensureExplorationScroll() {\r\n        const currentY = await this.page.evaluate(() => window.scrollY);\r\n        const docHeight = await this.page.evaluate(() => document.body.scrollHeight);\r\n        const scrollDelta = currentY - this._lastScrollY;\r\n        const timeSinceLastScroll = Date.now() - this._lastScrollTime;\r\n\r\n        // If scrolled enough or near bottom, no need for extra scroll\r\n        if (scrollDelta >= this._minScrollPerDive || currentY > docHeight - 1500) {\r\n            return true;\r\n        }\r\n\r\n        // If at top (near 0), need to scroll significantly\r\n        if (currentY < 100) {\r\n            this.log(`[Scroll] Starting from top, performing exploration scroll (${this._scrollExplorationThreshold}px)...`);\r\n            // Scroll with variance (0.8x - 1.2x) for natural behavior\r\n            const variance = 0.8 + Math.random() * 0.4;\r\n            const scrollAmount = Math.floor(this._scrollExplorationThreshold * variance);\r\n            await scrollDown(this.page, scrollAmount);\r\n            await this.page.waitForTimeout(mathUtils.randomInRange(800, 1500));\r\n            this._lastScrollY = await this.page.evaluate(() => window.scrollY);\r\n            this._lastScrollTime = Date.now();\r\n            return true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n       * Internal method: diveTweet with AI reply (original logic)\r\n       * Now includes dive locking to prevent scroller interference\r\n         */\r\n    async _diveTweetWithAI() {\r\n        try {\r\n            // ================================================================\r\n            // ACQUIRE DIVE LOCK - Prevents scroller interference\r\n            // ================================================================\r\n            await this.startDive();\r\n\r\n            // ENSURE EXPLORATION SCROLL - Prevent re-diving same area\r\n            await this._ensureExplorationScroll();\r\n\r\n            let targetTweet = null;\r\n\r\n            // Find suitable tweet with increased scroll distance\r\n            for (let attempt = 0; attempt < 3; attempt++) {\r\n                const tweets = this.page.locator('article[data-testid=\"tweet\"]');\r\n                const count = await tweets.count();\r\n\r\n                if (count > 0) {\r\n                    for (let i = 0; i < Math.min(count, 10); i++) {\r\n                        const t = tweets.nth(i);\r\n                        const box = await t.boundingBox();\r\n                        // Extended viewport range to catch more tweets\r\n                        if (box && box.height > 0 && box.y > -100 && box.y < 1200) {\r\n                            targetTweet = t;\r\n                            // Reduced early break probability (0.4 -> 0.2) for more exploration\r\n                            if (Math.random() > 0.2) break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (targetTweet) break;\r\n\r\n                this.log('[Dive] No suitable tweets. Scrolling...');\r\n                // Increased scroll distance (300 -> 600) with variance for natural behavior\r\n                const variance = 0.85 + Math.random() * 0.3;\r\n                const scrollAmount = Math.floor(600 * variance);\r\n                await scrollDown(this.page, scrollAmount);\r\n                await this.page.waitForTimeout(entropy.retryDelay(attempt));\r\n\r\n                // Update scroll tracking\r\n                this._lastScrollY = await this.page.evaluate(() => window.scrollY);\r\n                this._lastScrollTime = Date.now();\r\n            }\r\n\r\n            if (!targetTweet) {\r\n                this.log('[Dive] No suitable tweets found. Refreshing Home...');\r\n                await this.page.goto('https://x.com/');\r\n                await this.ensureForYouTab();\r\n                // Release lock before returning\r\n                await this.endDive(false, true);\r\n                return;\r\n            }\r\n\r\n            // Get username from tweet for URL construction\r\n            let username = 'unknown';\r\n            try {\r\n                const tweetTextEl = targetTweet.locator('[data-testid=\"tweetText\"]').first();\r\n                if (await tweetTextEl.count() > 0) {\r\n                    const parent = await tweetTextEl.$x('..');\r\n                    if (parent && parent[0]) {\r\n                        const link = await parent[0].$('a[href*=\"/\"]');\r\n                        if (link) {\r\n                            const href = await link.getAttribute('href');\r\n                            username = href?.replace(/^\\/|\\/$/g, '') || 'unknown';\r\n                        }\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                username = 'unknown';\r\n            }\r\n\r\n            // Determine click target\r\n            let clickTarget = null;\r\n            const timeStamp = targetTweet.locator('time').first();\r\n\r\n            const tweetTextEl = targetTweet.locator('[data-testid=\"tweetText\"]').first();\r\n\r\n            if (await tweetTextEl.count() > 0 && await tweetTextEl.isVisible()) {\r\n                clickTarget = tweetTextEl;\r\n                this.log('[Debug] Targeting tweet text body (Primary).');\r\n            } else if (await timeStamp.count() > 0 && await timeStamp.isVisible()) {\r\n                const parentLink = timeStamp.locator('xpath=./ancestor::a[1]');\r\n                clickTarget = (await parentLink.count() > 0) ? parentLink : timeStamp;\r\n                this.log('[Debug] Targeting tweet permalink/time (Fallback).');\r\n            } else {\r\n                clickTarget = targetTweet;\r\n                this.log('[Debug] Targeting entire tweet card (Last Resort).');\r\n            }\r\n\r\n            if (clickTarget) {\r\n                await clickTarget.evaluate(el => el.scrollIntoView({ block: 'center', inline: 'center' }));\r\n                await this.page.waitForTimeout(entropy.scrollSettleTime());\r\n\r\n                const dbgBox = await clickTarget.boundingBox();\r\n                this.log(`[Debug] Target: Box=${dbgBox ? `x:${Math.round(dbgBox.x)},y:${Math.round(dbgBox.y)}` : 'null'}`);\r\n\r\n                this.log('[Attempt] Ghost Click on Permalink...');\r\n                await this.humanClick(clickTarget, 'Tweet Permalink');\r\n            }\r\n\r\n            // Wait for navigation to tweet page\r\n            let tweetUrl = '';\r\n            let expanded = false;\r\n            try {\r\n                // Wait for URL to contain /status/\r\n                await this.page.waitForURL('**/status/**', { timeout: TWITTER_TIMEOUTS.NAVIGATION });\r\n                tweetUrl = this.page.url();\r\n                this.log('[Success] Navigated to tweet page.');\r\n                this.log(`[Debug] Tweet URL: ${tweetUrl}`);\r\n                expanded = true;\r\n            } catch (e) {\r\n                this.log('[Fail] Ghost Click did not navigate. Retrying with NATIVE click...');\r\n                if (clickTarget) {\r\n                    await clickTarget.click({ force: true });\r\n                }\r\n                try {\r\n                    await this.page.waitForURL('**/status/**', { timeout: TWITTER_TIMEOUTS.NAVIGATION });\r\n                    tweetUrl = this.page.url();\r\n                    this.log('[Success] Native Click navigated to tweet.');\r\n                    expanded = true;\r\n                } catch (e2) {\r\n                    this.log('[Fail] Failed to expand tweet. Aborting dive.');\r\n                    // Release lock before returning\r\n                    await this.endDive(false, true);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (!expanded) {\r\n                await this.endDive(false, true);\r\n                return;\r\n            }\r\n\r\n            // Skip if already processed this tweet\r\n            const tweetIdMatch = tweetUrl && tweetUrl.match(/status\\/(\\d+)/);\r\n            if (tweetIdMatch) {\r\n                const tweetId = tweetIdMatch[1];\r\n                if (this._processedTweetIds.has(tweetId)) {\r\n                    this.log(`[AI] Already processed tweet ${tweetId}, skipping...`);\r\n                    await this.endDive(true, true);\r\n                    return;\r\n                }\r\n                this._processedTweetIds.add(tweetId);\r\n                this.log(`[AI] Tracking new tweet ${tweetId}`);\r\n            }\r\n\r\n            // ================================================================\r\n            // EXTRACT TWEET CONTENT AFTER NAVIGATION (PRIMARY SOURCE)\r\n            // ================================================================\r\n            this.log('[AI] Extracting tweet content from full page...');\r\n\r\n            // Wait for tweet content to fully load\r\n            await this.page.waitForSelector('[data-testid=\"tweetText\"]', { timeout: TWITTER_TIMEOUTS.ELEMENT_VISIBLE }).catch(() => { });\r\n            await this.page.waitForTimeout(1000);  // Additional settle time\r\n\r\n            // Extract FRESH tweet text AFTER navigation\r\n            let tweetText = '';\r\n            const freshTextEl = this.page.locator('[data-testid=\"tweetText\"]').first();\r\n\r\n            if (await freshTextEl.count() > 0) {\r\n                tweetText = await freshTextEl.innerText().catch(() => '');\r\n                this.log(`[AI] Extracted tweet text (${tweetText.length} chars)`);\r\n\r\n                if (tweetText.length < 10) {\r\n                    this.log('[AI] Tweet text too short, trying alternative selectors...');\r\n                    // Try alternative selectors\r\n                    const alternatives = [\r\n                        '[data-testid=\"tweetText\"]',\r\n                        '[lang] > div',\r\n                        'article [role=\"group\"]',\r\n                        '.tweet-text'\r\n                    ];\r\n\r\n                    for (const selector of alternatives) {\r\n                        const altEl = this.page.locator(selector).first();\r\n                        if (await altEl.count() > 0) {\r\n                            const altText = await altEl.innerText().catch(() => '');\r\n                            if (altText.length > tweetText.length) {\r\n                                tweetText = altText;\r\n                                this.log(`[AI] Found better text (${altText.length} chars) with ${selector}`);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                this.log('[AI] WARNING: Could not find tweet text element!');\r\n            }\r\n\r\n            // Extract username from page URL\r\n            if (username === 'unknown') {\r\n                try {\r\n                    const url = this.page.url();\r\n                    const match = url && url.match(/x\\.com\\/(\\w+)\\/status/);\r\n                    if (match) username = match[1];\r\n                } catch (e) { }\r\n            }\r\n\r\n            // Validate we have tweet text\r\n            if (!tweetText || tweetText.length < 5) {\r\n                this.log('[AI] WARNING: Could not extract valid tweet text. Skipping AI reply.');\r\n                // Still read the page and return normally\r\n                await this._readExpandedTweet();\r\n                await this.endDive(true, true);\r\n                return;\r\n            }\r\n\r\n            // ================================================================\r\n            // AI DECISION: Use Action Runner for smart probability redistribution\r\n            // ================================================================\r\n            const selectedAction = this.actionRunner.selectAction();\r\n            let actionSuccess = false;\r\n\r\n            if (!selectedAction) {\r\n                this.log(`[AI-Engage] No action selected (all at limits or disabled)`);\r\n            } else {\r\n                this.log(`[AI-Engage] Selected: ${selectedAction.toUpperCase()}`);\r\n\r\n                const context = {\r\n                    tweetText,\r\n                    username,\r\n                    tweetUrl,\r\n                    enhancedContext: {}\r\n                };\r\n\r\n                const result = await this.actionRunner.executeAction(selectedAction, context);\r\n                actionSuccess = result.success && result.executed;\r\n\r\n                if (actionSuccess) {\r\n                    this.log(`[AI-Engage]  ${selectedAction} executed: ${result.reason}`);\r\n                } else if (!result.executed) {\r\n                    this.log(`[AI-Engage]  ${selectedAction} skipped: ${result.reason}`);\r\n                } else {\r\n                    this.log(`[AI-Engage]  ${selectedAction} failed: ${result.reason}`);\r\n                }\r\n            }\r\n\r\n            // Store tweet context for Post-Dive engagement (if needed for fallbacks)\r\n            this._lastTweetText = tweetText;\r\n            this._lastUsername = username;\r\n            this._lastTweetUrl = tweetUrl;\r\n\r\n            // ================================================================\r\n            // Read expanded tweet or navigate home immediately if successful\r\n            // ================================================================\r\n            if (actionSuccess) {\r\n                this.log(`[Dive] Action successful, skipping reading phase and returning home...`);\r\n            } else {\r\n                await this._readExpandedTweet();\r\n            }\r\n\r\n            // ================================================================\r\n            // RELEASE DIVE LOCK AND RETURN TO HOME\r\n            // ================================================================\r\n            // ================================================================\r\n            // RELEASE DIVE LOCK AND RETURN TO HOME\r\n            // ================================================================\r\n            // Only navigate home if action was NOT successful\r\n            if (!actionSuccess) {\r\n                await this.endDive(true, true);\r\n            } else {\r\n                // Action was successful, just release the lock\r\n                await this.endDive(true, false);\r\n            }\r\n\r\n        } catch (error) {\r\n            this.log('[Dive] Dive sequence failed: ' + error.message);\r\n            // Release lock on error\r\n            await this.endDive(false, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Read expanded tweet page (reading, media, replies, etc.)\r\n     */\r\n    async _readExpandedTweet() {\r\n        // Text highlighting before reading\r\n        if (Math.random() < 0.15) {\r\n            await this.highlightText().catch(() => { });\r\n        }\r\n\r\n        // Read main tweet\r\n        const readTime = mathUtils.randomInRange(5000, 15000);\r\n        this.log(`[Idle] Reading expanded tweet for ${readTime}ms...`);\r\n\r\n        // During long reads, occasionally trigger micro-interactions\r\n        const fidgetDuringRead = readTime > 8000;\r\n        let fidgetInterval = null;\r\n\r\n        if (fidgetDuringRead) {\r\n            fidgetInterval = this.startFidgetLoop();\r\n        }\r\n\r\n        await this.page.waitForTimeout(readTime);\r\n\r\n        if (fidgetInterval) {\r\n            this.stopFidgetLoop();\r\n        }\r\n\r\n        // Optional micro-interaction after reading\r\n        if (Math.random() < 0.2) {\r\n            await this.triggerMicroInteraction('post_read');\r\n        }\r\n\r\n        // Optional media\r\n        if (mathUtils.roll(0.2)) {\r\n            const media = this.page.locator('[data-testid=\"tweetPhoto\"]').first();\r\n            if (await media.count() > 0 && await media.isVisible()) {\r\n                this.log('[Action] Open media viewer');\r\n                await this.humanClick(media, 'Media Viewer');\r\n                const viewTime = mathUtils.randomInRange(5000, 12000);\r\n                this.log(`[Media] Viewing media for ${(viewTime / 1000).toFixed(1)}s...`);\r\n                await this.page.waitForTimeout(viewTime);\r\n                await this.page.keyboard.press('Escape', { delay: mathUtils.randomInRange(50, 150) });\r\n                await this.page.waitForTimeout(mathUtils.randomInRange(400, 900));\r\n            }\r\n        }\r\n\r\n        // Read replies\r\n        this.log('[Scroll] Reading replies...');\r\n        await scrollRandom(this.page, 300, 600);\r\n        await this.page.waitForTimeout(mathUtils.randomInRange(2000, 4000));\r\n\r\n        // Return scroll\r\n        await scrollRandom(this.page, 240, 660);\r\n        await this.page.waitForTimeout(mathUtils.randomInRange(1000, 2000));\r\n\r\n        // Note: Post-Dive engagement removed to favor strictly single-action-per-dive policy\r\n\r\n        // Clear cached tweet context\r\n        this._lastTweetText = null;\r\n        this._lastUsername = null;\r\n        this._lastTweetUrl = null;\r\n\r\n        // Idle and return home\r\n        await this.page.waitForTimeout(mathUtils.randomInRange(1200, 2400));\r\n        await this.navigateHome();\r\n        await this.page.waitForTimeout(mathUtils.randomInRange(1500, 3000));\r\n    }\r\n\r\n    /**\r\n           * Override runSession to use dive queue and respect operation lock\r\n           * Prevents scroller interference during tweet diving operations\r\n           */\r\n    async runSession(cycles = 10, minDurationSec = 0, maxDurationSec = 0) {\r\n        this.log(`[AITwitterAgent] Starting AI-Enhanced Session with DiveQueue and Lock Management...`);\r\n\r\n        // ================================================================\r\n        // SETUP PHASE\r\n        // ================================================================\r\n\r\n        // Enable quick mode if we're in cooldown phase\r\n        const originalDiveTweet = this.diveTweet.bind(this);\r\n\r\n        // Wrap diveTweet to enable quick mode when needed\r\n        this.diveTweet = async () => {\r\n            try {\r\n                if (this.isInCooldown() && !this.quickModeEnabled) {\r\n                    this.log('[DiveQueue] Enabling quick mode for cooldown phase');\r\n                    this.diveQueue.enableQuickMode();\r\n                    this.quickModeEnabled = true;\r\n                }\r\n                const result = await originalDiveTweet();\r\n                return result;\r\n            } catch (error) {\r\n                this.log(`[DiveQueue] Wrapped diveTweet error: ${error.message}`);\r\n                throw error;\r\n            }\r\n        };\r\n\r\n        // Initialize session from parent\r\n        this.log(`Starting Session on ${this.page.url()}`);\r\n\r\n        if (minDurationSec > 0 && maxDurationSec > 0) {\r\n            const durationMs = mathUtils.randomInRange(minDurationSec * 1000, maxDurationSec * 1000);\r\n            this.sessionEndTime = Date.now() + durationMs;\r\n            this.log(`Session Timer Set: ${(durationMs / 1000).toFixed(1)}s`);\r\n        } else {\r\n            this.log(`Session Mode: Fixed Cycles (${cycles})`);\r\n        }\r\n\r\n        // Navigate to home if not already there\r\n        if (!this.page.url().includes('home')) {\r\n            await this.navigateHome();\r\n        }\r\n\r\n        // Theme enforcement - apply early to prevent flashing\r\n        const theme = this.twitterConfig.theme || 'dark';\r\n        if (theme) {\r\n            this.log(`Enforcing theme: ${theme}`);\r\n            await this.page.emulateMedia({ colorScheme: theme });\r\n        }\r\n\r\n        // Human-like session warmup\r\n        await this.human.sessionStart();\r\n\r\n        // Initial login check\r\n        for (let i = 0; i < 3; i++) {\r\n            const isLoggedIn = await this.checkLoginState();\r\n            if (isLoggedIn) break;\r\n\r\n            if (i < 2) {\r\n                const delay = entropy.retryDelay(i, 5000);\r\n                this.log(`[Validation] Login check failed (${i + 1}/3). Retrying in ${(delay / 1000).toFixed(1)}s...`);\r\n                await this.page.waitForTimeout(delay);\r\n            }\r\n        }\r\n\r\n        if (this.state.consecutiveLoginFailures >= 3) {\r\n            this.log(' Aborting session: Not logged in (3 consecutive failures).');\r\n            return;\r\n        }\r\n\r\n        // ================================================================\r\n        // MAIN SESSION LOOP WITH OPERATION LOCK CHECKS\r\n        // ================================================================\r\n\r\n        while (true) {\r\n            // ============================================================\r\n            // CHECK END CONDITIONS\r\n            // ============================================================\r\n\r\n            // Check if should end session naturally\r\n            const elapsed = Date.now() - this.sessionStart;\r\n            if (this.human.session.shouldEndSession(elapsed)) {\r\n                this.log(` Natural session end reached. Finishing...`);\r\n                break;\r\n            }\r\n\r\n            // Check session timeout\r\n            if (this.isSessionExpired()) {\r\n                this.log(` Session Time Limit Reached. Finishing...`);\r\n                break;\r\n            }\r\n\r\n            // Check login failures\r\n            if (this.state.consecutiveLoginFailures >= 3) {\r\n                this.log(` ABORTING: Detected 'Not Logged In' state 3 times consecutively.`);\r\n                break;\r\n            }\r\n\r\n            // Check cycle limit\r\n            if (!this.sessionEndTime && this.loopIndex >= cycles) {\r\n                this.log(`Session Cycle Limit Reached (${cycles}). Finishing...`);\r\n                break;\r\n            }\r\n\r\n            this.loopIndex += 1;\r\n            this.log(`--- Loop ${this.loopIndex} ${this.sessionEndTime ? '' : `of ${cycles}`} ---`);\r\n\r\n            // ============================================================\r\n            // HEALTH CHECK - Verify connection health before proceeding\r\n            // ============================================================\r\n            const healthCheckInterval = 10; // Check every 10 loops\r\n            if (this.loopIndex % healthCheckInterval === 0) {\r\n                this.log('[Health] Performing periodic health check...');\r\n                const health = await this.performHealthCheck();\r\n\r\n                if (!health.healthy) {\r\n                    this.logWarn(`[Health] Unhealthy: ${health.reason}. Attempting recovery...`);\r\n                    // Attempt recovery by navigating home\r\n                    try {\r\n                        await this.navigateHome();\r\n                        await this.page.waitForTimeout(2000);\r\n                        const retryHealth = await this.performHealthCheck();\r\n                        if (!retryHealth.healthy) {\r\n                            this.logWarn('[Health] Recovery failed, continuing with caution');\r\n                        } else {\r\n                            this.log('[Health] Recovery successful');\r\n                        }\r\n                    } catch (e) {\r\n                        this.logWarn(`[Health] Recovery attempt failed: ${e.message}`);\r\n                    }\r\n                } else {\r\n                    this.log('[Health] Connection healthy');\r\n                }\r\n            }\r\n\r\n            // Boredom pause every 4th cycle\r\n            if (this.loopIndex % 4 === 0 && mathUtils.roll(0.25)) {\r\n                await this.human.session.boredomPause(this.page);\r\n            }\r\n\r\n            // ============================================================\r\n            // CHECK OPERATION LOCK BEFORE CONTINUING\r\n            // ============================================================\r\n\r\n            // Wait for diving operation to complete if lock is acquired\r\n            let firstSessionWait = true;\r\n            if (this.operationLock) {\r\n                while (this.operationLock) {\r\n                    const now = Date.now();\r\n\r\n                    // Only log every 10 seconds to prevent log spam\r\n                    if (firstSessionWait || now - this.lastWaitLogTime >= this.waitLogInterval) {\r\n                        this.log(`[Session]  Waiting for diving operation to complete... (${((now - this.lastWaitLogTime) / 1000).toFixed(0)}s elapsed)`);\r\n                        this.lastWaitLogTime = now;\r\n                        firstSessionWait = false;\r\n                    }\r\n\r\n                    await new Promise(resolve => setTimeout(resolve, 100));\r\n                }\r\n                this.log('[Session]  Diving operation completed, continuing session');\r\n                this.lastWaitLogTime = 0;  // Reset wait log timestamp\r\n            }\r\n\r\n            // ============================================================\r\n            // BURST MODE STATE MACHINE\r\n            // ============================================================\r\n\r\n            const now = Date.now();\r\n            if (this.state.activityMode === 'BURST') {\r\n                if (now > this.state.burstEndTime) {\r\n                    this.state.activityMode = 'NORMAL';\r\n                    this.log(' Burst Mode Ended. Returning to normal pace.');\r\n                }\r\n            } else if (this.state.activityMode === 'NORMAL') {\r\n                if (!this.isFatigued && mathUtils.roll(0.10)) {\r\n                    this.state.activityMode = 'BURST';\r\n                    const duration = mathUtils.randomInRange(30000, 60000);\r\n                    this.state.burstEndTime = now + duration;\r\n                    this.log(` >>> ENTERING BURST MODE! High intensity for ${(duration / 1000).toFixed(1)}s`);\r\n                }\r\n            }\r\n\r\n            // ============================================================\r\n            // SIMULATE READING (WITH SCROLL LOCK CHECK)\r\n            // ============================================================\r\n\r\n            if (this.operationLock) {\r\n                // Skip reading during diving operations\r\n                this.log('[Session] Skipping reading (diving operation in progress)');\r\n            } else {\r\n                await this.simulateReading();\r\n                if (this.isSessionExpired()) break;\r\n            }\r\n\r\n            // ============================================================\r\n            // DECISION LOGIC\r\n            // ============================================================\r\n\r\n            // Wait for lock again after reading with buffered logging\r\n            let secondSessionWait = true;\r\n            if (this.operationLock) {\r\n                while (this.operationLock) {\r\n                    const now = Date.now();\r\n\r\n                    // Only log every 10 seconds to prevent log spam\r\n                    if (secondSessionWait || now - this.lastWaitLogTime >= this.waitLogInterval) {\r\n                        this.log(`[Session]  Waiting for diving operation after reading... (${((now - this.lastWaitLogTime) / 1000).toFixed(0)}s elapsed)`);\r\n                        this.lastWaitLogTime = now;\r\n                        secondSessionWait = false;\r\n                    }\r\n\r\n                    await new Promise(resolve => setTimeout(resolve, 100));\r\n                }\r\n                this.lastWaitLogTime = 0;  // Reset wait log timestamp\r\n            }\r\n\r\n            // Check end conditions again\r\n            if (this.isSessionExpired()) break;\r\n\r\n            const p = this.normalizeProbabilities(this.twitterConfig.probabilities);\r\n            const roll = Math.random();\r\n            let cursor = 0;\r\n\r\n            if (roll < (cursor += p.refresh)) {\r\n                this.log('[Branch] Refresh Feed');\r\n                this.state.lastRefreshAt = Date.now();\r\n                await this.navigateHome();\r\n                await this.page.waitForTimeout(Math.max(50, mathUtils.gaussian(1500, 600)));\r\n            } else if (roll < (cursor += p.profileDive)) {\r\n                await this.diveProfile();\r\n            } else if (roll < (cursor += p.tweetDive)) {\r\n                await this.diveTweet();\r\n                // endDive(true, true) already handles: navigate to home, wait 500ms, release lock\r\n                // Just continue scrolling from home\r\n                await this.simulateReading();\r\n            } else {\r\n                this.log('[Branch] Idle (Staring at screen)');\r\n                const idleCfg = this.twitterConfig.timings?.actionSpecific?.idle || { mean: 5000, deviation: 2000 };\r\n                const duration = Math.max(1000, mathUtils.gaussian(idleCfg.mean, idleCfg.deviation));\r\n                await this.page.waitForTimeout(duration);\r\n            }\r\n\r\n            // Wind-down if under 20s remaining\r\n            if (this.sessionEndTime && (this.sessionEndTime - Date.now() < 20000)) {\r\n                this.log('Winding down session... Navigating Home and idling briefly.');\r\n                await this.navigateHome();\r\n                await this.page.waitForTimeout(mathUtils.randomInRange(1500, 3000));\r\n                break;\r\n            }\r\n\r\n            // Human-like cycle complete\r\n            await this.human.cycleComplete();\r\n        }\r\n\r\n        // ================================================================\r\n        // CLEANUP PHASE\r\n        // ================================================================\r\n\r\n        // Wait for any pending operations with buffered logging\r\n        let finalCleanupWait = true;\r\n        if (this.operationLock) {\r\n            while (this.operationLock) {\r\n                const now = Date.now();\r\n\r\n                // Only log every 10 seconds to prevent log spam\r\n                if (finalCleanupWait || now - this.lastWaitLogTime >= this.waitLogInterval) {\r\n                    this.log(`[Session]  Waiting for final diving operation to complete... (${((now - this.lastWaitLogTime) / 1000).toFixed(0)}s elapsed)`);\r\n                    this.lastWaitLogTime = now;\r\n                    finalCleanupWait = false;\r\n                }\r\n\r\n                await new Promise(resolve => setTimeout(resolve, 100));\r\n            }\r\n            this.lastWaitLogTime = 0;  // Reset wait log timestamp\r\n        }\r\n\r\n        // Session wrap-up\r\n        await this.human.sessionEnd();\r\n\r\n        // Flush buffered logs\r\n        await this.flushLogs();\r\n\r\n        this.log('Session Complete.');\r\n\r\n        // Final stats are printed by ai-twitterActivity.js to avoid duplication\r\n    }\r\n\r\n    /**\r\n     * Override simulateReading to respect scrolling lock\r\n     * When diving operation is in progress, skip scrolling and perform idle cursor movement\r\n     */\r\n    async simulateReading() {\r\n        // Check if scrolling is enabled\r\n        if (!this.scrollingEnabled || this.operationLock) {\r\n            this.log('[Idle] Scrolling disabled (diving operation in progress)');\r\n\r\n            // Perform idle cursor movement for human-like behavior\r\n            await this.performIdleCursorMovement();\r\n            return;\r\n        }\r\n\r\n        // Continue with parent's simulateReading implementation\r\n        await super.simulateReading();\r\n    }\r\n\r\n    /**\r\n      * Get dive queue status for monitoring (uses BufferedLogger)\r\n      */\r\n    getQueueStatus() {\r\n        const status = this.diveQueue.getFullStatus();\r\n\r\n        // Use buffered logger for high-frequency queue status updates\r\n        this.queueLogger.info(`Queue: ${status.queueLength} queued, ${status.activeCount} active, ${status.utilization}% utilized`);\r\n        this.queueLogger.info(`Capacity: ${status.capacity}/${status.maxQueueSize}`);\r\n\r\n        if (status.engagementLimits) {\r\n            const limits = status.engagementLimits;\r\n            this.queueLogger.info(`Limits: likes(${limits.likes.used}/${limits.likes.limit}) ` +\r\n                `replies(${limits.replies.used}/${limits.replies.limit}) ` +\r\n                `quotes(${limits.quotes.used}/${limits.quotes.limit}) ` +\r\n                `bookmarks(${limits.bookmarks.used}/${limits.bookmarks.limit})`);\r\n        }\r\n\r\n        if (status.retryInfo && status.retryInfo.pendingRetries > 0) {\r\n            this.queueLogger.warn(`${status.retryInfo.pendingRetries} retries pending`);\r\n        }\r\n\r\n        return status;\r\n    }\r\n\r\n    /**\r\n     * Check if queue is healthy\r\n     */\r\n    isQueueHealthy() {\r\n        return this.diveQueue.isHealthy();\r\n    }\r\n\r\n    /**\r\n     * Handle AI reply decision and execution\r\n     * Flow: Probability check  Sentiment check  Enhanced Context  Reply\r\n      */\r\n    async handleAIReply(tweetText, username, options = {}) {\r\n        const { url = '' } = options;\r\n\r\n        // ================================================================\r\n        // Check if this is a pre-validated reply from _diveTweetWithAI\r\n        // If so, skip probability check and go directly to sentiment analysis\r\n        // ================================================================\r\n        if (options.action === 'reply') {\r\n            this.log(`[AI-Replies] Pre-validated reply - skipping probability check`);\r\n        } else {\r\n            // Original flow - make decision here\r\n            this.aiStats.attempts++;\r\n            this.log(`[AI] Analyzing tweet from @${username}...`);\r\n        }\r\n        this.log(`[AI] Tweet URL: ${url}`);\r\n\r\n        // ================================================================\r\n        // STEP 1: Sentiment analysis (skip negative content)\r\n        // ================================================================\r\n        this.log(`[Sentiment] Analyzing tweet sentiment...`);\r\n        const sentimentResult = sentimentService.analyze(tweetText);\r\n\r\n        // Log basic sentiment (backward compatible)\r\n        this.log(`[SentimentGuard] ${sentimentResult.isNegative ? ' NEGATIVE' : ' Neutral/Positive'} content (score: ${sentimentResult.score.toFixed(2)})`);\r\n\r\n        // Log advanced dimensions\r\n        this.log(`[Sentiment] Dimensions - Valence: ${sentimentResult.dimensions.valence.valence.toFixed(2)}, ` +\r\n            `Arousal: ${sentimentResult.dimensions.arousal.arousal.toFixed(2)}, ` +\r\n            `Dominance: ${sentimentResult.dimensions.dominance.dominance.toFixed(2)}, ` +\r\n            `Sarcasm: ${sentimentResult.dimensions.sarcasm.sarcasm.toFixed(2)}`);\r\n\r\n        // Log engagement recommendations\r\n        if (sentimentResult.engagement.warnings.length > 0) {\r\n            this.log(`[Sentiment] Warnings: ${sentimentResult.engagement.warnings.join(', ')}`);\r\n        }\r\n\r\n        if (sentimentResult.isNegative) {\r\n            this.log(`[AI-Replies] Skipped (negative sentiment)`);\r\n            this.aiStats.skips++;\r\n            return;\r\n        }\r\n\r\n        // Check advanced risk factors\r\n        if (sentimentResult.composite.riskLevel === 'high') {\r\n            this.log(`[AI-Replies] Skipped (high risk: ${sentimentResult.composite.conversationType})`);\r\n            this.aiStats.skips++;\r\n            return;\r\n        }\r\n\r\n        // ================================================================\r\n        // STEP 3: Enhanced Context Capture (metrics, sentiment, tone)\r\n        // ================================================================\r\n        this.log(`[AI-Context] Extracting enhanced context...`);\r\n        const enhancedContext = await this.contextEngine.extractEnhancedContext(\r\n            this.page,\r\n            url,\r\n            tweetText,\r\n            username\r\n        );\r\n\r\n        this.log(`[AI-Context] Enhanced: sentiment=${enhancedContext.sentiment?.overall}, tone=${enhancedContext.tone?.primary}, engagement=${enhancedContext.engagementLevel}, ${enhancedContext.replies.length} replies`);\r\n\r\n        // ================================================================\r\n        // STEP 4: Generate reply with enhanced context\r\n        // ================================================================\r\n\r\n        // If pre-validated, skip shouldReply() call and generate reply directly\r\n        if (options.action === 'reply') {\r\n            const decision = await this.replyEngine.generateReply(tweetText, username, enhancedContext);\r\n\r\n            if (decision.success && decision.reply) {\r\n                // Check engagement limits\r\n                const canReply = this.engagementTracker.canPerform('replies') && this.diveQueue.canEngage('replies');\r\n                if (!canReply) {\r\n                    this.log(`[AI-Replies] Skipped (engagement limit reached)`);\r\n                    this.aiStats.skips++;\r\n                    return;\r\n                }\r\n                this.log(`[AI-Replies] Generated reply: \"${decision.reply.substring(0, 30)}...\"`);\r\n                await this.executeAIReply(decision.reply);\r\n                this.aiStats.replies++;\r\n                return;\r\n            } else {\r\n                this.log(`[AI-Replies] Failed to generate reply: ${decision.reason || 'unknown error'}`);\r\n                this.aiStats.errors++;\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Original flow - use shouldReply() for decision\r\n        const decision = await this.replyEngine.shouldReply(tweetText, username, enhancedContext);\r\n\r\n        // ================================================================\r\n        // STEP 5: Execute decision\r\n        // ================================================================\r\n        switch (decision.decision) {\r\n            case 'reply':\r\n                // Check engagement limits from both systems\r\n                const canReply = this.engagementTracker.canPerform('replies') && this.diveQueue.canEngage('replies');\r\n                if (!canReply) {\r\n                    this.log(`[AI-Replies] Skipped (engagement limit reached - tracker: ${this.engagementTracker.canPerform('replies')}, queue: ${this.diveQueue.canEngage('replies')})`);\r\n                    this.aiStats.skips++;\r\n                    return;\r\n                }\r\n                this.log(`[AI-Replies] Generating reply: \"${decision.reply?.substring(0, 30)}...\"`);\r\n                await this.executeAIReply(decision.reply);\r\n                this.aiStats.replies++;\r\n                break;\r\n\r\n            case 'skip': {\r\n                this.log(`[AI-Replies] Skipped (${decision.reason})`);\r\n                this.aiStats.skips++;\r\n                break;\r\n            }\r\n\r\n            default: {\r\n                this.log(`[AI-Replies] Skipped (no decision)`);\r\n                this.aiStats.skips++;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    async executeAIReply(replyText) {\r\n        try {\r\n            this.log('[AI] Executing reply with human-like behavior...');\r\n\r\n            // Use the new human-like reply engine\r\n            const result = await this.replyEngine.executeReply(this.page, replyText);\r\n\r\n            if (result.success) {\r\n                this.log(`[AI] Reply posted successfully via ${result.method}`);\r\n                this.state.replies++;\r\n\r\n                // Record engagement in both systems\r\n                if (this.engagementTracker.record('replies')) {\r\n                    const progress = this.engagementTracker.getProgress('replies');\r\n                    this.log(`[Engagement] ${progress} Replies posted`);\r\n                }\r\n            } else {\r\n                this.logWarn(`[AI] Reply failed: ${result.reason} (method: ${result.method})`);\r\n            }\r\n\r\n            return result.success;\r\n\r\n        } catch (error) {\r\n            this.log(`[AI] Failed to post reply: ${error.message}`);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    async executeAIQuote(quoteText, tweetUrl = '') {\r\n        try {\r\n            this.log('[AI] Executing quote with human-like behavior...');\r\n\r\n            const result = await this.quoteEngine.executeQuote(this.page, quoteText);\r\n\r\n            if (result.success) {\r\n                this.log(`[AI] Quote posted successfully via ${result.method}`);\r\n                this.state.quotes++;\r\n\r\n                if (this.engagementTracker.record('quotes')) {\r\n                    const progress = this.engagementTracker.getProgress('quotes');\r\n                    this.log(`[Engagement] ${progress} Quotes posted`);\r\n                }\r\n            } else {\r\n                this.logWarn(`[AI] Quote failed: ${result.reason} (method: ${result.method})`);\r\n            }\r\n\r\n            return result.success;\r\n\r\n        } catch (error) {\r\n            this.log(`[AI] Failed to post quote: ${error.message}`);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Verify reply was posted by scanning DOM for reply content\r\n     * @param {string} replyText - The text we attempted to post\r\n     * @returns {Promise<boolean>} True if reply found in DOM\r\n     */\r\n    async verifyReplyPosted(replyText) {\r\n        try {\r\n            // Get current page URL to verify we're still on tweet page\r\n            const currentUrl = this.page.url();\r\n            if (!currentUrl.includes('/status/')) {\r\n                this.log('[Verify] No longer on tweet page');\r\n                return false;\r\n            }\r\n\r\n            // Wait a bit for DOM to update\r\n            await this.page.waitForTimeout(1000);\r\n\r\n            // Look for the reply text in article elements (newly posted reply)\r\n            const articles = await this.page.$$('article');\r\n            this.log(`[Verify] Found ${articles.length} articles on page`);\r\n\r\n            // Get the first few words of our reply to search for\r\n            const searchWords = replyText.split(' ').slice(0, 5).join(' ').toLowerCase();\r\n            this.log(`[Verify] Searching for: \"${searchWords}\"`);\r\n\r\n            // Check each article for our reply text\r\n            for (let i = 0; i < Math.min(articles.length, 5); i++) {\r\n                try {\r\n                    const article = articles[i];\r\n                    const textEl = await article.$('[data-testid=\"tweetText\"], [dir=\"auto\"]');\r\n                    if (textEl) {\r\n                        const articleText = await textEl.innerText().catch(() => '');\r\n                        const articleTextLower = articleText.toLowerCase();\r\n\r\n                        // Check if article contains our reply text (partial match)\r\n                        if (articleTextLower.includes(searchWords) ||\r\n                            searchWords.includes(articleTextLower.slice(0, 30))) {\r\n                            this.log(`[Verify] Found reply in article ${i + 1}`);\r\n                            return true;\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    // Skip failed articles\r\n                }\r\n            }\r\n\r\n            // Alternative: Look for reply count increase or new elements\r\n            const replyBtn = this.page.locator('[data-testid=\"reply\"]').first();\r\n            const replyCount = await replyBtn.count();\r\n\r\n            // Check if composer is closed (reply submitted)\r\n            const composer = this.page.locator('[data-testid=\"tweetText\"]').first();\r\n            const composerCount = await composer.count();\r\n\r\n            if (composerCount > 0) {\r\n                const composerText = await composer.innerText().catch(() => '');\r\n                // If composer is empty or cleared, reply was likely posted\r\n                if (!composerText || composerText.trim().length === 0) {\r\n                    this.log('[Verify] Composer cleared - reply likely posted');\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            this.log('[Verify] Could not verify reply in DOM');\r\n            return false;\r\n\r\n        } catch (error) {\r\n            this.log(`[Verify] Error checking reply: ${error.message}`);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ultra-human-like typing simulation\r\n     * Mimics real human typing patterns to avoid detection\r\n     */\r\n    async humanTypingWithTypos(inputEl, text) {\r\n        const chars = text.split('');\r\n\r\n        // Keyboard layout for proximity typos\r\n        const keyboardLayout = {\r\n            'q': ['w', 'a', '1'], 'w': ['q', 'e', 'a', 's', '2'],\r\n            'e': ['w', 'r', 'd', 's', '3', '4'], 'r': ['e', 't', 'f', 'g', '4', '5'],\r\n            't': ['r', 'y', 'g', 'h', '5', '6'], 'y': ['t', 'u', 'h', 'j', '6', '7'],\r\n            'u': ['y', 'i', 'j', 'k', '7', '8'], 'i': ['u', 'o', 'k', 'l', '8', '9'],\r\n            'o': ['i', 'p', 'l', ';', '9', '0'], 'p': ['o', '[', \"'\", '0'],\r\n            'a': ['q', 'w', 's', 'z'], 's': ['w', 'e', 'd', 'x', 'z', 'a'],\r\n            'd': ['e', 'r', 'f', 'c', 'x', 's'], 'f': ['r', 't', 'g', 'v', 'c', 'd'],\r\n            'g': ['t', 'y', 'h', 'b', 'v', 'f'], 'h': ['y', 'u', 'j', 'n', 'b', 'g'],\r\n            'j': ['u', 'i', 'k', 'm', 'n', 'h'], 'k': ['i', 'o', 'l', ',', 'm', 'j'],\r\n            'l': ['o', 'p', ';', ',', '.', 'k'], 'z': ['a', 's', 'x'], 'x': ['z', 'c', 'd', 's'],\r\n            'c': ['x', 'v', 'f', 'd'], 'v': ['c', 'b', 'g', 'f'], 'b': ['v', 'n', 'h', 'g'],\r\n            'n': ['b', 'm', 'j', 'h'], 'm': ['n', ',', 'j', 'k'],\r\n            '0': ['9', 'p', 'o'], '1': ['2', 'q'], '2': ['1', '3', 'w', 'q'],\r\n            '3': ['2', '4', 'e', 'w'], '4': ['3', '5', 'r', 'e'], '5': ['4', '6', 't', 'r'],\r\n            '6': ['5', '7', 'y', 't'], '7': ['6', '8', 'u', 'y'], '8': ['7', '9', 'i', 'u'],\r\n            '9': ['8', '0', 'o', 'i'],\r\n            '.': [',', 'l', ';', '/'], ',': ['m', '.', 'k', 'j', 'n'],\r\n            ';': ['l', \"'\", 'p', '/'], \"'\": [';', 'p', '[', ']'],\r\n            '[': ['p', \"'\", ']', '\\\\'], ']': ['[', '\\\\'], '\\\\': [']'],\r\n            '-': ['0', '=', '['], '=': ['-', '[', ']']\r\n        };\r\n\r\n        // Shift-required characters\r\n        const shiftChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()_+{}|:\"<>?~';\r\n\r\n        // Track typing state\r\n        let i = 0;\r\n        let consecutiveErrors = 0;\r\n\r\n        while (i < chars.length) {\r\n            const char = chars[i];\r\n            const isUpperCase = char >= 'A' && char <= 'Z';\r\n            const isShiftChar = shiftChars.includes(char);\r\n            const isSpace = char === ' ';\r\n            const isPunctuation = '.,!?;:;\\'\"-()[]{}'.includes(char);\r\n            const isNewline = char === '\\n';\r\n            const prevChar = i > 0 ? chars[i - 1] : null;\r\n            const nextChar = i < chars.length - 1 ? chars[i + 1] : null;\r\n\r\n            // Context-aware typing speed\r\n            let baseDelay;\r\n\r\n            // Position-based speed patterns\r\n            const positionProgress = i / chars.length;\r\n            const charsTyped = i;\r\n            const charsRemaining = chars.length - i;\r\n\r\n            if (charsTyped < 3) {\r\n                // Very slow start (finding keyboard)\r\n                baseDelay = mathUtils.randomInRange(200, 400);\r\n            } else if (charsTyped < 10) {\r\n                // Warming up\r\n                baseDelay = mathUtils.randomInRange(120, 250);\r\n            } else if (positionProgress > 0.8) {\r\n                // Slowing down at end\r\n                baseDelay = mathUtils.randomInRange(100, 200);\r\n            } else {\r\n                // Normal typing rhythm\r\n                baseDelay = mathUtils.randomInRange(60, 150);\r\n            }\r\n\r\n            // Context adjustments\r\n            if (isUpperCase || isShiftChar) {\r\n                // Hold shift - takes extra time\r\n                baseDelay += mathUtils.randomInRange(50, 150);\r\n            }\r\n\r\n            if (isSpace) {\r\n                // Word boundary pause\r\n                baseDelay += mathUtils.randomInRange(80, 200);\r\n\r\n                // Sometimes longer pause between sentences\r\n                if (prevChar === '.' || prevChar === '!' || prevChar === '?') {\r\n                    baseDelay += mathUtils.randomInRange(200, 500);\r\n                }\r\n            }\r\n\r\n            if (isPunctuation && !isSpace) {\r\n                // Punctuation pause\r\n                baseDelay += mathUtils.randomInRange(30, 100);\r\n\r\n                // Longer for sentence end\r\n                if (char === '.' || char === '!' || char === '?') {\r\n                    baseDelay += mathUtils.randomInRange(100, 300);\r\n                }\r\n            }\r\n\r\n            if (isNewline) {\r\n                baseDelay += mathUtils.randomInRange(200, 400);\r\n            }\r\n\r\n            // ERROR SIMULATION\r\n            // Determine if we should make an error\r\n            let makeError = false;\r\n            let errorType = null;\r\n\r\n            if (charsTyped >= 3 && charsRemaining >= 2 && consecutiveErrors < 2) {\r\n                const errorRoll = Math.random();\r\n\r\n                // 8% base error rate\r\n                if (errorRoll < 0.08) {\r\n                    makeError = true;\r\n\r\n                    // Error type distribution:\r\n                    // 40% - adjacent key\r\n                    // 25% - double letter\r\n                    // 20% - skipped letter\r\n                    // 10% - transposition\r\n                    // 5% - no error (just pause)\r\n                    const errorRoll2 = Math.random();\r\n                    if (errorRoll2 < 0.40) errorType = 'adjacent';\r\n                    else if (errorRoll2 < 0.65) errorType = 'double';\r\n                    else if (errorRoll2 < 0.85) errorType = 'skip';\r\n                    else if (errorRoll2 < 0.95) errorType = 'transposition';\r\n                    else errorType = 'pause';\r\n                }\r\n            }\r\n\r\n            if (makeError && errorType !== 'pause') {\r\n                switch (errorType) {\r\n                    case 'adjacent':\r\n                        const charLower = char.toLowerCase();\r\n                        const adjacent = keyboardLayout[charLower];\r\n                        if (adjacent && Math.random() < 0.7) {\r\n                            const wrongChar = adjacent[Math.floor(Math.random() * adjacent.length)];\r\n                            // Type wrong char\r\n                            await this.page.keyboard.type(wrongChar, { delay: baseDelay });\r\n                            // Pause like human noticing\r\n                            await this.page.waitForTimeout(mathUtils.randomInRange(80, 200));\r\n                            // Backspace\r\n                            await this.page.keyboard.press('Backspace', { delay: mathUtils.randomInRange(40, 100) });\r\n                            // Brief pause before correct\r\n                            await this.page.waitForTimeout(mathUtils.randomInRange(30, 80));\r\n                            // Type correct\r\n                            await this.page.keyboard.type(char, { delay: baseDelay + mathUtils.randomInRange(20, 60) });\r\n                            consecutiveErrors++;\r\n                        } else {\r\n                            await this.page.keyboard.type(char, { delay: baseDelay });\r\n                        }\r\n                        break;\r\n\r\n                    case 'double':\r\n                        // Type the same char twice by accident\r\n                        if (Math.random() < 0.6) {\r\n                            await this.page.keyboard.type(char, { delay: baseDelay });\r\n                            await this.page.waitForTimeout(mathUtils.randomInRange(20, 60));\r\n                            await this.page.keyboard.type(char, { delay: baseDelay });\r\n                            await this.page.waitForTimeout(mathUtils.randomInRange(50, 150));\r\n                            // Backspace once to fix\r\n                            await this.page.keyboard.press('Backspace', { delay: mathUtils.randomInRange(40, 100) });\r\n                            consecutiveErrors++;\r\n                        } else {\r\n                            await this.page.keyboard.type(char, { delay: baseDelay });\r\n                        }\r\n                        break;\r\n\r\n                    case 'skip':\r\n                        // Type next char instead of current (transposition)\r\n                        if (i < chars.length - 1 && Math.random() < 0.5) {\r\n                            const nextCharTyped = chars[i + 1];\r\n                            await this.page.keyboard.type(nextCharTyped, { delay: baseDelay });\r\n                            await this.page.waitForTimeout(mathUtils.randomInRange(50, 120));\r\n                            // Notice and correct\r\n                            await this.page.keyboard.press('Backspace', { delay: mathUtils.randomInRange(40, 100) });\r\n                            // Type correct char\r\n                            await this.page.keyboard.type(char, { delay: baseDelay + mathUtils.randomInRange(20, 80) });\r\n                            consecutiveErrors++;\r\n                        } else {\r\n                            await this.page.keyboard.type(char, { delay: baseDelay });\r\n                        }\r\n                        break;\r\n\r\n                    case 'transposition':\r\n                        // Type char in wrong order (like \"teh\" for \"the\")\r\n                        // Handle naturally as skip + adjacent\r\n                        await this.page.keyboard.type(char, { delay: baseDelay });\r\n                        consecutiveErrors++;\r\n                        break;\r\n                }\r\n            } else if (errorType === 'pause') {\r\n                // Human paused while typing (thinking)\r\n                await this.page.waitForTimeout(mathUtils.randomInRange(300, 800));\r\n                await this.page.keyboard.type(char, { delay: baseDelay });\r\n            } else {\r\n                // Normal typing - add slight variation\r\n                await this.page.keyboard.type(char, {\r\n                    delay: baseDelay + mathUtils.randomInRange(-10, 20)\r\n                });\r\n                consecutiveErrors = 0;\r\n            }\r\n\r\n            // Random \"thinking pause\" - 3% chance during typing\r\n            if (Math.random() < 0.03 && charsTyped > 5 && charsRemaining > 5) {\r\n                await this.page.waitForTimeout(mathUtils.randomInRange(200, 600));\r\n            }\r\n\r\n            // Micro mouse movements (hand adjustment) - 5% chance\r\n            if (Math.random() < 0.05) {\r\n                const dx = mathUtils.randomInRange(-20, 20);\r\n                const dy = mathUtils.randomInRange(-10, 10);\r\n                await this.page.mouse.move(dx, dy, { steps: 2 });\r\n            }\r\n\r\n            i++;\r\n        }\r\n\r\n        // Final human touch - sometimes cursor moves away at end\r\n        await this.page.waitForTimeout(mathUtils.randomInRange(100, 300));\r\n    }\r\n\r\n    /**\r\n          * Handle fallback action when AI skips\r\n          */\r\n    async handleFallback(action) {\r\n        try {\r\n            switch (action) {\r\n                case 'bookmark':\r\n                    // Check engagement limits from both systems\r\n                    const canBookmark = this.engagementTracker.canPerform('bookmarks') && this.diveQueue.canEngage('bookmarks');\r\n                    if (!canBookmark) {\r\n                        this.log('[AI-Fallback] Bookmark limit reached, skipping');\r\n                        return;\r\n                    }\r\n\r\n                    const bm = this.page.locator('button[data-testid=\"bookmark\"]').first();\r\n                    if (await bm.count() > 0 && await bm.isVisible()) {\r\n                        this.log('[AI-Fallback] Bookmarking tweet');\r\n                        await this.humanClick(bm, 'Bookmark');\r\n\r\n                        if (this.engagementTracker.record('bookmarks')) {\r\n                            const progress = this.engagementTracker.getProgress('bookmarks');\r\n                            this.log(`[Engagement] ${progress} Bookmarks used`);\r\n                        }\r\n\r\n                        // Also record in dive queue\r\n                        if (this.diveQueue.canEngage('bookmarks')) {\r\n                            this.diveQueue.recordEngagement('bookmarks');\r\n                            const queueProgress = this.diveQueue.getEngagementProgress();\r\n                            this.log(`[DiveQueue-Engagement] Bookmarks: ${queueProgress.bookmarks.current}/${queueProgress.bookmarks.limit}`);\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n                case 'like':\r\n                    await this.handleLike();\r\n                    break;\r\n\r\n                case 'none':\r\n                default:\r\n                    this.log('[AI-Fallback] No action taken');\r\n                    break;\r\n            }\r\n        } catch (error) {\r\n            this.log(`[AI-Fallback] Error: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n          * Handle like button - Robust implementation with smart selectors and fallbacks\r\n          * Optionally accepts tweetText for sentiment analysis\r\n          */\r\n    async handleLike(tweetText = null) {\r\n        try {\r\n            // ================================================================\r\n            // SENTIMENT CHECK - Skip likes on negative content\r\n            // ================================================================\r\n            if (tweetText) {\r\n                const sentimentResult = sentimentService.analyze(tweetText);\r\n                if (!sentimentResult.engagement.canLike) {\r\n                    this.log(`[Sentiment]  Skipping like on negative content ` +\r\n                        `(risk: ${sentimentResult.composite.riskLevel}, ` +\r\n                        `toxicity: ${sentimentResult.dimensions.toxicity.toxicity.toFixed(2)})`);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // Check engagement limits from both systems\r\n            const canLike = this.engagementTracker.canPerform('likes') && this.diveQueue.canEngage('likes');\r\n            if (!canLike) {\r\n                this.log('[Like] Limit reached, skipping');\r\n                return;\r\n            }\r\n\r\n            // ================================================================\r\n            // SMART SELECTOR WITH FALLBACKS (using HumanInteraction)\r\n            // ================================================================\r\n            const likeSelectors = [\r\n                'button[data-testid=\"like\"][role=\"button\"]',\r\n                '[data-testid=\"like\"]',\r\n                '[aria-label=\"Like\"]',\r\n                'svg[aria-label*=\"Like\"]',\r\n                'button:has-text(\"Like\"):not([aria-label*=\"Unlike\"])'\r\n            ];\r\n\r\n            const likeResult = await this.humanInteraction.findWithFallback(likeSelectors, { visible: true, timeout: 5000 });\r\n\r\n            if (!likeResult) {\r\n                this.log('[Like]  Could not find like button with any selector');\r\n                return;\r\n            }\r\n\r\n            const likeButton = likeResult.element;\r\n            const selectedSelector = likeResult.selector;\r\n\r\n            // Check if already liked\r\n            const unlikeSelectors = [\r\n                'button[data-testid=\"unlike\"][role=\"button\"]',\r\n                '[data-testid=\"unlike\"]',\r\n                '[aria-label=\"Unlike\"]',\r\n                '[aria-label*=\"Liked\"]'\r\n            ];\r\n\r\n            const unlikeResult = await this.humanInteraction.findWithFallback(unlikeSelectors, { visible: true, timeout: 1000 });\r\n            if (unlikeResult) {\r\n                this.log(`[Skip] Tweet is ALREADY LIKED (found: ${unlikeResult.selector})`);\r\n                return;\r\n            }\r\n\r\n            // ================================================================\r\n            // PRE-CLICK VERIFICATION\r\n            // ============================================================================================\r\n\r\n            // Wait for element to be stable\r\n            let stableCount = 0;\r\n            const maxStableAttempts = 10;\r\n            let lastBoundingBox = null;\r\n\r\n            while (stableCount < 3 && stableCount < maxStableAttempts) {\r\n                try {\r\n                    const bbox = await likeButton.boundingBox();\r\n                    if (bbox) {\r\n                        if (lastBoundingBox) {\r\n                            const dx = Math.abs(bbox.x - lastBoundingBox.x);\r\n                            const dy = Math.abs(bbox.y - lastBoundingBox.y);\r\n                            if (dx < 3 && dy < 3) {\r\n                                stableCount++;\r\n                            } else {\r\n                                stableCount = 0;\r\n                            }\r\n                        }\r\n                        lastBoundingBox = bbox;\r\n                    }\r\n                } catch { }\r\n\r\n                if (stableCount < 3) {\r\n                    await this.page.waitForTimeout(100);\r\n                    stableCount++;\r\n                }\r\n            }\r\n\r\n            // Check aria-label to confirm not already liked\r\n            try {\r\n                const ariaLabel = await likeButton.getAttribute('aria-label') || '';\r\n                if (ariaLabel.toLowerCase().includes('unlike') || ariaLabel.toLowerCase().includes('liked')) {\r\n                    this.log(`[Skip] Tweet already liked (aria-label: ${ariaLabel})`);\r\n                    return;\r\n                }\r\n            } catch { }\r\n\r\n            // Verify element is actionable (not covered by overlay)\r\n            const isActionable = await this.isElementActionable(likeButton);\r\n            if (!isActionable) {\r\n                this.log('[Like]  Element may be covered, trying scroll adjustment...');\r\n                try {\r\n                    await likeButton.scrollIntoViewIfNeeded();\r\n                    await this.page.waitForTimeout(500);\r\n                } catch { }\r\n            }\r\n\r\n            // ================================================================\r\n            // EXECUTE CLICK\r\n            // ================================================================\r\n            this.log(`[Action]  Like (selector: ${selectedSelector})`);\r\n\r\n            // Try humanClick first, then fallback to native\r\n            try {\r\n                await this.humanClick(likeButton, 'Like Button');\r\n            } catch (e) {\r\n                this.log(`[Like] humanClick failed: ${e.message}, using native click...`);\r\n                try {\r\n                    await likeButton.click({ timeout: TWITTER_TIMEOUTS.ELEMENT_CLICKABLE });\r\n                } catch (e2) {\r\n                    this.log(`[Like] Native click failed: ${e2.message}`);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // ================================================================\r\n            // POST-CLICK VERIFICATION & TRACKING\r\n            // ================================================================\r\n            await this.page.waitForTimeout(mathUtils.randomInRange(1000, 2000));\r\n\r\n            // Check if like was registered (button should now show \"Unlike\")\r\n            let likeRegistered = false;\r\n            for (const selector of unlikeSelectors) {\r\n                try {\r\n                    const el = this.page.locator(selector).first();\r\n                    if (await el.isVisible().catch(() => false)) {\r\n                        likeRegistered = true;\r\n                        break;\r\n                    }\r\n                } catch { }\r\n            }\r\n\r\n            if (likeRegistered) {\r\n                this.log(`[Like]  Successfully liked tweet`);\r\n\r\n                // Record engagement\r\n                if (this.engagementTracker.record('likes')) {\r\n                    const progress = this.engagementTracker.getProgress('likes');\r\n                    this.log(`[Engagement] ${progress} Likes given`);\r\n                }\r\n            } else {\r\n                this.log(`[Like]  Like may not have registered`);\r\n            }\r\n\r\n            // Return to home page to continue main loop\r\n            await this.navigateHome();\r\n            await this.page.waitForTimeout(mathUtils.randomInRange(1500, 3000));\r\n\r\n        } catch (error) {\r\n            this.log(`[Like]  Error: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n          * Handle bookmark button - Robust implementation with smart selectors and fallbacks\r\n          */\r\n    async handleBookmark() {\r\n        try {\r\n            // Check engagement limits from both systems\r\n            const canBookmark = this.engagementTracker.canPerform('bookmarks') && this.diveQueue.canEngage('bookmarks');\r\n            if (!canBookmark) {\r\n                this.log('[Bookmark] Limit reached, skipping');\r\n                return;\r\n            }\r\n\r\n            // ================================================================\r\n            // SMART SELECTOR WITH FALLBACKS (using HumanInteraction)\r\n            // ================================================================\r\n            const bookmarkSelectors = [\r\n                'button[data-testid=\"bookmark\"]',\r\n                '[data-testid=\"bookmark\"]',\r\n                '[aria-label=\"Bookmark\"]',\r\n                'svg[aria-label*=\"Bookmark\"]',\r\n                'button:has-text(\"Bookmark\")'\r\n            ];\r\n\r\n            const bookmarkResult = await this.humanInteraction.findWithFallback(bookmarkSelectors, { visible: true, timeout: 5000 });\r\n\r\n            if (!bookmarkResult) {\r\n                this.log('[Bookmark]  Could not find bookmark button with any selector');\r\n                return;\r\n            }\r\n\r\n            const bm = bookmarkResult.element;\r\n            const selectedSelector = bookmarkResult.selector;\r\n\r\n            // Check if already bookmarked\r\n            const removeBookmarkSelectors = [\r\n                'button[data-testid=\"removeBookmark\"]',\r\n                '[data-testid=\"removeBookmark\"]',\r\n                '[aria-label=\"Remove Bookmark\"]',\r\n                '[aria-label=\"Bookmark saved\"]'\r\n            ];\r\n\r\n            const removeResult = await this.humanInteraction.findWithFallback(removeBookmarkSelectors, { visible: true, timeout: 1000 });\r\n            if (removeResult) {\r\n                this.log(`[Skip] Tweet ALREADY bookmarked (found: ${removeResult.selector})`);\r\n                return;\r\n            }\r\n\r\n            // ================================================================\r\n            // PRE-CLICK VERIFICATION\r\n            // ================================================================\r\n\r\n            // Wait for element to be stable\r\n            let stableCount = 0;\r\n            const maxStableAttempts = 10;\r\n            let lastBoundingBox = null;\r\n\r\n            while (stableCount < 3 && stableCount < maxStableAttempts) {\r\n                try {\r\n                    const bbox = await bm.boundingBox();\r\n                    if (bbox) {\r\n                        if (lastBoundingBox) {\r\n                            const dx = Math.abs(bbox.x - lastBoundingBox.x);\r\n                            const dy = Math.abs(bbox.y - lastBoundingBox.y);\r\n                            if (dx < 3 && dy < 3) {\r\n                                stableCount++;\r\n                            } else {\r\n                                stableCount = 0;\r\n                            }\r\n                        }\r\n                        lastBoundingBox = bbox;\r\n                    }\r\n                } catch { }\r\n\r\n                if (stableCount < 3) {\r\n                    await this.page.waitForTimeout(100);\r\n                    stableCount++;\r\n                }\r\n            }\r\n\r\n            // Verify element is actionable (not covered by overlay)\r\n            const isActionable = await this.isElementActionable(bm);\r\n            if (!isActionable) {\r\n                this.log('[Bookmark]  Element may be covered, trying scroll adjustment...');\r\n                try {\r\n                    await bm.scrollIntoViewIfNeeded();\r\n                    await this.page.waitForTimeout(500);\r\n                } catch { }\r\n            }\r\n\r\n            // ================================================================\r\n            // EXECUTE CLICK\r\n            // ================================================================\r\n            this.log(`[Action]  Bookmark (selector: ${selectedSelector})`);\r\n\r\n            // Try humanClick first, then fallback to native\r\n            try {\r\n                await this.humanClick(bm, 'Bookmark Button');\r\n            } catch (e) {\r\n                this.log(`[Bookmark] humanClick failed: ${e.message}, using native click...`);\r\n                try {\r\n                    await bm.click({ timeout: TWITTER_TIMEOUTS.ELEMENT_CLICKABLE });\r\n                } catch (e2) {\r\n                    this.log(`[Bookmark] Native click failed: ${e2.message}`);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // ================================================================\r\n            // POST-CLICK VERIFICATION & TRACKING\r\n            // ================================================================\r\n            await this.page.waitForTimeout(mathUtils.randomInRange(1000, 2000));\r\n\r\n            // Check if bookmark was registered\r\n            let bookmarkRegistered = false;\r\n            for (const selector of removeBookmarkSelectors) {\r\n                try {\r\n                    const el = this.page.locator(selector).first();\r\n                    if (await el.isVisible().catch(() => false)) {\r\n                        bookmarkRegistered = true;\r\n                        break;\r\n                    }\r\n                } catch { }\r\n            }\r\n\r\n            if (bookmarkRegistered) {\r\n                this.log(`[Bookmark]  Successfully bookmarked tweet`);\r\n\r\n                if (this.engagementTracker.record('bookmarks')) {\r\n                    const progress = this.engagementTracker.getProgress('bookmarks');\r\n                    this.log(`[Engagement] ${progress} Bookmarks saved`);\r\n                }\r\n            } else {\r\n                this.log(`[Bookmark]  Bookmark may not have registered`);\r\n            }\r\n\r\n            // Return to home page to continue main loop\r\n            await this.navigateHome();\r\n            await this.page.waitForTimeout(mathUtils.randomInRange(1500, 3000));\r\n\r\n        } catch (error) {\r\n            this.log(`[Bookmark]  Error: ${error.message}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle AI Quote Tweet decision and execution\r\n     * Flow: Probability check  Generate quote  Click Retweet  Select Quote  Type  Post\r\n      */\r\n    async handleAIQuote(tweetText, username, options = {}) {\r\n        const { url = '' } = options;\r\n\r\n        // ================================================================\r\n        // Check if this is a pre-validated quote from _diveTweetWithAI\r\n        // ================================================================\r\n        if (options.action === 'quote') {\r\n            this.log(`[AI-Quote] Pre-validated quote - proceeding with generation`);\r\n        } else {\r\n            this.log(`[AI-Quote] Analyzing tweet from @${username}...`);\r\n        }\r\n        this.log(`[AI-Quote] Tweet URL: ${url}`);\r\n\r\n        // ================================================================\r\n        // NOTE: Probability check was done by the caller (handleAIEngage)\r\n        // Proceed directly to sentiment analysis\r\n        // ================================================================\r\n\r\n        // ================================================================\r\n        // STEP 1: Sentiment analysis (skip negative content)\r\n        // ================================================================\r\n        this.log(`[Sentiment] Analyzing tweet sentiment...`);\r\n        const sentimentResult = sentimentService.analyze(tweetText);\r\n\r\n        // Log basic sentiment (backward compatible)\r\n        this.log(`[SentimentGuard] ${sentimentResult.isNegative ? ' NEGATIVE' : ' Neutral/Positive'} content (score: ${sentimentResult.score.toFixed(2)})`);\r\n\r\n        // Log advanced dimensions\r\n        this.log(`[Sentiment] Dimensions - Valence: ${sentimentResult.dimensions.valence.valence.toFixed(2)}, ` +\r\n            `Arousal: ${sentimentResult.dimensions.arousal.arousal.toFixed(2)}, ` +\r\n            `Dominance: ${sentimentResult.dimensions.dominance.dominance.toFixed(2)}, ` +\r\n            `Sarcasm: ${sentimentResult.dimensions.sarcasm.sarcasm.toFixed(2)}`);\r\n\r\n        if (sentimentResult.isNegative) {\r\n            this.log(`[AI-Quote] Skipped (negative sentiment)`);\r\n            return;\r\n        }\r\n\r\n        // Check advanced risk factors\r\n        if (sentimentResult.composite.riskLevel === 'high') {\r\n            this.log(`[AI-Quote] Skipped (high risk: ${sentimentResult.composite.conversationType})`);\r\n            return;\r\n        }\r\n\r\n        // ================================================================\r\n        // STEP 2: Engagement limits check\r\n        // ================================================================\r\n        if (!this.engagementTracker.canPerform('quotes')) {\r\n            this.log(`[AI-Quote] Skipped (engagement limit reached)`);\r\n            return;\r\n        }\r\n\r\n        // ================================================================\r\n        // STEP 3: Extract context (replies) for better AI quotes\r\n        // ================================================================\r\n        this.log(`[AI-Context] Loading replies for quote context...`);\r\n        const enhancedContext = await this.contextEngine.extractEnhancedContext(\r\n            this.page,\r\n            url,\r\n            tweetText,\r\n            username\r\n        );\r\n\r\n        this.log(`[AI-Context] Enhanced: sentiment=${enhancedContext.sentiment?.overall}, tone=${enhancedContext.tone?.primary}, ${enhancedContext.replies.length} replies`);\r\n\r\n        // ================================================================\r\n        // STEP 5: Generate AI quote\r\n        // ================================================================\r\n        this.log(`[AI-Quote] Generating quote tweet...`);\r\n\r\n        const quoteResult = await this.quoteEngine.generateQuote(tweetText, username, {\r\n            url,\r\n            sentiment: sentimentResult.composite?.engagementStyle || 'neutral',\r\n            tone: sentimentResult.composite?.conversationType || 'neutral',\r\n            engagement: 'low',\r\n            replies: enhancedContext.replies\r\n        });\r\n\r\n        if (!quoteResult.success || !quoteResult.quote) {\r\n            const reason = quoteResult.reason || 'unknown';\r\n            this.log(`[AI-Quote]  Failed to generate quote (reason: ${reason})`);\r\n            return;\r\n        }\r\n\r\n        // ================================================================\r\n        // STEP 5: Display AI result BEFORE executing\r\n        // ================================================================\r\n        this.log(`[AI-Quote] AI QUOTE: \"${quoteResult.quote}\"`);\r\n\r\n        // Execute quote with human-like behavior (uses 4 methods randomly)\r\n        const result = await this.quoteEngine.executeQuote(this.page, quoteResult.quote);\r\n\r\n        if (result.success) {\r\n            if (this.engagementTracker.record('quotes')) {\r\n                const progress = this.engagementTracker.getProgress('quotes');\r\n                this.log(`[Engagement] ${progress} Quotes posted`);\r\n            }\r\n            this.log(`[AI-Quote] Quote tweet posted successfully via ${result.method}`);\r\n\r\n            // Additional verification: ensure composer is closed before proceeding\r\n            this.log(`[AI-Quote] Verifying quote completion...`);\r\n            let composerClosed = false;\r\n            for (let i = 0; i < 5; i++) {\r\n                try {\r\n                    const composerVisible = await this.page.locator('[data-testid=\"tweetTextarea_0\"]').isVisible().catch(() => false);\r\n                    if (!composerVisible) {\r\n                        composerClosed = true;\r\n                        this.log(`[AI-Quote] Composer verified closed`);\r\n                        break;\r\n                    }\r\n                    await this.page.waitForTimeout(1000);\r\n                } catch (e) {\r\n                    composerClosed = true;\r\n                    this.log(`[AI-Quote] Composer verification error (treating as closed): ${e.message}`);\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!composerClosed) {\r\n                this.log(`[AI-Quote]  Composer may still be open, attempting to close...`);\r\n                try {\r\n                    await this.page.keyboard.press('Escape');\r\n                    await this.page.waitForTimeout(500);\r\n                } catch (e) { }\r\n            }\r\n        } else {\r\n            this.log(`[AI-Quote] Quote tweet failed: ${result.reason} (method: ${result.method})`);\r\n        }\r\n    }\r\n\r\n    /**\r\n      * Get AI stats\r\n      */\r\n    getAIStats() {\r\n        const actionStats = {};\r\n        if (this.actions) {\r\n            for (const [name, action] of Object.entries(this.actions)) {\r\n                actionStats[name] = action.getStats();\r\n            }\r\n        }\r\n\r\n        return {\r\n            ...this.aiStats,\r\n            successRate: this.aiStats.attempts > 0\r\n                ? ((this.aiStats.replies / this.aiStats.attempts) * 100).toFixed(1) + '%'\r\n                : '0%',\r\n            actions: actionStats\r\n        };\r\n    }\r\n\r\n    /**\r\n          * Get action stats\r\n          */\r\n    getActionStats() {\r\n        if (this.actionRunner) {\r\n            return this.actionRunner.getStats();\r\n        }\r\n        const stats = {};\r\n        if (this.actions) {\r\n            for (const [name, action] of Object.entries(this.actions)) {\r\n                stats[name] = action.getStats();\r\n            }\r\n        }\r\n        return stats;\r\n    }\r\n\r\n    /**\r\n      * Perform health check on browser connection\r\n      * Returns health status and attempts recovery if needed\r\n      */\r\n    async performHealthCheck() {\r\n        try {\r\n            // Get browser context\r\n            const context = this.page.context();\r\n            const browser = context.browser();\r\n\r\n            if (!browser || !browser.isConnected()) {\r\n                this.logWarn('[Health] Browser disconnected, attempting recovery...');\r\n                return { healthy: false, reason: 'browser_disconnected' };\r\n            }\r\n\r\n            // Check page responsiveness\r\n            const pageHealth = await this.page.evaluate(() => {\r\n                return {\r\n                    readyState: document.readyState,\r\n                    title: document.title,\r\n                    hasBody: !!document.body\r\n                };\r\n            }).catch(() => ({\r\n                readyState: 'error',\r\n                title: '',\r\n                hasBody: false,\r\n                error: 'Page evaluation failed'\r\n            }));\r\n\r\n            if (pageHealth.readyState !== 'complete' && pageHealth.readyState !== 'interactive') {\r\n                this.logWarn('[Health] Page not fully loaded, attempting recovery...');\r\n                return { healthy: false, reason: 'page_not_ready' };\r\n            }\r\n\r\n            // Check if still on expected domain\r\n            const currentUrl = this.page.url();\r\n            if (!currentUrl.includes('x.com') && !currentUrl.includes('twitter.com')) {\r\n                this.logWarn(`[Health] Unexpected URL: ${currentUrl}, navigating home...`);\r\n                await this.navigateHome();\r\n                return { healthy: false, reason: 'unexpected_url' };\r\n            }\r\n\r\n            return { healthy: true, pageState: pageHealth.readyState };\r\n\r\n        } catch (error) {\r\n            this.logWarn(`[Health] Health check failed: ${error.message}`);\r\n            return { healthy: false, reason: error.message };\r\n        }\r\n    }\r\n\r\n    /**\r\n      * Log current engagement status\r\n      */\r\n    getActionStats() {\r\n        if (this.actionRunner) {\r\n            return this.actionRunner.getStats();\r\n        }\r\n        const stats = {};\r\n        if (this.actions) {\r\n            for (const [name, action] of Object.entries(this.actions)) {\r\n                stats[name] = action.getStats();\r\n            }\r\n        }\r\n        return stats;\r\n    }\r\n    //Get engagement stats\r\n    getEngagementStats() {\r\n        return {\r\n            tracker: this.engagementTracker.getStatus(),\r\n            summary: this.engagementTracker.getSummary(),\r\n            usageRate: this.engagementTracker.getUsageRate()\r\n        };\r\n    }\r\n    //Log current engagement status      \r\n    logEngagementStatus() {\r\n        const status = this.engagementTracker.getStatus();\r\n        for (const [action, data] of Object.entries(status)) {\r\n            const emoji = data.remaining === 0 ? '' :\r\n                parseFloat(data.percentage) >= 80 ? '' : '';\r\n            this.engagementLogger?.info(`[Engagement] ${emoji} ${action}: ${data.current}/${data.limit} (${data.percentage} used)`);\r\n        }\r\n    }\r\n\r\n    //Flush all buffered loggers (call during cleanup)\r\n      \r\n    async flushLogs() {\r\n        this.log('[Logger] Flushing buffered logs...');\r\n        await Promise.all([\r\n            this.queueLogger.shutdown(),\r\n            this.engagementLogger.shutdown()\r\n        ]);\r\n        this.log('[Logger] All buffered logs flushed');\r\n    }\r\n    //Finalize engagement logger entry   \r\n}\r\nexport default AITwitterAgent;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\My Script\\auto-ai\\utils\\async-queue.js","messages":[{"ruleId":"no-prototype-builtins","severity":2,"message":"Do not access Object.prototype method 'hasOwnProperty' from target object.","line":332,"column":37,"messageId":"prototypeBuildIn","endLine":332,"endColumn":51,"suggestions":[{"messageId":"callObjectPrototype","data":{"prop":"hasOwnProperty"},"fix":{"range":[11050,11089],"text":"Object.prototype.hasOwnProperty.call(this.engagementCounters, "},"desc":"Call Object.prototype.hasOwnProperty explicitly."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Async Queue Manager for AI Operations\r\n * Handles race conditions and provides timeout/fallback mechanisms\r\n * @module utils/async-queue\r\n */\r\n\r\nimport { createLogger } from './logger.js';\r\nimport { TWITTER_TIMEOUTS } from '../constants/twitter-timeouts.js';\r\n\r\nconst logger = createLogger('async-queue.js');\r\n\r\nexport class AsyncQueue {\r\n    constructor(options = {}) {\r\n        this.maxConcurrent = options.maxConcurrent ?? 3;\r\n        this.maxQueueSize = options.maxQueueSize ?? 50;\r\n        this.defaultTimeout = options.defaultTimeout ?? TWITTER_TIMEOUTS.QUEUE_ITEM_TIMEOUT;\r\n\r\n        this.queue = [];\r\n        this.active = new Map();\r\n        this.processingPromise = null; // Use promise chain instead of boolean flag\r\n        this.processing = false; // Boolean flag for getStatus() compatibility\r\n        this.processedCount = 0;\r\n        this.failedCount = 0;\r\n        this.timedOutCount = 0;\r\n\r\n        this.stats = {\r\n            totalAdded: 0,\r\n            totalCompleted: 0,\r\n            totalFailed: 0,\r\n            totalTimedOut: 0,\r\n            averageWaitTime: 0,\r\n            averageProcessingTime: 0\r\n        };\r\n\r\n        logger.info(`[AsyncQueue] Initialized (maxConcurrent: ${this.maxConcurrent}, maxQueueSize: ${this.maxQueueSize}, defaultTimeout: ${this.defaultTimeout}ms)`);\r\n    }\r\n\r\n    /**\r\n     * Add a task to the queue\r\n     * @param {Function} taskFn - Async function to execute\r\n     * @param {object} options - Task options\r\n     * @returns {Promise} Result of the task\r\n     */\r\n    async add(taskFn, options = {}) {\r\n        const id = `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n        const timeout = options.timeout ?? this.defaultTimeout;\r\n        const priority = options.priority ?? 0;\r\n        const taskName = options.name || 'unnamed';\r\n\r\n        // Check queue size with atomic access\r\n        const currentQueueSize = this.queue.length + this.active.size;\r\n        if (currentQueueSize >= this.maxQueueSize) {\r\n            logger.warn(`[AsyncQueue] Queue full, rejecting task: ${taskName} (current: ${currentQueueSize}, max: ${this.maxQueueSize})`);\r\n            return { success: false, reason: 'queue_full', taskName: id };\r\n        }\r\n\r\n        // Create promise that will be resolved/rejected when task completes\r\n        const taskPromise = new Promise((resolve, reject) => {\r\n            const startTime = Date.now();\r\n            this.queue.push({\r\n                id,\r\n                taskFn,\r\n                timeout,  // Ensure timeout is properly stored\r\n                priority,\r\n                taskName,\r\n                resolve,\r\n                reject,\r\n                enqueueTime: startTime\r\n            });\r\n            this.stats.totalAdded++;\r\n\r\n            // Trigger queue processing with promise chaining\r\n            this._processQueue().catch(err => {\r\n                logger.error(`[AsyncQueue] Queue processing error: ${err.message}`);\r\n            });\r\n        });\r\n\r\n        return taskPromise;\r\n    }\r\n\r\n    /**\r\n     * Process items in the queue using promise chaining\r\n     * This prevents race conditions by ensuring only one processing loop runs at a time\r\n     */\r\n    async _processQueue() {\r\n        // If already processing, wait for it to complete\r\n        if (this.processingPromise) {\r\n            return this.processingPromise;\r\n        }\r\n\r\n        // Create new processing promise\r\n        this.processingPromise = this._processItems().finally(() => {\r\n            this.processingPromise = null;\r\n            this.processing = false;\r\n        });\r\n\r\n        this.processing = true;\r\n        return this.processingPromise;\r\n    }\r\n\r\n    /**\r\n     * Actual processing logic - processes items from the queue\r\n     */\r\n    async _processItems() {\r\n        while (this.queue.length > 0 && this.active.size < this.maxConcurrent) {\r\n            // Sort by priority (higher priority first)\r\n            this.queue.sort((a, b) => b.priority - a.priority);\r\n\r\n            const item = this.queue.shift();\r\n            const startTime = Date.now();\r\n\r\n            logger.debug(`[AsyncQueue] Starting task: ${item.taskName} (queue: ${this.queue.length}, active: ${this.active.size}/${this.maxConcurrent})`);\r\n\r\n            // Track active task\r\n            this.active.set(item.id, {\r\n                ...item,\r\n                startTime\r\n            });\r\n\r\n            // Process task with timeout\r\n            let timeoutId;\r\n            const timeoutPromise = new Promise((_, reject) => {\r\n                timeoutId = setTimeout(() => {\r\n                    logger.warn(`[AsyncQueue]  Task timeout reached: ${item.timeout}ms for ${item.taskName}`);\r\n                    reject(new Error('timeout'));\r\n                }, item.timeout);\r\n            });\r\n\r\n            try {\r\n                const result = await Promise.race([\r\n                    this._executeTask(item),\r\n                    timeoutPromise\r\n                ]);\r\n                \r\n                // Clear timeout since task completed successfully\r\n                clearTimeout(timeoutId);\r\n\r\n                const processingTime = Date.now() - startTime;\r\n                this.stats.totalCompleted++;\r\n                this._updateAverageStats('processing', processingTime);\r\n\r\n                logger.info(`[AsyncQueue]  Completed task: ${item.taskName} in ${processingTime}ms`);\r\n                item.resolve({ success: true, result, taskName: item.taskName, processingTime });\r\n\r\n            } catch (error) {\r\n                const isTimeout = error.message === 'timeout';\r\n                const processingTime = Date.now() - startTime;\r\n\r\n                if (isTimeout) {\r\n                    this.stats.totalTimedOut++;\r\n                    this.timedOutCount++;\r\n                    logger.warn(`[AsyncQueue]  Task timed out: ${item.taskName} after ${processingTime}ms`);\r\n                } else {\r\n                    this.stats.totalFailed++;\r\n                    this.failedCount++;\r\n                    logger.error(`[AsyncQueue]  Task failed: ${item.taskName} - ${error.message}`);\r\n                }\r\n\r\n                item.resolve({\r\n                    success: false,\r\n                    reason: isTimeout ? 'timeout' : 'error',\r\n                    error: error.message,\r\n                    taskName: item.taskName,\r\n                    processingTime\r\n                });\r\n\r\n            } finally {\r\n                this.active.delete(item.id);\r\n                this.processedCount++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a task with timeout\r\n     */\r\n    async _executeTask(item) {\r\n        return await item.taskFn();\r\n    }\r\n\r\n    /**\r\n     * Create a timeout promise using the item's timeout value\r\n     */\r\n    _createTimeout(item) {\r\n        return new Promise((_, reject) => {\r\n            setTimeout(() => {\r\n                logger.warn(`[AsyncQueue] Task timeout reached: ${item.timeout}ms for ${item.taskName}`);\r\n                reject(new Error('timeout'));\r\n            }, item.timeout);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Update average statistics\r\n     */\r\n    _updateAverageStats(type, value) {\r\n        const count = this.stats.totalCompleted + this.stats.totalFailed;\r\n        if (count <= 1) {\r\n            if (type === 'processing') {\r\n                this.stats.averageProcessingTime = value;\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (type === 'processing') {\r\n            const total = this.stats.averageProcessingTime * (count - 1) + value;\r\n            this.stats.averageProcessingTime = total / count;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get queue status\r\n     */\r\n    getStatus() {\r\n        return {\r\n            queueLength: this.queue.length,\r\n            activeCount: this.active.size,\r\n            maxConcurrent: this.maxConcurrent,\r\n            isProcessing: this.processing,\r\n            processed: this.processedCount,\r\n            failed: this.failedCount,\r\n            timedOut: this.timedOutCount\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get detailed statistics\r\n     */\r\n    getStats() {\r\n        return {\r\n            ...this.stats,\r\n            queueStatus: this.getStatus(),\r\n            utilizationPercent: this.active.size > 0\r\n                ? Math.round((this.active.size / this.maxConcurrent) * 100)\r\n                : 0\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Clear the queue\r\n     */\r\n    clear() {\r\n        const dropped = this.queue.length;\r\n        this.queue = [];\r\n\r\n        logger.info(`[AsyncQueue] Cleared queue (dropped ${dropped} tasks)`);\r\n\r\n        return { dropped };\r\n    }\r\n\r\n    /**\r\n     * Check if queue is healthy\r\n     */\r\n    isHealthy() {\r\n        return this.failedCount < 5 && this.timedOutCount < 10;\r\n    }\r\n\r\n    /**\r\n     * Alias for isHealthy() for external API compatibility\r\n     */\r\n    isQueueHealthy() {\r\n        return this.isHealthy();\r\n    }\r\n\r\n    /**\r\n     * Get health status\r\n     */\r\n    getHealth() {\r\n        return {\r\n            healthy: this.isHealthy(),\r\n            failedCount: this.failedCount,\r\n            timedOutCount: this.timedOutCount,\r\n            queueLength: this.queue.length\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Dive Queue - Specialized queue for tweet dive operations\r\n * Extends AsyncQueue with dive-specific features\r\n */\r\nexport class DiveQueue extends AsyncQueue {\r\n    constructor(options = {}) {\r\n        // Use passed timeout or default, but ensure it's reasonable\r\n        const timeout = options.defaultTimeout ?? TWITTER_TIMEOUTS.DIVE_TIMEOUT;\r\n        const finalTimeout = Math.max(10000, Math.min(timeout, 300000)); // Clamp between 10s and 5min\r\n\r\n        super({\r\n            maxConcurrent: 1,  // Force sequential processing - only 1 dive at a time\r\n            maxQueueSize: options.maxQueueSize ?? 30,\r\n            defaultTimeout: finalTimeout\r\n        });\r\n\r\n        this.fallbackEngagement = options.fallbackEngagement ?? false;\r\n        this.quickMode = false;\r\n\r\n        // Engagement tracking\r\n        this.engagementLimits = {\r\n            replies: options.replies ?? 3,\r\n            retweets: options.retweets ?? 1,\r\n            quotes: options.quotes ?? 1,\r\n            likes: options.likes ?? 5,\r\n            follows: options.follows ?? 2,\r\n            bookmarks: options.bookmarks ?? 2\r\n        };\r\n\r\n        this.engagementCounters = {\r\n            replies: 0,\r\n            retweets: 0,\r\n            quotes: 0,\r\n            likes: 0,\r\n            follows: 0,\r\n            bookmarks: 0\r\n        };\r\n\r\n        logger.info(`[DiveQueue] Initialized with engagement limits: ${JSON.stringify(this.engagementLimits)}`);\r\n    }\r\n\r\n    /**\r\n     * Check if engagement limit allows action (synchronous - optimized for performance)\r\n     */\r\n    canEngage(action) {\r\n        const limit = this.engagementLimits[action] ?? Infinity;\r\n        const current = this.engagementCounters[action] ?? 0;\r\n        return current < limit;\r\n    }\r\n\r\n    /**\r\n     * Record engagement action (synchronous - optimized for performance)\r\n     */\r\n    recordEngagement(action) {\r\n        if (this.engagementCounters.hasOwnProperty(action)) {\r\n            const limit = this.engagementLimits[action] ?? Infinity;\r\n            const current = this.engagementCounters[action];\r\n\r\n            if (current < limit) {\r\n                this.engagementCounters[action]++;\r\n                logger.debug(`[DiveQueue]  Engagement recorded: ${action} (${current + 1}/${limit})`);\r\n                return true;\r\n            } else {\r\n                logger.debug(`[DiveQueue]  Engagement limit reached: ${action} (${current}/${limit})`);\r\n                return false;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get engagement progress (synchronous - optimized for performance)\r\n     */\r\n    getEngagementProgress() {\r\n        const progress = {};\r\n        for (const action of Object.keys(this.engagementLimits)) {\r\n            progress[action] = {\r\n                current: this.engagementCounters[action],\r\n                limit: this.engagementLimits[action],\r\n                remaining: Math.max(0, this.engagementLimits[action] - this.engagementCounters[action]),\r\n                percentUsed: Math.round((this.engagementCounters[action] / this.engagementLimits[action]) * 100)\r\n            };\r\n        }\r\n        return progress;\r\n    }\r\n\r\n    /**\r\n     * Update engagement limits at runtime\r\n     */\r\n    updateEngagementLimits(newLimits) {\r\n        this.engagementLimits = { ...this.engagementLimits, ...newLimits };\r\n        logger.info(`[DiveQueue] Updated engagement limits: ${JSON.stringify(this.engagementLimits)}`);\r\n    }\r\n\r\n    /**\r\n      * Add dive task with fallback support\r\n      */\r\n    async addDive(diveFn, fallbackFn, options = {}) {\r\n        const taskName = options.taskName || `dive_${Date.now()}`;\r\n        const timeout = options.timeout ?? this.defaultTimeout;\r\n\r\n        logger.debug(`[DiveQueue] addDive called: ${taskName}, timeout: ${timeout}ms`);\r\n\r\n        return this.add(async () => {\r\n            try {\r\n                logger.debug(`[DiveQueue] Starting dive function: ${taskName}`);\r\n\r\n                // Create dive promise with proper timeout closure\r\n                const divePromise = diveFn();\r\n\r\n                // Create timeout promise with correct closure variables\r\n                let timeoutId;\r\n                const timeoutPromise = new Promise((_, reject) => {\r\n                    timeoutId = setTimeout(() => {\r\n                        logger.warn(`[DiveQueue] Dive timeout reached: ${timeout}ms for ${taskName}`);\r\n                        reject(new Error('dive_timeout'));\r\n                    }, timeout);\r\n                });\r\n\r\n                try {\r\n                    const result = await Promise.race([divePromise, timeoutPromise]);\r\n                    clearTimeout(timeoutId); // Clear timeout on success\r\n\r\n                    logger.debug(`[DiveQueue] Dive function completed: ${taskName}`);\r\n                    return {\r\n                        success: true,\r\n                        result,\r\n                        fallbackUsed: false,\r\n                        taskName\r\n                    };\r\n                } catch (error) {\r\n                    clearTimeout(timeoutId); // Clear timeout on error\r\n                    throw error;\r\n                }\r\n\r\n            } catch (error) {\r\n                logger.warn(`[DiveQueue] Dive failed: ${error.message}, checking fallback...`);\r\n\r\n                // Check if we should use fallback\r\n                if (this.fallbackEngagement && fallbackFn) {\r\n                    try {\r\n                        const fallbackResult = await fallbackFn();\r\n                        return {\r\n                            success: false,\r\n                            fallbackUsed: true,\r\n                            fallbackResult,\r\n                            error: error.message,\r\n                            taskName\r\n                        };\r\n                    } catch (fallbackError) {\r\n                        logger.error(`[DiveQueue] Fallback also failed: ${fallbackError.message}`);\r\n                        return {\r\n                            success: false,\r\n                            fallbackUsed: false,\r\n                            error: `${error.message}; fallback: ${fallbackError.message}`,\r\n                            taskName\r\n                        };\r\n                    }\r\n                }\r\n\r\n                return {\r\n                    success: false,\r\n                    fallbackUsed: false,\r\n                    error: error.message,\r\n                    taskName\r\n                };\r\n            }\r\n        }, {\r\n            ...options,\r\n            name: taskName,\r\n            timeout: timeout  // Explicitly pass timeout to base add method\r\n        });\r\n    }\r\n\r\n    /**\r\n      * Enable quick mode (reduced timeouts for faster fallback)\r\n      */\r\n    enableQuickMode() {\r\n        this.quickMode = true;\r\n        this.defaultTimeout = 15000;  // Still faster than normal 20-30s, but enough for AI\r\n        logger.info(`[DiveQueue] Quick mode enabled (timeout: ${this.defaultTimeout}ms)`);\r\n    }\r\n\r\n    /**\r\n      * Disable quick mode\r\n      */\r\n    disableQuickMode() {\r\n        this.quickMode = false;\r\n        this.defaultTimeout = 20000;  // Normal timeout\r\n        logger.info(`[DiveQueue] Quick mode disabled (timeout: ${this.defaultTimeout}ms)`);\r\n    }\r\n\r\n    /**\r\n     * Get comprehensive queue status including engagement\r\n     */\r\n    getFullStatus() {\r\n        return {\r\n            queue: this.getStatus(),\r\n            engagement: this.getEngagementProgress(),\r\n            quickMode: this.quickMode,\r\n            health: this.getHealth()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Reset engagement counters\r\n     */\r\n    resetEngagement() {\r\n        for (const key of Object.keys(this.engagementCounters)) {\r\n            this.engagementCounters[key] = 0;\r\n        }\r\n        logger.info(`[DiveQueue] Engagement counters reset`);\r\n    }\r\n\r\n}\r\n\r\nexport default AsyncQueue;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\My Script\\auto-ai\\utils\\engagement-limits.js","messages":[{"ruleId":"no-prototype-builtins","severity":2,"message":"Do not access Object.prototype method 'hasOwnProperty' from target object.","line":92,"column":29,"messageId":"prototypeBuildIn","endLine":92,"endColumn":43,"suggestions":[{"messageId":"callObjectPrototype","data":{"prop":"hasOwnProperty"},"fix":{"range":[2507,2533],"text":"Object.prototype.hasOwnProperty.call(this.stats, "},"desc":"Call Object.prototype.hasOwnProperty explicitly."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Engagement Limits Module\r\n * Tracks and enforces per-session engagement limits\r\n * to prevent over-engagement and rate limiting.\r\n * \r\n * @module utils/engagement-limits\r\n */\r\n\r\nconst DEFAULT_LIMITS = {\r\n    replies: 3,\r\n    retweets: 1,\r\n    quotes: 1,\r\n    likes: 5,\r\n    follows: 2,\r\n    bookmarks: 2\r\n};\r\n\r\nconst CRITICAL_THRESHOLDS = {\r\n    replies: 0.8,\r\n    retweets: 0.8,\r\n    quotes: 0.8,\r\n    likes: 0.8,\r\n    follows: 0.8,\r\n    bookmarks: 0.8\r\n};\r\n\r\nfunction createEngagementTracker(limits = DEFAULT_LIMITS) {\r\n    const stats = {\r\n        replies: 0,\r\n        retweets: 0,\r\n        quotes: 0,\r\n        likes: 0,\r\n        follows: 0,\r\n        bookmarks: 0\r\n    };\r\n\r\n    return {\r\n        limits: { ...limits },\r\n        stats: { ...stats },\r\n        history: [],\r\n        \r\n        canPerform(action) {\r\n            const current = this.stats[action] || 0;\r\n            const limit = this.limits[action] || Infinity;\r\n            return current < limit;\r\n        },\r\n        \r\n        getRemaining(action) {\r\n            const current = this.stats[action] || 0;\r\n            const limit = this.limits[action] || Infinity;\r\n            return Math.max(0, limit - current);\r\n        },\r\n        \r\n        getUsage(action) {\r\n            const current = this.stats[action] || 0;\r\n            const limit = this.limits[action] || Infinity;\r\n            if (limit === 0) return 0;\r\n            return current / limit;\r\n        },\r\n        \r\n        getProgress(action) {\r\n            const current = this.stats[action] || 0;\r\n            const limit = this.limits[action] || Infinity;\r\n            if (limit === Infinity) return `${current} used`;\r\n            return `${current}/${limit}`;\r\n        },\r\n\r\n        getProgressPercent(action) {\r\n            return (this.getUsage(action) * 100).toFixed(1) + '%';\r\n        },\r\n        \r\n        isNearLimit(action, threshold = 0.8) {\r\n            return this.getUsage(action) >= threshold;\r\n        },\r\n        \r\n        isExhausted(action) {\r\n            return !this.canPerform(action);\r\n        },\r\n        \r\n        isAnyExhausted() {\r\n            return Object.keys(this.limits).some(action => !this.canPerform(action));\r\n        },\r\n        \r\n        hasRemainingCapacity() {\r\n            return Object.values(this.stats).some((count, idx) => {\r\n                const action = Object.keys(this.stats)[idx];\r\n                return this.canPerform(action);\r\n            });\r\n        },\r\n        \r\n        record(action) {\r\n            if (!this.stats.hasOwnProperty(action)) {\r\n                console.warn(`[engagement-limits.js] Unknown action: ${action}`);\r\n                return false;\r\n            }\r\n            \r\n            if (!this.canPerform(action)) {\r\n                console.log(`[engagement-limits.js] Limit reached for ${action} (${this.stats[action]}/${this.limits[action]})`);\r\n                return false;\r\n            }\r\n            \r\n            this.stats[action]++;\r\n            \r\n            this.history.push({\r\n                action,\r\n                timestamp: Date.now(),\r\n                count: this.stats[action],\r\n                limit: this.limits[action]\r\n            });\r\n            \r\n            return true;\r\n        },\r\n        \r\n        recordIfAllowed(action) {\r\n            return this.record(action);\r\n        },\r\n        \r\n        decrement(action) {\r\n            if (this.stats[action] > 0) {\r\n                this.stats[action]--;\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n        \r\n        getStatus() {\r\n            const status = {};\r\n            for (const action of Object.keys(this.limits)) {\r\n                const current = this.stats[action] || 0;\r\n                const limit = this.limits[action] || Infinity;\r\n                status[action] = {\r\n                    current,\r\n                    limit,\r\n                    remaining: Math.max(0, limit - current),\r\n                    percentage: limit > 0 ? ((current / limit) * 100).toFixed(1) + '%' : 'N/A'\r\n                };\r\n            }\r\n            return status;\r\n        },\r\n        \r\n        getSummary() {\r\n            const summary = [];\r\n            for (const action of Object.keys(this.limits)) {\r\n                const current = this.stats[action] || 0;\r\n                const limit = this.limits[action] || Infinity;\r\n                if (limit !== Infinity) {\r\n                    summary.push(`${action}: ${current}/${limit}`);\r\n                }\r\n            }\r\n            return summary.join(', ');\r\n        },\r\n        \r\n        getUsageRate() {\r\n            const totalUsed = Object.values(this.stats).reduce((a, b) => a + b, 0);\r\n            const totalLimit = Object.values(this.limits).reduce((a, b) => a + (b || 0), 0);\r\n            return {\r\n                used: totalUsed,\r\n                limit: totalLimit,\r\n                percentage: totalLimit > 0 ? ((totalUsed / totalLimit) * 100).toFixed(1) + '%' : 'N/A'\r\n            };\r\n        },\r\n        \r\n        getRecentActions(count = 10) {\r\n            return this.history.slice(-count);\r\n        },\r\n        \r\n        reset() {\r\n            for (const key of Object.keys(this.stats)) {\r\n                this.stats[key] = 0;\r\n            }\r\n            this.history = [];\r\n        },\r\n        \r\n        setLimit(action, limit) {\r\n            if (Object.prototype.hasOwnProperty.call(this.limits, action)) {\r\n                this.limits[action] = limit;\r\n            }\r\n        },\r\n        \r\n        setLimits(newLimits) {\r\n            this.limits = { ...this.limits, ...newLimits };\r\n        }\r\n    };\r\n}\r\n\r\nfunction formatLimitStatus(tracker) {\r\n    const status = tracker.getStatus();\r\n    const lines = ['Engagement Limits Status:'];\r\n    \r\n    for (const [action, data] of Object.entries(status)) {\r\n        const emoji = data.remaining === 0 ? '' : \r\n                      data.percentage >= '80.0%' ? '' : '';\r\n        lines.push(`  ${emoji} ${action}: ${data.current}/${data.limit} (${data.percentage} used)`);\r\n    }\r\n    \r\n    return lines.join('\\n');\r\n}\r\n\r\nfunction shouldSkipAction(action, phase, modifiers) {\r\n    const phaseMod = modifiers[phase]?.[action] || 1.0;\r\n    const randomRoll = Math.random();\r\n    return randomRoll > phaseMod;\r\n}\r\n\r\nfunction getSmartActionProbability(action, tracker, phase, modifiers) {\r\n    const baseMod = modifiers[phase]?.[action] || 1.0;\r\n    const remaining = tracker.getRemaining(action);\r\n    const totalLimit = tracker.limits[action] || 1;\r\n    const scarcityMod = Math.max(0.1, remaining / totalLimit);\r\n    return baseMod * scarcityMod;\r\n}\r\n\r\nexport const engagementLimits = {\r\n    defaults: DEFAULT_LIMITS,\r\n    thresholds: CRITICAL_THRESHOLDS,\r\n    createEngagementTracker,\r\n    formatLimitStatus,\r\n    shouldSkipAction,\r\n    getSmartActionProbability\r\n};\r\n\r\nexport default engagementLimits;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\My Script\\auto-ai\\utils\\free-api-router.js","messages":[{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":226,"column":9,"messageId":"unnecessaryAssignment","endLine":226,"endColumn":20}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Free API Router for OpenRouter\r\n * Handles API key rotation, model cascading fallbacks, and proxy routing\r\n * With: Config Validation, Circuit Breaker, Rate Limit Tracking, Request Deduplication, Model Performance Tracking, Quick Timeout\r\n * @module utils/free-api-router\r\n */\r\n\r\nimport { createLogger } from './logger.js';\r\nimport { createProxyAgent } from './proxy-agent.js';\r\nimport { CircuitBreaker } from './circuit-breaker.js';\r\nimport { RateLimitTracker } from './rate-limit-tracker.js';\r\nimport { RequestDedupe } from './request-dedupe.js';\r\nimport { ModelPerfTracker } from './model-perf-tracker.js';\r\nimport { ConfigValidator } from './config-validator.js';\r\nimport { ApiKeyTimeoutTracker } from './api-key-timeout-tracker.js';\r\n// import { FreeOpenRouterHelper } from './free-openrouter-helper.js';\r\nimport { RouterError, ProxyError, classifyHttpError } from './errors.js';\r\n// import { RateLimitError, ModelError } from './errors.js';\r\n\r\nconst logger = createLogger('free-api-router.js');\r\n\r\nlet sharedHelper = null;\r\n\r\nexport function getSharedHelper() {\r\n  return sharedHelper;\r\n}\r\n\r\nexport function setSharedHelper(helper) {\r\n  sharedHelper = helper;\r\n}\r\n\r\nexport class FreeApiRouter {\r\n  constructor(options = {}) {\r\n    this.config = {\r\n      enabled: options.enabled ?? false,\r\n      apiKeys: options.apiKeys || [],\r\n      models: {\r\n        primary: options.primaryModel || 'anthropic/claude-3.5-sonnet:free',\r\n        fallbacks: options.fallbackModels || []\r\n      },\r\n      proxy: {\r\n        enabled: options.proxyEnabled ?? false,\r\n        fallbackToDirect: options.proxyFallbackToDirect ?? true,\r\n        list: options.proxyList || []\r\n      }\r\n    };\r\n\r\n    this.endpoint = 'https://openrouter.ai/api/v1/chat/completions';\r\n\r\n    this.defaultTimeout = options.timeout || 60000;\r\n    this.quickTimeout = options.quickTimeout || 20000;\r\n\r\n    this.browserId = options.browserId || 'default';\r\n    this.taskId = options.taskId || 'default';\r\n    this.sessionId = `${this.browserId}:${this.taskId}`;\r\n\r\n    this.sessionApiKey = null;\r\n    this.sessionApiKeyIndex = -1;\r\n    this.currentProxyIndex = -1;\r\n\r\n    this.stats = {\r\n      totalRequests: 0,\r\n      successes: 0,\r\n      failures: 0,\r\n      circuitBreaks: 0,\r\n      rateLimitHits: 0,\r\n      dedupeHits: 0,\r\n      quickTimeouts: 0\r\n    };\r\n\r\n    if (this.config.enabled) {\r\n      this._initModules();\r\n      this._selectSessionApiKey();\r\n      this._logInitialization();\r\n    }\r\n  }\r\n\r\n  _hash(str) {\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n      const char = str.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash;\r\n    }\r\n    return Math.abs(hash);\r\n  }\r\n\r\n  _selectSessionApiKey() {\r\n    if (this.config.apiKeys.length === 0) {\r\n      logger.warn('[FreeRouter] No API keys configured');\r\n      return;\r\n    }\r\n\r\n    const sessionKey = `${this.browserId}:${this.taskId}`;\r\n    const hash = this._hash(sessionKey);\r\n    this.sessionApiKeyIndex = hash % this.config.apiKeys.length;\r\n    this.sessionApiKey = this.config.apiKeys[this.sessionApiKeyIndex];\r\n\r\n    logger.info(`[FreeRouter] Session ${this.sessionId} -> API Key ${this.sessionApiKeyIndex + 1}/${this.config.apiKeys.length}`);\r\n  }\r\n\r\n  setTask(browserId, taskId) {\r\n    const oldSessionId = this.sessionId;\r\n    this.browserId = browserId || this.browserId;\r\n    this.taskId = taskId || this.taskId;\r\n    this.sessionId = `${this.browserId}:${this.taskId}`;\r\n\r\n    if (oldSessionId !== this.sessionId) {\r\n      logger.info(`[FreeRouter] Session changed: ${oldSessionId} -> ${this.sessionId}`);\r\n      this._selectSessionApiKey();\r\n    }\r\n  }\r\n\r\n  _initModules() {\r\n    this.circuitBreaker = new CircuitBreaker({\r\n      failureThreshold: 5,\r\n      resetTimeout: 60000,\r\n      halfOpenSuccessThreshold: 1\r\n    });\r\n\r\n    this.rateLimitTracker = new RateLimitTracker({\r\n      cacheDuration: 60000,\r\n      warningThreshold: 0.2\r\n    });\r\n\r\n    this.requestDedupe = new RequestDedupe({\r\n      ttl: 30000,\r\n      maxSize: 1000,\r\n      enabled: true\r\n    });\r\n\r\n    this.modelPerfTracker = new ModelPerfTracker({\r\n      windowSize: 100,\r\n      minSamples: 5\r\n    });\r\n\r\n    this.apiKeyTimeoutTracker = new ApiKeyTimeoutTracker({\r\n      defaultTimeout: this.defaultTimeout,\r\n      quickTimeout: this.quickTimeout,\r\n      slowThreshold: 15000,\r\n      failureThreshold: 3\r\n    });\r\n\r\n    this.configValidator = new ConfigValidator();\r\n  }\r\n\r\n  _logInitialization() {\r\n    logger.info(`[FreeRouter] Initialized for session: ${this.sessionId}`);\r\n    logger.info(`[FreeRouter] API Keys: ${this.config.apiKeys.length}, Selected: ${this.sessionApiKeyIndex + 1}`);\r\n    logger.info(`[FreeRouter] Primary model: ${this.config.models.primary}`);\r\n    logger.info(`[FreeRouter] Fallback models: ${this.config.models.fallbacks.length}`);\r\n    logger.info(`[FreeRouter] Timeout: default=${this.defaultTimeout}ms, quick=${this.quickTimeout}ms`);\r\n\r\n    if (this.config.proxy.enabled) {\r\n      logger.info(`[FreeRouter] Proxy enabled: ${this.config.proxy.list.length} proxies`);\r\n    }\r\n\r\n    logger.info('[FreeRouter] Advanced features: CircuitBreaker, RateLimitTracker, RequestDedupe, ModelPerfTracker, ApiKeyTimeoutTracker');\r\n  }\r\n\r\n  _selectRequestProxy() {\r\n    if (!this.config.proxy.enabled || this.config.proxy.list.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    this.currentProxyIndex = Math.floor(Math.random() * this.config.proxy.list.length);\r\n    return this.config.proxy.list[this.currentProxyIndex];\r\n  }\r\n\r\n  _parseProxy(proxyString) {\r\n    if (!proxyString) return null;\r\n\r\n    const parts = proxyString.split(':');\r\n    if (parts.length < 2) {\r\n      logger.warn(`[FreeRouter] Invalid proxy format: ${proxyString}`);\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      host: parts[0],\r\n      port: parts[1],\r\n      username: parts[2] || null,\r\n      password: parts[3] || null\r\n    };\r\n  }\r\n\r\n  _maskKey(key) {\r\n    if (!key) return 'null';\r\n    if (key.length < 8) return '***';\r\n    return `${key.substring(0, 6)}...${key.substring(key.length - 4)}`;\r\n  }\r\n\r\n   async processRequest(request) {\r\n     this.stats.totalRequests++;\r\n\r\n     if (!this.config.enabled) {\r\n       return { success: false, error: 'Free API router not enabled' };\r\n     }\r\n\r\n     const { messages, maxTokens = 100, temperature = 0.7 } = request;\r\n\r\n     const startTime = Date.now();\r\n\r\n     const dedupeResult = this.requestDedupe.check(messages, this.config.models.primary, maxTokens, temperature);\r\n\r\n     if (dedupeResult.hit) {\r\n       this.stats.dedupeHits++;\r\n       this.stats.successes++;\r\n\r\n       const warningStatus = this.rateLimitTracker.getWarningStatus(this.sessionApiKey);\r\n       logger.info(`[FreeRouter] Dedupe hit, returning cached response`);\r\n\r\n       return {\r\n         success: true,\r\n         content: dedupeResult.response,\r\n         model: this.config.models.primary,\r\n         keyUsed: this.sessionApiKeyIndex,\r\n         fromCache: true,\r\n         warningStatus: warningStatus\r\n       };\r\n     }\r\n\r\n     logger.info(`[FreeRouter] processRequest: calling _tryModelWithKey`);\r\n\r\n    // Build list of models to try - prioritize working models from test results\r\n    let modelsToTry = [];\r\n    \r\n    // Get tested working models if available\r\n    const testResults = sharedHelper?.getResults();\r\n    const configuredModels = [\r\n      this.config.models.primary,\r\n      ...this.config.models.fallbacks\r\n    ].filter(Boolean);\r\n    \r\n    if (testResults && testResults.working && testResults.working.length > 0) {\r\n      // Use tested working models first, in random order\r\n      let workingModels = [...testResults.working];\r\n      \r\n      // If we have fewer than 3 working models, add more from configured models\r\n      if (workingModels.length < 3) {\r\n        logger.warn(`[FreeRouter] Only ${workingModels.length} working models from tester, adding more from config`);\r\n        const additionalModels = configuredModels.filter(m => !workingModels.includes(m));\r\n        workingModels = [...workingModels, ...additionalModels];\r\n      }\r\n      \r\n      // Shuffle working models to distribute load\r\n      for (let i = workingModels.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [workingModels[i], workingModels[j]] = [workingModels[j], workingModels[i]];\r\n      }\r\n      modelsToTry = workingModels;\r\n      logger.info(`[FreeRouter] Using ${workingModels.length} models (shuffled) - ${testResults.working.length} tested working + ${workingModels.length - testResults.working.length} from config`);\r\n    } else {\r\n      // Fallback to configured models\r\n      modelsToTry = configuredModels;\r\n      logger.info(`[FreeRouter] No test results available, using ${modelsToTry.length} configured models`);\r\n    }\r\n\r\n    // Track models that got rate limited (429) to skip them\r\n    const rateLimitedModels = new Set();\r\n    const maxRetries = 3;\r\n    let retryCount = 0;\r\n\r\n    for (let modelIndex = 0; modelIndex < modelsToTry.length && retryCount < maxRetries; modelIndex++) {\r\n      const model = modelsToTry[modelIndex];\r\n      \r\n      // Skip if this model was already rate limited in this request\r\n      if (rateLimitedModels.has(model)) {\r\n        logger.info(`[FreeRouter] Skipping ${model} - already rate limited in this request`);\r\n        continue;\r\n      }\r\n\r\n      const circuitCheck = this.circuitBreaker.check(model, this.sessionApiKey);\r\n\r\n      if (!circuitCheck.allowed) {\r\n        this.stats.circuitBreaks++;\r\n        logger.warn(`[FreeRouter] Circuit open for ${model}, skipping`);\r\n        continue;\r\n      }\r\n\r\n      const rateLimitStatus = this.rateLimitTracker.getWarningStatus(this.sessionApiKey);\r\n\r\n      if (rateLimitStatus === 'exhausted') {\r\n        this.stats.rateLimitHits++;\r\n        logger.warn(`[FreeRouter] Rate limit exhausted for API key, trying fallback model`);\r\n        continue;\r\n      }\r\n\r\n      retryCount++;\r\n      logger.info(`[FreeRouter] Attempt ${retryCount}/${maxRetries}: Trying model ${model}`);\r\n\r\n      const result = await this._tryModelWithKey(model, messages, maxTokens, temperature, startTime);\r\n\r\n      if (result.success) {\r\n        const duration = Date.now() - startTime;\r\n\r\n        this.circuitBreaker.recordSuccess(model, this.sessionApiKey);\r\n        this.modelPerfTracker.trackSuccess(model, duration, this.sessionApiKey);\r\n        this.apiKeyTimeoutTracker.trackRequest(this.sessionApiKey, duration, true);\r\n        this.requestDedupe.set(messages, model, result.content, maxTokens, temperature);\r\n        this.rateLimitTracker.trackRequest(this.sessionApiKey, model);\r\n\r\n        this.stats.successes++;\r\n\r\n        return {\r\n          success: true,\r\n          content: result.content,\r\n          model: model,\r\n          keyUsed: this.sessionApiKeyIndex,\r\n          proxyUsed: result.proxyUsed,\r\n          modelFallbacks: modelIndex,\r\n          retryCount: retryCount,\r\n          duration,\r\n          warningStatus: rateLimitStatus\r\n        };\r\n      }\r\n\r\n      const duration = Date.now() - startTime;\r\n      logger.warn(`[FreeRouter] Model ${model} failed: ${result.error}`);\r\n\r\n      // Check if it's a server error (429, 503, 500, etc.) - these are retryable with different models\r\n      const isServerError = result.error && (\r\n        result.error.includes('429') || \r\n        result.error.includes('503') || \r\n        result.error.includes('500') ||\r\n        result.error.includes('502') ||\r\n        result.error.includes('504')\r\n      );\r\n      \r\n      if (isServerError) {\r\n        if (result.error.includes('429')) {\r\n          rateLimitedModels.add(model);\r\n          logger.warn(`[FreeRouter] Model ${model} rate limited (429), will skip in subsequent retries`);\r\n        } else {\r\n          logger.warn(`[FreeRouter] Model ${model} server error (${result.error.match(/\\d{3}/)?.[0] || 'unknown'}), marking for skip`);\r\n          rateLimitedModels.add(model);\r\n        }\r\n        // Temporarily record circuit breaker failure to avoid hammering\r\n        this.circuitBreaker.recordFailure(model, this.sessionApiKey);\r\n      } else {\r\n        this.circuitBreaker.recordFailure(model, this.sessionApiKey);\r\n      }\r\n      \r\n      this.modelPerfTracker.trackFailure(model, result.error, this.sessionApiKey);\r\n      this.apiKeyTimeoutTracker.trackRequest(this.sessionApiKey, duration, false);\r\n\r\n      if (result.usedProxy && this.config.proxy.enabled && this.config.proxy.fallbackToDirect) {\r\n        logger.info('[FreeRouter] Proxy failed, trying direct connection...');\r\n\r\n        const directResult = await this._tryModelDirect(model, messages, maxTokens, temperature, startTime);\r\n\r\n        if (directResult.success) {\r\n          const directDuration = Date.now() - startTime;\r\n\r\n          this.circuitBreaker.recordSuccess(model, this.sessionApiKey);\r\n          this.modelPerfTracker.trackSuccess(model, directDuration, this.sessionApiKey);\r\n          this.apiKeyTimeoutTracker.trackRequest(this.sessionApiKey, directDuration, true);\r\n          this.requestDedupe.set(messages, model, directResult.content, maxTokens, temperature);\r\n\r\n          this.stats.successes++;\r\n          this.stats.directFallbacks++;\r\n\r\n          return {\r\n            success: true,\r\n            content: directResult.content,\r\n            model: model,\r\n            keyUsed: this.sessionApiKeyIndex,\r\n            proxyUsed: false,\r\n            modelFallbacks: modelIndex,\r\n            directFallbackUsed: true,\r\n            retryCount: retryCount,\r\n            duration: directDuration\r\n          };\r\n        }\r\n\r\n        const directDuration = Date.now() - startTime;\r\n        logger.warn(`[FreeRouter] Direct connection also failed for ${model}: ${directResult.error}`);\r\n        this.circuitBreaker.recordFailure(model, this.sessionApiKey);\r\n        this.modelPerfTracker.trackFailure(model, directResult.error, this.sessionApiKey);\r\n        this.apiKeyTimeoutTracker.trackRequest(this.sessionApiKey, directDuration, false);\r\n      }\r\n      \r\n      // Log status before continuing to next model\r\n      if (retryCount < maxRetries && modelIndex < modelsToTry.length - 1) {\r\n        logger.info(`[FreeRouter] Moving to next model. Progress: ${retryCount}/${maxRetries} attempts used, ${modelsToTry.length - modelIndex - 1} models remaining`);\r\n      }\r\n    }\r\n\r\n    this.stats.failures++;\r\n\r\n    return {\r\n      success: false,\r\n      error: 'All models and fallbacks exhausted after 3 retries',\r\n      modelsTried: retryCount,\r\n      rateLimitedModels: Array.from(rateLimitedModels)\r\n    };\r\n  }\r\n\r\n   async _tryModelWithKey(model, messages, maxTokens, temperature, _startTime) {\r\n     logger.info(`[FreeRouter] _tryModelWithKey: model=${model}`);\r\n     const proxyString = this._selectRequestProxy();\r\n     logger.info(`[FreeRouter] _tryModelWithKey: proxy=${proxyString}`);\r\n     const proxy = this._parseProxy(proxyString);\r\n\r\n    const payload = {\r\n      model,\r\n      messages,\r\n      max_tokens: maxTokens,\r\n      temperature,\r\n      stream: false,\r\n      exclude_reasoning: true\r\n    };\r\n\r\n    const requestTimeout = this.apiKeyTimeoutTracker.getTimeoutForKey(this.sessionApiKey);\r\n\r\n    try {\r\n      if (proxy) {\r\n        return await this._callThroughProxy(proxy, payload, requestTimeout);\r\n      } else {\r\n        return await this._callDirect(payload, requestTimeout);\r\n      }\r\n    } catch (error) {\r\n      return { success: false, error: error.message, usedProxy: !!proxy };\r\n    }\r\n  }\r\n\r\n   async _callDirect(payload, timeout) {\r\n     logger.info(`[FreeRouter] _callDirect: starting request to ${payload.model}`);\r\n     const controller = new AbortController();\r\n     const timeoutId = setTimeout(() => {\r\n       controller.abort();\r\n       this.stats.quickTimeouts++;\r\n     }, timeout);\r\n\r\n    try {\r\n      const response = await fetch(this.endpoint, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Authorization': `Bearer ${this.sessionApiKey}`,\r\n          'HTTP-Referer': 'https://github.com/auto-ai',\r\n          'X-Title': 'Auto-AI Free Router'\r\n        },\r\n        body: JSON.stringify(payload),\r\n        signal: controller.signal\r\n      });\r\n\r\n      clearTimeout(timeoutId);\r\n\r\n      if (!response.ok) {\r\n        const errorText = await response.text();\r\n        throw classifyHttpError(response.status, errorText, { \r\n          endpoint: this.endpoint, \r\n          model: payload.model \r\n        });\r\n      }\r\n\r\nconst data = await response.json();\r\n        \r\n        const message = data.choices[0]?.message;\r\n        let content = message?.content || '';\r\n        \r\n        // DEBUG: Log raw API response to debug empty responses\r\n        // Check if reasoning_content has the actual response (some models put it there)\r\n        const reasoningContent = message?.reasoning_content || '';\r\n        \r\n        if (!content && reasoningContent) {\r\n          logger.warn(`[FreeRouter]  Content empty but reasoning_content has ${reasoningContent.length} chars - using reasoning_content`);\r\n          content = reasoningContent;\r\n        }\r\n        \r\n        // Log FULL response (not just first 500 chars) when debugging\r\n        if (!content) {\r\n          logger.warn(`[FreeRouter]  EMPTY RESPONSE from model ${payload.model}`);\r\n          logger.warn(`[FreeRouter] Full API Response: ${JSON.stringify(data, null, 2)}`);\r\n          logger.warn(`[FreeRouter] Message object: ${JSON.stringify(message, null, 2)}`);\r\n          logger.warn(`[FreeRouter] All choices: ${JSON.stringify(data.choices, null, 2)}`);\r\n        } else {\r\n          logger.debug(`[FreeRouter] Response received (${content.length} chars): ${content.substring(0, 200)}...`);\r\n        }\r\n        \r\n        if (reasoningContent) {\r\n          logger.debug(`[FreeRouter] Reasoning content excluded by API (${reasoningContent.length} chars)`);\r\n        }\r\n\r\n        return {\r\n          success: true,\r\n          content: content\r\n        };\r\n     } catch (error) {\r\n       clearTimeout(timeoutId);\r\n       // If it's already an AppError, rethrow it\r\n       if (error.name && error.name.includes('Error') && error.code) {\r\n         throw error;\r\n       }\r\n       // Otherwise wrap it\r\n       throw new RouterError(error.message, { endpoint: this.endpoint }, error);\r\n     }\r\n   }\r\n\r\n  async _callThroughProxy(proxy, payload, timeout) {\r\n    const proxyUrl = proxy.username\r\n      ? `http://${proxy.username}:${proxy.password}@${proxy.host}:${proxy.port}`\r\n      : `http://${proxy.host}:${proxy.port}`;\r\n\r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(() => {\r\n      controller.abort();\r\n      this.stats.quickTimeouts++;\r\n    }, timeout);\r\n\r\n    try {\r\n      const agent = await createProxyAgent(proxyUrl);\r\n      const httpAgent = await agent.getAgent();\r\n\r\n      if (!httpAgent) {\r\n        throw new ProxyError('Failed to create proxy agent', { \r\n          proxy: `${proxy.host}:${proxy.port}` \r\n        });\r\n      }\r\n\r\n      const response = await fetch(this.endpoint, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Authorization': `Bearer ${this.sessionApiKey}`,\r\n          'HTTP-Referer': 'https://github.com/auto-ai',\r\n          'X-Title': 'Auto-AI Free Router'\r\n        },\r\n        body: JSON.stringify(payload),\r\n        signal: controller.signal,\r\n        agent: httpAgent\r\n      });\r\n\r\n      clearTimeout(timeoutId);\r\n\r\n      if (!response.ok) {\r\n        const errorText = await response.text();\r\n        throw classifyHttpError(response.status, errorText, { \r\n          endpoint: this.endpoint, \r\n          model: payload.model,\r\n          proxy: `${proxy.host}:${proxy.port}`\r\n        });\r\n      }\r\n\r\nconst data = await response.json();\r\n\r\n        const message = data.choices[0]?.message;\r\n        let content = message?.content || '';\r\n        \r\n        // DEBUG: Log raw API response to debug empty responses\r\n        // Check if reasoning_content has the actual response (some models put it there)\r\n        const reasoningContent = message?.reasoning_content || '';\r\n        \r\n        if (!content && reasoningContent) {\r\n          logger.warn(`[FreeRouter]  Content empty but reasoning_content has ${reasoningContent.length} chars via proxy - using reasoning_content`);\r\n          content = reasoningContent;\r\n        }\r\n        \r\n        // Log FULL response (not just first 500 chars) when debugging\r\n        if (!content) {\r\n          logger.warn(`[FreeRouter]  EMPTY RESPONSE from model ${payload.model} via proxy ${proxy.host}`);\r\n          logger.warn(`[FreeRouter] Full API Response: ${JSON.stringify(data, null, 2)}`);\r\n          logger.warn(`[FreeRouter] Message object: ${JSON.stringify(message, null, 2)}`);\r\n          logger.warn(`[FreeRouter] All choices: ${JSON.stringify(data.choices, null, 2)}`);\r\n        } else {\r\n          logger.debug(`[FreeRouter] Response received (${content.length} chars): ${content.substring(0, 200)}...`);\r\n        }\r\n        \r\n        if (reasoningContent) {\r\n          logger.debug(`[FreeRouter] Reasoning content excluded by API (${reasoningContent.length} chars)`);\r\n        }\r\n\r\n        return {\r\n          success: true,\r\n          content: content,\r\n          proxy: `${proxy.host}:${proxy.port}`\r\n        };\r\n     } catch (error) {\r\n       clearTimeout(timeoutId);\r\n       throw error;\r\n     }\r\n   }\r\n\r\n  async _tryModelDirect(model, messages, maxTokens, temperature, startTime) {\r\n    const payload = {\r\n      model,\r\n      messages,\r\n      max_tokens: maxTokens,\r\n      temperature,\r\n      stream: false\r\n    };\r\n\r\n    const requestTimeout = this.apiKeyTimeoutTracker.getTimeoutForKey(this.sessionApiKey);\r\n    return await this._callDirect(payload, requestTimeout);\r\n  }\r\n\r\n  async validateConfig(settings) {\r\n    const result = this.configValidator.validate(settings);\r\n    this.configValidator.logResults();\r\n    return result;\r\n  }\r\n\r\n  async refreshRateLimits() {\r\n    if (this.sessionApiKey) {\r\n      return await this.rateLimitTracker.refreshKey(this.sessionApiKey);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  getSessionInfo() {\r\n    return {\r\n      sessionId: this.sessionId,\r\n      browserId: this.browserId,\r\n      taskId: this.taskId,\r\n      apiKeyIndex: this.sessionApiKeyIndex + 1,\r\n      totalApiKeys: this.config.apiKeys.length,\r\n      apiKeyMask: this._maskKey(this.sessionApiKey),\r\n      primaryModel: this.config.models.primary,\r\n      fallbackCount: this.config.models.fallbacks.length,\r\n      proxyEnabled: this.config.proxy.enabled,\r\n      proxyCount: this.config.proxy.list.length,\r\n      timeout: {\r\n        default: this.defaultTimeout + 'ms',\r\n        quick: this.quickTimeout + 'ms'\r\n      }\r\n    };\r\n  }\r\n\r\n  getStats() {\r\n    return {\r\n      router: {\r\n        totalRequests: this.stats.totalRequests,\r\n        successes: this.stats.successes,\r\n        failures: this.stats.failures,\r\n        circuitBreaks: this.stats.circuitBreaks,\r\n        rateLimitHits: this.stats.rateLimitHits,\r\n        dedupeHits: this.stats.dedupeHits,\r\n        quickTimeouts: this.stats.quickTimeouts,\r\n        successRate: this.stats.totalRequests > 0\r\n          ? ((this.stats.successes / this.stats.totalRequests) * 100).toFixed(1) + '%'\r\n          : '0%'\r\n      },\r\n      circuitBreaker: this.circuitBreaker.getStats(),\r\n      rateLimitTracker: this.rateLimitTracker.getStats(),\r\n      requestDedupe: this.requestDedupe.getStats(),\r\n      modelPerfTracker: this.modelPerfTracker.getStats(),\r\n      apiKeyTimeoutTracker: this.apiKeyTimeoutTracker.getStats()\r\n    };\r\n  }\r\n\r\n  getDetailedStats() {\r\n    return {\r\n      session: this.getSessionInfo(),\r\n      router: this.stats,\r\n      circuitBreakerStates: this.circuitBreaker.getAllStates(),\r\n      rateLimitStatus: this.rateLimitTracker.getCacheStatus(),\r\n      modelPerformance: this.modelPerfTracker.getAllStats(),\r\n      bestModel: this.modelPerfTracker.getBestModel([\r\n        this.config.models.primary,\r\n        ...this.config.models.fallbacks\r\n      ], this.sessionApiKey)\r\n    };\r\n  }\r\n\r\n  resetStats() {\r\n    this.stats = {\r\n      totalRequests: 0,\r\n      successes: 0,\r\n      failures: 0,\r\n      circuitBreaks: 0,\r\n      rateLimitHits: 0,\r\n      dedupeHits: 0,\r\n      quickTimeouts: 0\r\n    };\r\n\r\n    this.circuitBreaker.reset();\r\n    this.rateLimitTracker.invalidateCache();\r\n    this.requestDedupe.clear();\r\n    this.modelPerfTracker.reset();\r\n    this.apiKeyTimeoutTracker.reset();\r\n\r\n    logger.info('[FreeRouter] All stats reset');\r\n  }\r\n\r\n  isReady() {\r\n    return this.config.enabled &&\r\n           this.sessionApiKey &&\r\n           this.config.apiKeys.length > 0;\r\n  }\r\n\r\n  syncWithHelper() {\r\n    if (!sharedHelper) {\r\n      return false;\r\n    }\r\n\r\n    const results = sharedHelper.getResults();\r\n    if (!results || results.working.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    const workingModels = results.working;\r\n    const primaryModel = this.config.models.primary;\r\n\r\n    if (workingModels.includes(primaryModel)) {\r\n      this.config.models.primary = primaryModel;\r\n      this.config.models.fallbacks = workingModels.filter(m => m !== primaryModel);\r\n    } else {\r\n      this.config.models.primary = workingModels[0];\r\n      this.config.models.fallbacks = workingModels.slice(1);\r\n    }\r\n\r\n    logger.info(`[FreeRouter] Synced with helper: primary=${this.config.models.primary}, fallbacks=${this.config.models.fallbacks.length}`);\r\n    return true;\r\n  }\r\n\r\n  getModelsInfo() {\r\n    const results = sharedHelper?.getResults();\r\n    return {\r\n      primary: this.config.models.primary,\r\n      fallbacks: this.config.models.fallbacks,\r\n      testedWorking: results?.working || [],\r\n      testedFailed: results?.failed?.map(f => f.model) || [],\r\n      totalTested: results?.total || 0,\r\n      allConfigured: [\r\n        this.config.models.primary,\r\n        ...this.config.models.fallbacks\r\n      ].filter(Boolean)\r\n    };\r\n  }\r\n}\r\n\r\nexport default FreeApiRouter;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\My Script\\auto-ai\\utils\\generateProfiles.js","messages":[{"ruleId":"no-useless-assignment","severity":2,"message":"This assigned value is not used in subsequent statements.","line":115,"column":13,"messageId":"unnecessaryAssignment","endLine":115,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\nimport fs from 'fs';\r\nimport path from 'path';\r\nimport { fileURLToPath } from 'url';\r\n\r\nconst __filename = fileURLToPath(import.meta.url);\r\nconst __dirname = path.dirname(__filename);\r\n\r\nconst OUTPUT_FILE = path.join(__dirname, '../data/twitterActivityProfiles.json');\r\n\r\n// Tweaked Bounds\r\nconst BOUNDS = {\r\n    Skimmer: {\r\n        readingPhase: { mean: 60000, deviation: 20000 },\r\n        scrollPause: { mean: 800, deviation: 300 },\r\n        refresh: 0.2, dive: 0.2,\r\n        tweetDive: 0.05, like: 0.01,\r\n        bookmark: 0.002, follow: 0.001,\r\n        tweet: 0.01 // 1%\r\n    },\r\n    Balanced: {\r\n        readingPhase: { mean: 120000, deviation: 45000 },\r\n        scrollPause: { mean: 2000, deviation: 800 },\r\n        refresh: 0.1, dive: 0.3,\r\n        tweetDive: 0.1, like: 0.015,\r\n        bookmark: 0.005, follow: 0.003,\r\n        tweet: 0.05 // 5%\r\n    },\r\n    DeepDiver: {\r\n        readingPhase: { mean: 210000, deviation: 70000 },\r\n        scrollPause: { mean: 4000, deviation: 1500 },\r\n        refresh: 0.05, dive: 0.6,\r\n        tweetDive: 0.2, like: 0.018,\r\n        bookmark: 0.02, follow: 0.005,\r\n        tweet: 0.02 // 2%\r\n    },\r\n    Lurker: {\r\n        readingPhase: { mean: 250000, deviation: 90000 },\r\n        scrollPause: { mean: 3000, deviation: 1000 },\r\n        refresh: 0.05, dive: 0.1,\r\n        tweetDive: 0.15, like: 0.005,\r\n        bookmark: 0.03, follow: 0.001,\r\n        tweet: 0.001 // 0.1%\r\n    },\r\n    DoomScroller: {\r\n        readingPhase: { mean: 30000, deviation: 12000 },\r\n        scrollPause: { mean: 600, deviation: 200 },\r\n        refresh: 0.1, dive: 0.05,\r\n        tweetDive: 0.02, like: 0.005,\r\n        bookmark: 0.001, follow: 0.0005,\r\n        tweet: 0.001 // 0.1%\r\n    },\r\n    NewsJunkie: {\r\n        readingPhase: { mean: 40000, deviation: 15000 },\r\n        scrollPause: { mean: 1200, deviation: 400 },\r\n        refresh: 0.6, dive: 0.1,\r\n        tweetDive: 0.3, like: 0.01,\r\n        bookmark: 0.025, follow: 0.01,\r\n        tweet: 0.15 // 15%\r\n    },\r\n    Stalker: {\r\n        readingPhase: { mean: 120000, deviation: 40000 },\r\n        scrollPause: { mean: 2000, deviation: 800 },\r\n        refresh: 0.1, dive: 0.9,\r\n        tweetDive: 0.05, like: 0.01,\r\n        bookmark: 0.005, follow: 0.02,\r\n        tweet: 0.01 // 1%\r\n    }\r\n};\r\n\r\nclass ProfileFactory {\r\n    static gaussian(mean, stdev) {\r\n        let u = 0, v = 0;\r\n        while (u === 0) u = Math.random();\r\n        while (v === 0) v = Math.random();\r\n        return mean + stdev * Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\r\n    }\r\n\r\n    static round(num) {\r\n        return Math.round(num * 10000) / 10000; // 4 decimals\r\n    }\r\n\r\n    static create(index, type = \"Balanced\") {\r\n        const bounds = BOUNDS[type];\r\n\r\n        // 1. Timings\r\n        const pReading = {\r\n            mean: Math.floor(Math.max(15000, this.gaussian(bounds.readingPhase.mean, 10000))),\r\n            deviation: Math.floor(Math.max(5000, this.gaussian(bounds.readingPhase.deviation, 2000)))\r\n        };\r\n\r\n        const pScroll = {\r\n            mean: Math.floor(Math.max(200, this.gaussian(bounds.scrollPause.mean, 200))),\r\n            deviation: Math.floor(Math.max(50, this.gaussian(bounds.scrollPause.deviation, 50)))\r\n        };\r\n\r\n        // 2. Initial Probabilities\r\n        let pRefresh = Math.max(0, Math.min(0.8, this.gaussian(bounds.refresh, 0.05)));\r\n        let pDive = Math.max(0, Math.min(0.8, this.gaussian(bounds.dive, 0.1)));\r\n        let pIdle = Math.max(0, Math.min(0.3, this.gaussian(0.1, 0.05)));\r\n\r\n        // New Detailed Probabilities\r\n        let pTweetDive = Math.max(0, Math.min(0.9, this.gaussian(bounds.tweetDive, 0.05)));\r\n        // Enforce 0.5% min, 2% max for Likes\r\n        let pLikeAfter = Math.max(0.005, Math.min(0.02, this.gaussian(bounds.like, 0.005)));\r\n        let pBookmark = Math.max(0, Math.min(0.1, this.gaussian(bounds.bookmark, 0.005)));\r\n        let pFollow = Math.max(0, Math.min(0.01, this.gaussian(bounds.follow, 0.001)));\r\n\r\n        // Tweet (Post) Probability\r\n        let pTweet = Math.max(0, Math.min(0.3, this.gaussian(bounds.tweet, 0.02)));\r\n\r\n\r\n        // 3. New Input Logic (Mouse vs Keyboard Personas)\r\n        const isMouseUser = type === 'DoomScroller' ? true : (Math.random() < 0.9);\r\n        let inputP = {};\r\n\r\n        if (isMouseUser) {\r\n            const wheelBase = (type === 'DoomScroller') ? 0.95 : 0.85;\r\n            const wheelDown = this.gaussian(wheelBase, 0.05);\r\n            const wheelUp = Math.random() * 0.04 + 0.01;\r\n            // const remaining = 1.0 - (wheelDown + wheelUp);\r\n            let wDown = Math.max(0.70, wheelDown);\r\n            let wUp = Math.max(0.01, wheelUp);\r\n            let sp = Math.max(0, 1 - wDown - wUp);\r\n\r\n            inputP = {\r\n                wheelDown: this.round(wDown),\r\n                wheelUp: this.round(wUp),\r\n                space: this.round(sp),\r\n                keysDown: 0,\r\n                keysUp: 0\r\n            };\r\n        } else {\r\n            const keysDown = this.gaussian(0.85, 0.05);\r\n            const keysUp = Math.random() * 0.04 + 0.01;\r\n            let kDown = Math.max(0.70, keysDown);\r\n            let kUp = Math.max(0.01, keysUp);\r\n            let sp = Math.max(0, 1 - kDown - kUp);\r\n\r\n            inputP = {\r\n                wheelDown: 0,\r\n                wheelUp: 0,\r\n                space: this.round(sp),\r\n                keysDown: this.round(kDown),\r\n                keysUp: this.round(kUp)\r\n            };\r\n        }\r\n\r\n        pRefresh = this.round(pRefresh);\r\n        pDive = this.round(pDive);\r\n        pIdle = this.round(pIdle);\r\n        pTweetDive = this.round(pTweetDive);\r\n        pLikeAfter = this.round(pLikeAfter);\r\n        pBookmark = this.round(pBookmark);\r\n        pFollow = this.round(pFollow);\r\n        pTweet = this.round(pTweet);\r\n\r\n        // Generate ID and Description\r\n        const id = `${String(index).padStart(2, '0')}-${type}`;\r\n        const inputDesc = isMouseUser ? `Mouse (${(inputP.wheelDown * 100).toFixed(0)}%)` : `Keys (${(inputP.keysDown * 100).toFixed(0)}%)`;\r\n\r\n        const desc = `Type: ${type} | Input: ${inputDesc} | Dive: ${(pDive * 100).toFixed(1)}% | Tweet: ${(pTweet * 100).toFixed(1)}% | T-Dive: ${(pTweetDive * 100).toFixed(1)}% Like: ${(pLikeAfter * 100).toFixed(2)}%`;\r\n\r\n        return {\r\n            id,\r\n            description: desc,\r\n            timings: {\r\n                readingPhase: pReading,\r\n                scrollPause: pScroll,\r\n                actionSpecific: {\r\n                    space: {\r\n                        mean: Math.floor(Math.random() * (1200 - 800) + 800),\r\n                        deviation: Math.floor(Math.random() * (300 - 100) + 100)\r\n                    },\r\n                    keys: {\r\n                        mean: Math.floor(Math.random() * (150 - 80) + 80),\r\n                        deviation: Math.floor(Math.random() * (50 - 20) + 20)\r\n                    },\r\n                    // Idle duration (staring at screen) - Increased as requested\r\n                    idle: {\r\n                        mean: 15000,\r\n                        deviation: 5000\r\n                    }\r\n                }\r\n            },\r\n            probabilities: {\r\n                refresh: pRefresh,\r\n                profileDive: pDive,\r\n                tweetDive: pTweetDive,\r\n                likeTweetafterDive: pLikeAfter,\r\n                bookmarkAfterDive: pBookmark,\r\n                followOnProfile: pFollow,\r\n                tweet: pTweet,\r\n                // Reverted to original range logic (approx 10-30%)\r\n                idle: pIdle\r\n            },\r\n            inputMethods: inputP,\r\n            maxLike: 2,\r\n            maxFollow: 1,\r\n            theme: 'dark'\r\n        };\r\n    }\r\n}\r\n\r\n// Generate Profiles\r\nconst profileCounts = {\r\n    Skimmer: 4,\r\n    Balanced: 26,\r\n    DeepDiver: 4,\r\n    Lurker: 4,\r\n    DoomScroller: 4,\r\n    NewsJunkie: 4,\r\n    Stalker: 4\r\n};\r\n\r\nlet profiles = [];\r\nlet idx = 1;\r\n\r\nfor (const [type, count] of Object.entries(profileCounts)) {\r\n    for (let i = 0; i < count; i++) {\r\n        profiles.push(ProfileFactory.create(idx++, type));\r\n    }\r\n}\r\n\r\ntry {\r\n    fs.writeFileSync(OUTPUT_FILE, JSON.stringify(profiles, null, 2));\r\n    console.log(`[SUCCESS] Generated ${profiles.length} profiles to ${OUTPUT_FILE}`);\r\n    // Preview a few\r\n    console.log(\"Preview:\");\r\n    profiles.slice(0, 3).forEach(p => console.log(p.description));\r\n} catch (e) {\r\n    console.error(\"Failed to save profiles:\", e);\r\n}","usedDeprecatedRules":[]}]
