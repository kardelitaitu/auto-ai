<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>utils/ai-twitterAgent.js - MultiBrowseAutomation Docs</title>
    
    <meta name="description" content="Documentation for the Multi-Browser Automation Framework" />
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/your-repo-here" target="_blank" >GitHub Repo</a></h2><h3>Classes</h3><ul><li><a href="ActionOrchestrator.html">ActionOrchestrator</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ActionOrchestrator.html#getConstraintBlockedRoutines">getConstraintBlockedRoutines</a></li><li data-type='method' style='display: none;'><a href="ActionOrchestrator.html#getNext">getNext</a></li><li data-type='method' style='display: none;'><a href="ActionOrchestrator.html#getNextRoutine">getNextRoutine</a></li><li data-type='method' style='display: none;'><a href="ActionOrchestrator.html#record">record</a></li><li data-type='method' style='display: none;'><a href="ActionOrchestrator.html#reset">reset</a></li></ul></li><li><a href="module-connectors_baseDiscover-BaseDiscover.html">BaseDiscover</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-connectors_baseDiscover-BaseDiscover.html#discover">discover</a></li></ul></li><li><a href="module-connectors_discovery_ixbrowser-IxbrowserDiscover.html">IxbrowserDiscover</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-connectors_discovery_ixbrowser-IxbrowserDiscover.html#discover">discover</a></li></ul></li><li><a href="module-connectors_discovery_localBrave-LocalBraveDiscover.html">LocalBraveDiscover</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-connectors_discovery_localBrave-LocalBraveDiscover.html#discover">discover</a></li></ul></li><li><a href="module-connectors_discovery_roxybrowser-RoxybrowserDiscover.html">RoxybrowserDiscover</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-connectors_discovery_roxybrowser-RoxybrowserDiscover.html#discover">discover</a></li></ul></li><li><a href="module-connectors_discovery_undetectable-UndetectableDiscover.html">UndetectableDiscover</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-connectors_discovery_undetectable-UndetectableDiscover.html#discover">discover</a></li></ul></li><li><a href="module-core_agent-connector-AgentConnector.html">AgentConnector</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_agent-connector-AgentConnector.html#getHealth">getHealth</a></li><li data-type='method' style='display: none;'><a href="module-core_agent-connector-AgentConnector.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-core_agent-connector-AgentConnector.html#handleGenerateReply">handleGenerateReply</a></li><li data-type='method' style='display: none;'><a href="module-core_agent-connector-AgentConnector.html#handleVisionRequest">handleVisionRequest</a></li><li data-type='method' style='display: none;'><a href="module-core_agent-connector-AgentConnector.html#logHealth">logHealth</a></li><li data-type='method' style='display: none;'><a href="module-core_agent-connector-AgentConnector.html#processRequest">processRequest</a></li></ul></li><li><a href="module-core_audit-verifier-AuditVerifier.html">AuditVerifier</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_audit-verifier-AuditVerifier.html#calculateReliabilityMetric">calculateReliabilityMetric</a></li><li data-type='method' style='display: none;'><a href="module-core_audit-verifier-AuditVerifier.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-core_audit-verifier-AuditVerifier.html#logStats">logStats</a></li><li data-type='method' style='display: none;'><a href="module-core_audit-verifier-AuditVerifier.html#postFlightCheck">postFlightCheck</a></li><li data-type='method' style='display: none;'><a href="module-core_audit-verifier-AuditVerifier.html#preFlightCheck">preFlightCheck</a></li><li data-type='method' style='display: none;'><a href="module-core_audit-verifier-AuditVerifier.html#resetStats">resetStats</a></li><li data-type='method' style='display: none;'><a href="module-core_audit-verifier-AuditVerifier.html#waitForState">waitForState</a></li></ul></li><li><a href="module-core_automator-Automator.html">Automator</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#checkConnectionHealth">checkConnectionHealth</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#checkNetworkConnectivity">checkNetworkConnectivity</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#checkPageResponsive">checkPageResponsive</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#closeAll">closeAll</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#connectToBrowser">connectToBrowser</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#getBrowser">getBrowser</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#getConnectedEndpoints">getConnectedEndpoints</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#getConnectionCount">getConnectionCount</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#getHealthSummary">getHealthSummary</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#getHealthyConnectionCount">getHealthyConnectionCount</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#isHealthy">isHealthy</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#reconnect">reconnect</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#recoverConnection">recoverConnection</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#shutdown">shutdown</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#startHealthChecks">startHealthChecks</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#stopHealthChecks">stopHealthChecks</a></li><li data-type='method' style='display: none;'><a href="module-core_automator-Automator.html#testConnection">testConnection</a></li></ul></li><li><a href="module-core_circuit-breaker-CircuitBreaker.html">CircuitBreaker</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_circuit-breaker-CircuitBreaker.html#execute">execute</a></li><li data-type='method' style='display: none;'><a href="module-core_circuit-breaker-CircuitBreaker.html#forceClose">forceClose</a></li><li data-type='method' style='display: none;'><a href="module-core_circuit-breaker-CircuitBreaker.html#forceOpen">forceOpen</a></li><li data-type='method' style='display: none;'><a href="module-core_circuit-breaker-CircuitBreaker.html#getAllStatus">getAllStatus</a></li><li data-type='method' style='display: none;'><a href="module-core_circuit-breaker-CircuitBreaker.html#getBreaker">getBreaker</a></li><li data-type='method' style='display: none;'><a href="module-core_circuit-breaker-CircuitBreaker.html#getHealth">getHealth</a></li><li data-type='method' style='display: none;'><a href="module-core_circuit-breaker-CircuitBreaker.html#reset">reset</a></li><li data-type='method' style='display: none;'><a href="module-core_circuit-breaker-CircuitBreaker.html#resetAll">resetAll</a></li></ul></li><li><a href="module-core_cloud-client-CloudClient.html">CloudClient</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_cloud-client-CloudClient.html#getMultiClient">getMultiClient</a></li><li data-type='method' style='display: none;'><a href="module-core_cloud-client-CloudClient.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-core_cloud-client-CloudClient.html#resetStats">resetStats</a></li><li data-type='method' style='display: none;'><a href="module-core_cloud-client-CloudClient.html#sendRequest">sendRequest</a></li><li data-type='method' style='display: none;'><a href="module-core_cloud-client-CloudClient.html#testConnection">testConnection</a></li><li data-type='method' style='display: none;'><a href="module-core_cloud-client-CloudClient.html#testFreeModels">testFreeModels</a></li></ul></li><li><a href="module-core_discovery-Discovery.html">Discovery</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_discovery-Discovery.html#discoverBrowsers">discoverBrowsers</a></li><li data-type='method' style='display: none;'><a href="module-core_discovery-Discovery.html#getConnectorInfo">getConnectorInfo</a></li><li data-type='method' style='display: none;'><a href="module-core_discovery-Discovery.html#loadConnectors">loadConnectors</a></li></ul></li><li><a href="module-core_history-compactor-HistoryCompactor.html">HistoryCompactor</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_history-compactor-HistoryCompactor.html#compactHistory">compactHistory</a></li><li data-type='method' style='display: none;'><a href="module-core_history-compactor-HistoryCompactor.html#generateNarrativeSummary">generateNarrativeSummary</a></li><li data-type='method' style='display: none;'><a href="module-core_history-compactor-HistoryCompactor.html#getStats">getStats</a></li></ul></li><li><a href="module-core_humanizer-engine-HumanizerEngine.html">HumanizerEngine</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_humanizer-engine-HumanizerEngine.html#_easeOutCubic">_easeOutCubic</a></li><li data-type='method' style='display: none;'><a href="module-core_humanizer-engine-HumanizerEngine.html#_generateComputedPath">_generateComputedPath</a></li><li data-type='method' style='display: none;'><a href="module-core_humanizer-engine-HumanizerEngine.html#generateKeystrokeTiming">generateKeystrokeTiming</a></li><li data-type='method' style='display: none;'><a href="module-core_humanizer-engine-HumanizerEngine.html#generateMousePath">generateMousePath</a></li><li data-type='method' style='display: none;'><a href="module-core_humanizer-engine-HumanizerEngine.html#generatePause">generatePause</a></li></ul></li><li><a href="module-core_idle-ghosting-IdleGhosting.html">IdleGhosting</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_idle-ghosting-IdleGhosting.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-core_idle-ghosting-IdleGhosting.html#isGhosting">isGhosting</a></li><li data-type='method' style='display: none;'><a href="module-core_idle-ghosting-IdleGhosting.html#setWiggleParams">setWiggleParams</a></li><li data-type='method' style='display: none;'><a href="module-core_idle-ghosting-IdleGhosting.html#start">start</a></li><li data-type='method' style='display: none;'><a href="module-core_idle-ghosting-IdleGhosting.html#stop">stop</a></li></ul></li><li><a href="module-core_intent-classifier-IntentClassifier.html">IntentClassifier</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_intent-classifier-IntentClassifier.html#classify">classify</a></li><li data-type='method' style='display: none;'><a href="module-core_intent-classifier-IntentClassifier.html#forceCloud">forceCloud</a></li><li data-type='method' style='display: none;'><a href="module-core_intent-classifier-IntentClassifier.html#forceLocal">forceLocal</a></li><li data-type='method' style='display: none;'><a href="module-core_intent-classifier-IntentClassifier.html#getStats">getStats</a></li></ul></li><li><a href="module-core_local-client-LocalClient.html">LocalClient</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_local-client-LocalClient.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-core_local-client-LocalClient.html#resetStats">resetStats</a></li><li data-type='method' style='display: none;'><a href="module-core_local-client-LocalClient.html#sendRequest">sendRequest</a></li></ul></li><li><a href="module-core_ollama-client-OllamaClient.html">OllamaClient</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_ollama-client-OllamaClient.html#_chatRequest">_chatRequest</a></li><li data-type='method' style='display: none;'><a href="module-core_ollama-client-OllamaClient.html#_generateRequest">_generateRequest</a></li><li data-type='method' style='display: none;'><a href="module-core_ollama-client-OllamaClient.html#_warmupModel">_warmupModel</a></li><li data-type='method' style='display: none;'><a href="module-core_ollama-client-OllamaClient.html#applyHumanization">applyHumanization</a></li><li data-type='method' style='display: none;'><a href="module-core_ollama-client-OllamaClient.html#applyTypos">applyTypos</a></li><li data-type='method' style='display: none;'><a href="module-core_ollama-client-OllamaClient.html#generate">generate</a></li><li data-type='method' style='display: none;'><a href="module-core_ollama-client-OllamaClient.html#initialize">initialize</a></li><li data-type='method' style='display: none;'><a href="module-core_ollama-client-OllamaClient.html#isReady">isReady</a></li></ul></li><li><a href="module-core_orchestrator-Orchestrator.html">Orchestrator</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_orchestrator-Orchestrator.html#_sleep">_sleep</a></li><li data-type='method' style='display: none;'><a href="module-core_orchestrator-Orchestrator.html#addTask">addTask</a></li><li data-type='method' style='display: none;'><a href="module-core_orchestrator-Orchestrator.html#getMetrics">getMetrics</a></li><li data-type='method' style='display: none;'><a href="module-core_orchestrator-Orchestrator.html#getRecentTasks">getRecentTasks</a></li><li data-type='method' style='display: none;'><a href="module-core_orchestrator-Orchestrator.html#getTaskBreakdown">getTaskBreakdown</a></li><li data-type='method' style='display: none;'><a href="module-core_orchestrator-Orchestrator.html#logMetrics">logMetrics</a></li><li data-type='method' style='display: none;'><a href="module-core_orchestrator-Orchestrator.html#processTasks">processTasks</a></li><li data-type='method' style='display: none;'><a href="module-core_orchestrator-Orchestrator.html#shutdown">shutdown</a></li><li data-type='method' style='display: none;'><a href="module-core_orchestrator-Orchestrator.html#startDiscovery">startDiscovery</a></li><li data-type='method' style='display: none;'><a href="module-core_orchestrator-Orchestrator.html#waitForTasksToComplete">waitForTasksToComplete</a></li></ul></li><li><a href="module-core_prompt-builder-PromptBuilder.html">PromptBuilder</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_prompt-builder-PromptBuilder.html#build">build</a></li></ul></li><li><a href="module-core_request-queue-RequestQueue.html">RequestQueue</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_request-queue-RequestQueue.html#clear">clear</a></li><li data-type='method' style='display: none;'><a href="module-core_request-queue-RequestQueue.html#enqueue">enqueue</a></li><li data-type='method' style='display: none;'><a href="module-core_request-queue-RequestQueue.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-core_request-queue-RequestQueue.html#pause">pause</a></li><li data-type='method' style='display: none;'><a href="module-core_request-queue-RequestQueue.html#resume">resume</a></li></ul></li><li><a href="module-core_semantic-parser-SemanticParser.html">SemanticParser</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_semantic-parser-SemanticParser.html#extractSemanticTree">extractSemanticTree</a></li><li data-type='method' style='display: none;'><a href="module-core_semantic-parser-SemanticParser.html#findElementByName">findElementByName</a></li><li data-type='method' style='display: none;'><a href="module-core_semantic-parser-SemanticParser.html#generateCompactRepresentation">generateCompactRepresentation</a></li><li data-type='method' style='display: none;'><a href="module-core_semantic-parser-SemanticParser.html#getTreeStats">getTreeStats</a></li></ul></li><li><a href="module-core_sessionManager-SessionManager.html">SessionManager</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#addSession">addSession</a></li><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#cleanupTimedOutSessions">cleanupTimedOutSessions</a></li><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#findAndOccupyIdleWorker">findAndOccupyIdleWorker</a></li><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#getAllSessions">getAllSessions</a></li><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#getSessionMetadata">getSessionMetadata</a></li><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#getStuckWorkers">getStuckWorkers</a></li><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#getWorkerOccupancy">getWorkerOccupancy</a></li><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#loadSessionState">loadSessionState</a></li><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#registerPage">registerPage</a></li><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#releaseWorker">releaseWorker</a></li><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#removeSession">removeSession</a></li><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#saveSessionState">saveSessionState</a></li><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#shutdown">shutdown</a></li><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#stopCleanupTimer">stopCleanupTimer</a></li><li data-type='method' style='display: none;'><a href="module-core_sessionManager-SessionManager.html#unregisterPage">unregisterPage</a></li></ul></li><li><a href="module-core_state-manager-StateManager.html">StateManager</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_state-manager-StateManager.html#addBreadcrumb">addBreadcrumb</a></li><li data-type='method' style='display: none;'><a href="module-core_state-manager-StateManager.html#calculateComplexityScore">calculateComplexityScore</a></li><li data-type='method' style='display: none;'><a href="module-core_state-manager-StateManager.html#clearSession">clearSession</a></li><li data-type='method' style='display: none;'><a href="module-core_state-manager-StateManager.html#getBreadcrumbSummary">getBreadcrumbSummary</a></li><li data-type='method' style='display: none;'><a href="module-core_state-manager-StateManager.html#getBreadcrumbs">getBreadcrumbs</a></li><li data-type='method' style='display: none;'><a href="module-core_state-manager-StateManager.html#getExecutionState">getExecutionState</a></li><li data-type='method' style='display: none;'><a href="module-core_state-manager-StateManager.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-core_state-manager-StateManager.html#shutdown">shutdown</a></li><li data-type='method' style='display: none;'><a href="module-core_state-manager-StateManager.html#updateExecutionState">updateExecutionState</a></li></ul></li><li><a href="module-core_stuck-detector-StuckDetector.html">StuckDetector</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_stuck-detector-StuckDetector.html#check">check</a></li><li data-type='method' style='display: none;'><a href="module-core_stuck-detector-StuckDetector.html#reset">reset</a></li></ul></li><li><a href="module-core_vision-interpreter-VisionInterpreter.html">VisionInterpreter</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_vision-interpreter-VisionInterpreter.html#buildPrompt">buildPrompt</a></li><li data-type='method' style='display: none;'><a href="module-core_vision-interpreter-VisionInterpreter.html#parseResponse">parseResponse</a></li></ul></li><li><a href="module-core_vision-packager-VisionPackager.html">VisionPackager</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_vision-packager-VisionPackager.html#captureScreenshot">captureScreenshot</a></li><li data-type='method' style='display: none;'><a href="module-core_vision-packager-VisionPackager.html#captureWithROI">captureWithROI</a></li><li data-type='method' style='display: none;'><a href="module-core_vision-packager-VisionPackager.html#cleanupOldScreenshots">cleanupOldScreenshots</a></li><li data-type='method' style='display: none;'><a href="module-core_vision-packager-VisionPackager.html#compressScreenshot">compressScreenshot</a></li><li data-type='method' style='display: none;'><a href="module-core_vision-packager-VisionPackager.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-core_vision-packager-VisionPackager.html#identifyROI">identifyROI</a></li></ul></li><li><a href="module-core_vllm-client-VLLMClient.html">VLLMClient</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-core_vllm-client-VLLMClient.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-core_vllm-client-VLLMClient.html#resetStats">resetStats</a></li><li data-type='method' style='display: none;'><a href="module-core_vllm-client-VLLMClient.html#sendRequest">sendRequest</a></li><li data-type='method' style='display: none;'><a href="module-core_vllm-client-VLLMClient.html#testConnection">testConnection</a></li></ul></li><li><a href="module-utils_actions.ActionRunner.html">ActionRunner</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_actions.ActionRunner.html#calculateSmartProbabilities">calculateSmartProbabilities</a></li><li data-type='method' style='display: none;'><a href="module-utils_actions.ActionRunner.html#executeAction">executeAction</a></li><li data-type='method' style='display: none;'><a href="module-utils_actions.ActionRunner.html#getEngagementType">getEngagementType</a></li><li data-type='method' style='display: none;'><a href="module-utils_actions.ActionRunner.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-utils_actions.ActionRunner.html#isActionAvailable">isActionAvailable</a></li><li data-type='method' style='display: none;'><a href="module-utils_actions.ActionRunner.html#selectAction">selectAction</a></li><li data-type='method' style='display: none;'><a href="module-utils_actions.ActionRunner.html#tryExecute">tryExecute</a></li></ul></li><li><a href="module-utils_apiHandler-ApiHandler.html">ApiHandler</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_apiHandler-ApiHandler.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="module-utils_apiHandler-ApiHandler.html#get">get</a></li><li data-type='method' style='display: none;'><a href="module-utils_apiHandler-ApiHandler.html#post">post</a></li><li data-type='method' style='display: none;'><a href="module-utils_apiHandler-ApiHandler.html#put">put</a></li><li data-type='method' style='display: none;'><a href="module-utils_apiHandler-ApiHandler.html#request">request</a></li></ul></li><li><a href="module-utils_async-queue.DiveQueue.html">DiveQueue</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_async-queue.DiveQueue.html#addDive">addDive</a></li><li data-type='method' style='display: none;'><a href="module-utils_async-queue.DiveQueue.html#canEngage">canEngage</a></li><li data-type='method' style='display: none;'><a href="module-utils_async-queue.DiveQueue.html#disableQuickMode">disableQuickMode</a></li><li data-type='method' style='display: none;'><a href="module-utils_async-queue.DiveQueue.html#enableQuickMode">enableQuickMode</a></li><li data-type='method' style='display: none;'><a href="module-utils_async-queue.DiveQueue.html#getEngagementProgress">getEngagementProgress</a></li><li data-type='method' style='display: none;'><a href="module-utils_async-queue.DiveQueue.html#getFullStatus">getFullStatus</a></li><li data-type='method' style='display: none;'><a href="module-utils_async-queue.DiveQueue.html#recordEngagement">recordEngagement</a></li><li data-type='method' style='display: none;'><a href="module-utils_async-queue.DiveQueue.html#resetEngagement">resetEngagement</a></li><li data-type='method' style='display: none;'><a href="module-utils_async-queue.DiveQueue.html#updateEngagementLimits">updateEngagementLimits</a></li><li data-type='method' style='display: none;'><a href="module-utils_async-queue.DiveQueue.html#updateEngagementLimits">updateEngagementLimits</a></li></ul></li><li><a href="module-utils_config-cache.ConfigCache.html">ConfigCache</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_config-cache.ConfigCache.html#cleanExpired">cleanExpired</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-cache.ConfigCache.html#clear">clear</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-cache.ConfigCache.html#delete">delete</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-cache.ConfigCache.html#get">get</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-cache.ConfigCache.html#getEntries">getEntries</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-cache.ConfigCache.html#getMemoryUsage">getMemoryUsage</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-cache.ConfigCache.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-cache.ConfigCache.html#has">has</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-cache.ConfigCache.html#set">set</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-cache.ConfigCache.html#updateMaxSize">updateMaxSize</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-cache.ConfigCache.html#updateTTL">updateTTL</a></li></ul></li><li><a href="module-utils_config-service-ConfigService.html">ConfigService</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_config-service-ConfigService.html#_getWithDefaults">_getWithDefaults</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-service-ConfigService.html#ensureInit">ensureInit</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-service-ConfigService.html#get">get</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-service-ConfigService.html#getProfileConfig">getProfileConfig</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-service-ConfigService.html#getSettings">getSettings</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-service-ConfigService.html#init">init</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-service-ConfigService.html#reload">reload</a></li></ul></li><li><a href="module-utils_config-validator.ConfigValidator.html">ConfigValidator</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_config-validator.ConfigValidator.html#getSchema">getSchema</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-validator.ConfigValidator.html#validateConfig">validateConfig</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-validator.ConfigValidator.html#validateSectionConfig">validateSectionConfig</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-validator.ConfigValidator.html#validateWithReport">validateWithReport</a></li></ul></li><li><a href="module-utils_configLoader-ConfigLoader.html">ConfigLoader</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_configLoader-ConfigLoader.html#clearCache">clearCache</a></li><li data-type='method' style='display: none;'><a href="module-utils_configLoader-ConfigLoader.html#getValue">getValue</a></li><li data-type='method' style='display: none;'><a href="module-utils_configLoader-ConfigLoader.html#loadConfig">loadConfig</a></li><li data-type='method' style='display: none;'><a href="module-utils_configLoader-ConfigLoader.html#reloadConfig">reloadConfig</a></li><li data-type='method' style='display: none;'><a href="module-utils_configLoader-ConfigLoader.html#validateConfig">validateConfig</a></li></ul></li><li><a href="module-utils_entropyController-EntropyController.html">EntropyController</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#applyFatigueToTiming">applyFatigueToTiming</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#calculateFatigueLevel">calculateFatigueLevel</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#checkFatigue">checkFatigue</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#gaussian">gaussian</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#generateSessionProfile">generateSessionProfile</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#getFatigueModifiers">getFatigueModifiers</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#getSessionStats">getSessionStats</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#interActionGap">interActionGap</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#logAction">logAction</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#logNormal">logNormal</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#microBreakDuration">microBreakDuration</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#pageLoadWait">pageLoadWait</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#poisson">poisson</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#postClickDelay">postClickDelay</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#preDecisionDelay">preDecisionDelay</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#reactionTime">reactionTime</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#readingTime">readingTime</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#resetSession">resetSession</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#retryDelay">retryDelay</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#scrollDistance">scrollDistance</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#scrollSettleTime">scrollSettleTime</a></li><li data-type='method' style='display: none;'><a href="module-utils_entropyController-EntropyController.html#shouldMicroBreak">shouldMicroBreak</a></li></ul></li><li><a href="module-utils_environment-config.EnvironmentConfig.html">EnvironmentConfig</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_environment-config.EnvironmentConfig.html#generateDocumentation">generateDocumentation</a></li><li data-type='method' style='display: none;'><a href="module-utils_environment-config.EnvironmentConfig.html#getConfigPath">getConfigPath</a></li><li data-type='method' style='display: none;'><a href="module-utils_environment-config.EnvironmentConfig.html#getCurrentEnvValues">getCurrentEnvValues</a></li><li data-type='method' style='display: none;'><a href="module-utils_environment-config.EnvironmentConfig.html#getEnvOverrides">getEnvOverrides</a></li><li data-type='method' style='display: none;'><a href="module-utils_environment-config.EnvironmentConfig.html#getSupportedEnvVars">getSupportedEnvVars</a></li><li data-type='method' style='display: none;'><a href="module-utils_environment-config.EnvironmentConfig.html#isSupportedEnvVar">isSupportedEnvVar</a></li><li data-type='method' style='display: none;'><a href="module-utils_environment-config.EnvironmentConfig.html#validateEnvValues">validateEnvValues</a></li><li data-type='method' style='display: none;'><a href="module-utils_environment-config.EnvironmentConfig.html#.applyEnvOverrides">applyEnvOverrides</a></li><li data-type='method' style='display: none;'><a href="module-utils_environment-config.EnvironmentConfig.html#.getNestedValue">getNestedValue</a></li><li data-type='method' style='display: none;'><a href="module-utils_environment-config.EnvironmentConfig.html#.logAppliedOverrides">logAppliedOverrides</a></li><li data-type='method' style='display: none;'><a href="module-utils_environment-config.EnvironmentConfig.html#.parseEnvValue">parseEnvValue</a></li><li data-type='method' style='display: none;'><a href="module-utils_environment-config.EnvironmentConfig.html#.setNestedValue">setNestedValue</a></li></ul></li><li><a href="module-utils_errors.AppError.html">AppError</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_errors.AppError.html#toJSON">toJSON</a></li><li data-type='method' style='display: none;'><a href="module-utils_errors.AppError.html#toString">toString</a></li></ul></li><li><a href="module-utils_errors.BrowserError.html">BrowserError</a></li><li><a href="module-utils_errors.CircuitBreakerError.html">CircuitBreakerError</a></li><li><a href="module-utils_errors.ConfigError.html">ConfigError</a></li><li><a href="module-utils_errors.ModelError.html">ModelError</a></li><li><a href="module-utils_errors.ProxyError.html">ProxyError</a></li><li><a href="module-utils_errors.RateLimitError.html">RateLimitError</a></li><li><a href="module-utils_errors.RouterError.html">RouterError</a></li><li><a href="module-utils_errors.TimeoutError.html">TimeoutError</a></li><li><a href="module-utils_errors.ValidationError.html">ValidationError</a></li><li><a href="module-utils_global-scroll-controller-GlobalScrollController.html">GlobalScrollController</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_global-scroll-controller-GlobalScrollController.html#apply">apply</a></li><li data-type='method' style='display: none;'><a href="module-utils_global-scroll-controller-GlobalScrollController.html#applyRandom">applyRandom</a></li><li data-type='method' style='display: none;'><a href="module-utils_global-scroll-controller-GlobalScrollController.html#getMultiplier">getMultiplier</a></li><li data-type='method' style='display: none;'><a href="module-utils_global-scroll-controller-GlobalScrollController.html#init">init</a></li><li data-type='method' style='display: none;'><a href="module-utils_global-scroll-controller-GlobalScrollController.html#reload">reload</a></li><li data-type='method' style='display: none;'><a href="module-utils_global-scroll-controller-GlobalScrollController.html#scrollBy">scrollBy</a></li><li data-type='method' style='display: none;'><a href="module-utils_global-scroll-controller-GlobalScrollController.html#scrollDown">scrollDown</a></li><li data-type='method' style='display: none;'><a href="module-utils_global-scroll-controller-GlobalScrollController.html#scrollRandom">scrollRandom</a></li><li data-type='method' style='display: none;'><a href="module-utils_global-scroll-controller-GlobalScrollController.html#scrollReplies">scrollReplies</a></li><li data-type='method' style='display: none;'><a href="module-utils_global-scroll-controller-GlobalScrollController.html#scrollToBottom">scrollToBottom</a></li><li data-type='method' style='display: none;'><a href="module-utils_global-scroll-controller-GlobalScrollController.html#scrollToElement">scrollToElement</a></li><li data-type='method' style='display: none;'><a href="module-utils_global-scroll-controller-GlobalScrollController.html#scrollToTop">scrollToTop</a></li><li data-type='method' style='display: none;'><a href="module-utils_global-scroll-controller-GlobalScrollController.html#scrollUp">scrollUp</a></li><li data-type='method' style='display: none;'><a href="module-utils_global-scroll-controller-GlobalScrollController.html#smoothScroll">smoothScroll</a></li></ul></li><li><a href="module-utils_logger-BufferedLogger.html">BufferedLogger</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_logger-BufferedLogger.html#_add">_add</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-BufferedLogger.html#_startTimer">_startTimer</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-BufferedLogger.html#_stopTimer">_stopTimer</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-BufferedLogger.html#clear">clear</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-BufferedLogger.html#debug">debug</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-BufferedLogger.html#error">error</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-BufferedLogger.html#flush">flush</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-BufferedLogger.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-BufferedLogger.html#info">info</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-BufferedLogger.html#shutdown">shutdown</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-BufferedLogger.html#success">success</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-BufferedLogger.html#warn">warn</a></li></ul></li><li></li><li><a href="module-utils_logger-Logger.html">Logger</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_logger-Logger.html#_log">_log</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-Logger.html#colorizeTags">colorizeTags</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-Logger.html#debug">debug</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-Logger.html#error">error</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-Logger.html#info">info</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-Logger.html#success">success</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger-Logger.html#warn">warn</a></li></ul></li><li><a href="module-utils_metrics-MetricsCollector.html">MetricsCollector</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#exportToJSON">exportToJSON</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#generateJsonReport">generateJsonReport</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#getAvgAILatency">getAvgAILatency</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#getAvgDiveDuration">getAvgDiveDuration</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#getRecentTasks">getRecentTasks</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#getTaskBreakdown">getTaskBreakdown</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#getTwitterEngagementMetrics">getTwitterEngagementMetrics</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#logStats">logStats</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#recordAILatency">recordAILatency</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#recordApiCall">recordApiCall</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#recordBrowserDiscovery">recordBrowserDiscovery</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#recordDiveDuration">recordDiveDuration</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#recordError">recordError</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#recordSessionEvent">recordSessionEvent</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#recordSocialAction">recordSocialAction</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#recordTaskExecution">recordTaskExecution</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#recordTwitterEngagement">recordTwitterEngagement</a></li><li data-type='method' style='display: none;'><a href="module-utils_metrics-MetricsCollector.html#reset">reset</a></li></ul></li><li><a href="module-utils_sentiment-integration.SentimentIntegration.html">SentimentIntegration</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_sentiment-integration.SentimentIntegration.html#checkEngagementAction">checkEngagementAction</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-integration.SentimentIntegration.html#enrichContext">enrichContext</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-integration.SentimentIntegration.html#export">export</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-integration.SentimentIntegration.html#getReplyToneAdaptation">getReplyToneAdaptation</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-integration.SentimentIntegration.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-integration.SentimentIntegration.html#setEnabled">setEnabled</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-integration.SentimentIntegration.html#setPersonality">setPersonality</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-integration.SentimentIntegration.html#shouldQuoteCheck">shouldQuoteCheck</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-integration.SentimentIntegration.html#shouldReplyCheck">shouldReplyCheck</a></li></ul></li><li><a href="module-utils_sentiment-service.SentimentService.html">SentimentService</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_sentiment-service.SentimentService.html#analyze">analyze</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-service.SentimentService.html#analyzeBasic">analyzeBasic</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-service.SentimentService.html#analyzeForReplySelection">analyzeForReplySelection</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-service.SentimentService.html#calculateConfidence">calculateConfidence</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-service.SentimentService.html#deriveCompositeMetrics">deriveCompositeMetrics</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-service.SentimentService.html#getEngagementRecommendations">getEngagementRecommendations</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-service.SentimentService.html#getFromCache">getFromCache</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-service.SentimentService.html#getNeutralAnalysis">getNeutralAnalysis</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-service.SentimentService.html#getReplyRecommendations">getReplyRecommendations</a></li><li data-type='method' style='display: none;'><a href="module-utils_sentiment-service.SentimentService.html#hasNegativePattern">hasNegativePattern</a></li></ul></li><li><a href="module-utils_task-config-loader.TaskConfigLoader.html">TaskConfigLoader</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_task-config-loader.TaskConfigLoader.html#clearCache">clearCache</a></li><li data-type='method' style='display: none;'><a href="module-utils_task-config-loader.TaskConfigLoader.html#getStats">getStats</a></li><li data-type='method' style='display: none;'><a href="module-utils_task-config-loader.TaskConfigLoader.html#loadAiTwitterActivityConfig">loadAiTwitterActivityConfig</a></li></ul></li><li><a href="utils_config-manager%250D%250DThis%2520is%2520a%2520NEW%2520module%2520for%2520Phase%25202%2520improvements.%2520It%2520does%2520not%2520replace%2520existing%2520config%2520loaders%250Dbut%2520provides%2520a%2520more%2520robust%2520alternative%2520for%2520new%2520code.module_-ConfigManager.html">ConfigManager</a><ul class='methods'><li data-type='method' style='display: none;'><a href="utils_config-manager%25250D%25250DThis%252520is%252520a%252520NEW%252520module%252520for%252520Phase%2525202%252520improvements.%252520It%252520does%252520not%252520replace%252520existing%252520config%252520loaders%25250Dbut%252520provides%252520a%252520more%252520robust%252520alternative%252520for%252520new%252520code.module_-ConfigManager.html#clearCache">clearCache</a></li><li data-type='method' style='display: none;'><a href="utils_config-manager%25250D%25250DThis%252520is%252520a%252520NEW%252520module%252520for%252520Phase%2525202%252520improvements.%252520It%252520does%252520not%252520replace%252520existing%252520config%252520loaders%25250Dbut%252520provides%252520a%252520more%252520robust%252520alternative%252520for%252520new%252520code.module_-ConfigManager.html#get">get</a></li><li data-type='method' style='display: none;'><a href="utils_config-manager%25250D%25250DThis%252520is%252520a%252520NEW%252520module%252520for%252520Phase%2525202%252520improvements.%252520It%252520does%252520not%252520replace%252520existing%252520config%252520loaders%25250Dbut%252520provides%252520a%252520more%252520robust%252520alternative%252520for%252520new%252520code.module_-ConfigManager.html#getCacheStats">getCacheStats</a></li><li data-type='method' style='display: none;'><a href="utils_config-manager%25250D%25250DThis%252520is%252520a%252520NEW%252520module%252520for%252520Phase%2525202%252520improvements.%252520It%252520does%252520not%252520replace%252520existing%252520config%252520loaders%25250Dbut%252520provides%252520a%252520more%252520robust%252520alternative%252520for%252520new%252520code.module_-ConfigManager.html#getSources">getSources</a></li><li data-type='method' style='display: none;'><a href="utils_config-manager%25250D%25250DThis%252520is%252520a%252520NEW%252520module%252520for%252520Phase%2525202%252520improvements.%252520It%252520does%252520not%252520replace%252520existing%252520config%252520loaders%25250Dbut%252520provides%252520a%252520more%252520robust%252520alternative%252520for%252520new%252520code.module_-ConfigManager.html#getWithMeta">getWithMeta</a></li><li data-type='method' style='display: none;'><a href="utils_config-manager%25250D%25250DThis%252520is%252520a%252520NEW%252520module%252520for%252520Phase%2525202%252520improvements.%252520It%252520does%252520not%252520replace%252520existing%252520config%252520loaders%25250Dbut%252520provides%252520a%252520more%252520robust%252520alternative%252520for%252520new%252520code.module_-ConfigManager.html#has">has</a></li><li data-type='method' style='display: none;'><a href="utils_config-manager%25250D%25250DThis%252520is%252520a%252520NEW%252520module%252520for%252520Phase%2525202%252520improvements.%252520It%252520does%252520not%252520replace%252520existing%252520config%252520loaders%25250Dbut%252520provides%252520a%252520more%252520robust%252520alternative%252520for%252520new%252520code.module_-ConfigManager.html#init">init</a></li><li data-type='method' style='display: none;'><a href="utils_config-manager%25250D%25250DThis%252520is%252520a%252520NEW%252520module%252520for%252520Phase%2525202%252520improvements.%252520It%252520does%252520not%252520replace%252520existing%252520config%252520loaders%25250Dbut%252520provides%252520a%252520more%252520robust%252520alternative%252520for%252520new%252520code.module_-ConfigManager.html#keys">keys</a></li><li data-type='method' style='display: none;'><a href="utils_config-manager%25250D%25250DThis%252520is%252520a%252520NEW%252520module%252520for%252520Phase%2525202%252520improvements.%252520It%252520does%252520not%252520replace%252520existing%252520config%252520loaders%25250Dbut%252520provides%252520a%252520more%252520robust%252520alternative%252520for%252520new%252520code.module_-ConfigManager.html#reload">reload</a></li><li data-type='method' style='display: none;'><a href="utils_config-manager%25250D%25250DThis%252520is%252520a%252520NEW%252520module%252520for%252520Phase%2525202%252520improvements.%252520It%252520does%252520not%252520replace%252520existing%252520config%252520loaders%25250Dbut%252520provides%252520a%252520more%252520robust%252520alternative%252520for%252520new%252520code.module_-ConfigManager.html#set">set</a></li><li data-type='method' style='display: none;'><a href="utils_config-manager%25250D%25250DThis%252520is%252520a%252520NEW%252520module%252520for%252520Phase%2525202%252520improvements.%252520It%252520does%252520not%252520replace%252520existing%252520config%252520loaders%25250Dbut%252520provides%252520a%252520more%252520robust%252520alternative%252520for%252520new%252520code.module_-ConfigManager.html#toJSON">toJSON</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-connectors_baseDiscover.html">connectors/baseDiscover</a></li><li><a href="module-connectors_discovery_ixbrowser.html">connectors/discovery/ixbrowser</a></li><li><a href="module-connectors_discovery_localBrave.html">connectors/discovery/localBrave</a></li><li><a href="module-connectors_discovery_roxybrowser.html">connectors/discovery/roxybrowser</a></li><li><a href="module-connectors_discovery_undetectable.html">connectors/discovery/undetectable</a></li><li><a href="module-constants_twitter-timeouts.html">constants/twitter-timeouts</a></li><li><a href="module-core_agent-connector.html">core/agent-connector</a></li><li><a href="module-core_agent-cortex.html">core/agent-cortex</a></li><li><a href="module-core_audit-verifier.html">core/audit-verifier</a></li><li><a href="module-core_automator.html">core/automator</a></li><li><a href="module-core_circuit-breaker.html">core/circuit-breaker</a></li><li><a href="module-core_cloud-client.html">core/cloud-client</a></li><li><a href="module-core_discovery.html">core/discovery</a></li><li><a href="module-core_history-compactor.html">core/history-compactor</a></li><li><a href="module-core_humanizer-engine.html">core/humanizer-engine</a></li><li><a href="module-core_idle-ghosting.html">core/idle-ghosting</a></li><li><a href="module-core_intent-classifier.html">core/intent-classifier</a></li><li><a href="module-core_local-client.html">core/local-client</a></li><li><a href="module-core_ollama-client.html">core/ollama-client</a></li><li><a href="module-core_orchestrator.html">core/orchestrator</a></li><li><a href="module-core_prompt-builder.html">core/prompt-builder</a></li><li><a href="module-core_request-queue.html">core/request-queue</a></li><li><a href="module-core_semantic-parser.html">core/semantic-parser</a></li><li><a href="module-core_sessionManager.html">core/sessionManager</a></li><li><a href="module-core_state-manager.html">core/state-manager</a></li><li><a href="module-core_stuck-detector.html">core/stuck-detector</a></li><li><a href="module-core_vision-interpreter.html">core/vision-interpreter</a></li><li><a href="module-core_vision-packager.html">core/vision-packager</a></li><li><a href="module-core_vision_image-storage.html">core/vision/image-storage</a></li><li><a href="module-core_vision_roi-detector.html">core/vision/roi-detector</a></li><li><a href="module-core_vllm-client.html">core/vllm-client</a></li><li><a href="module-examples_simpleNavigate.html">examples/simpleNavigate</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-examples_simpleNavigate.html#~simpleNavigate">simpleNavigate</a></li></ul></li><li><a href="module-local-agent_core_actionEngine.html">local-agent/core/actionEngine</a></li><li><a href="module-local-agent_core_agent.html">local-agent/core/agent</a></li><li><a href="module-local-agent_core_vision.html">local-agent/core/vision</a></li><li><a href="module-local-agent_network_llmClient.html">local-agent/network/llmClient</a></li><li><a href="module-main.html">main</a></li><li><a href="module-strategies_EntropyReferrer.html">strategies/EntropyReferrer</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-strategies_EntropyReferrer.html#~_extractContext">_extractContext</a></li></ul></li><li><a href="module-tasks_agentNavigate.html">tasks/agentNavigate</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-tasks_agentNavigate.html#~agentNavigate">agentNavigate</a></li></ul></li><li><a href="module-tasks_ai-testertask.html">tasks/ai-testertask</a></li><li><a href="module-tasks_automationTask1.html">tasks/automationTask1</a></li><li><a href="module-tasks_automationTask2.html">tasks/automationTask2</a></li><li><a href="module-tasks_cookieBotRandom.html">tasks/cookieBotRandom</a></li><li><a href="module-tasks_runAgent.html">tasks/runAgent</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-tasks_runAgent.html#.run">run</a></li></ul></li><li><a href="module-tasks_testGoogleSearch.html">tasks/testGoogleSearch</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-tasks_testGoogleSearch.html#~testGoogleSearch">testGoogleSearch</a></li></ul></li><li><a href="module-tasks_twitterscroll.html">tasks/twitterscroll</a></li><li><a href="module-tests_test-core-modules.html">tests/test-core-modules</a></li><li><a href="module-utils_actions.html">utils/actions</a></li><li><a href="module-utils_actions_ai-twitter-bookmark.html">utils/actions/ai-twitter-bookmark</a></li><li><a href="module-utils_actions_ai-twitter-go-home.html">utils/actions/ai-twitter-go-home</a></li><li><a href="module-utils_actions_ai-twitter-like.html">utils/actions/ai-twitter-like</a></li><li><a href="module-utils_actions_ai-twitter-quote.html">utils/actions/ai-twitter-quote</a></li><li><a href="module-utils_actions_ai-twitter-reply.html">utils/actions/ai-twitter-reply</a></li><li><a href="module-utils_ai-context-engine.html">utils/ai-context-engine</a></li><li><a href="module-utils_ai-quote-engine.html">utils/ai-quote-engine</a></li><li><a href="module-utils_ai-reply-engine.html">utils/ai-reply-engine</a></li><li><a href="module-utils_ai-tools.html">utils/ai-tools</a></li><li><a href="module-utils_ai-twitterAgent.html">utils/ai-twitterAgent</a></li><li><a href="module-utils_api-key-timeout-tracker.html">utils/api-key-timeout-tracker</a></li><li><a href="module-utils_apiHandler.html">utils/apiHandler</a></li><li><a href="module-utils_async-queue.html">utils/async-queue</a></li><li><a href="module-utils_banner.html">utils/banner</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_banner.html#.showBanner">showBanner</a></li></ul></li><li><a href="module-utils_browserPatch.html">utils/browserPatch</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_browserPatch.html#.applyHumanizationPatch">applyHumanizationPatch</a></li></ul></li><li><a href="module-utils_circuit-breaker.html">utils/circuit-breaker</a></li><li><a href="module-utils_config-cache.html">utils/config-cache</a></li><li><a href="module-utils_config-service.html">utils/config-service</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_config-service.html#~applyEnvOverrides">applyEnvOverrides</a></li><li data-type='method' style='display: none;'><a href="module-utils_config-service.html#~getFromEnvOrSettings">getFromEnvOrSettings</a></li></ul></li><li><a href="module-utils_config-validator.html">utils/config-validator</a></li><li><a href="module-utils_configLoader.html">utils/configLoader</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_configLoader.html#.getBrowserAPI">getBrowserAPI</a></li><li data-type='method' style='display: none;'><a href="module-utils_configLoader.html#.getSettings">getSettings</a></li><li data-type='method' style='display: none;'><a href="module-utils_configLoader.html#.getTimeoutValue">getTimeoutValue</a></li><li data-type='method' style='display: none;'><a href="module-utils_configLoader.html#.getTimeouts">getTimeouts</a></li></ul></li><li><a href="module-utils_content-depth.html">utils/content-depth</a></li><li><a href="module-utils_dockerLLM.html">utils/dockerLLM</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_dockerLLM.html#.ensureDockerLLM">ensureDockerLLM</a></li><li data-type='method' style='display: none;'><a href="module-utils_dockerLLM.html#~isLocalLLMReady">isLocalLLMReady</a></li><li data-type='method' style='display: none;'><a href="module-utils_dockerLLM.html#~startLocalLLM">startLocalLLM</a></li></ul></li><li><a href="module-utils_engagement-limits.html">utils/engagement-limits</a></li><li><a href="module-utils_entropyController.html">utils/entropyController</a></li><li><a href="module-utils_envLoader.html">utils/envLoader</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_envLoader.html#.getEnv">getEnv</a></li><li data-type='method' style='display: none;'><a href="module-utils_envLoader.html#.getLogLevel">getLogLevel</a></li><li data-type='method' style='display: none;'><a href="module-utils_envLoader.html#.getNodeEnv">getNodeEnv</a></li><li data-type='method' style='display: none;'><a href="module-utils_envLoader.html#.getRequiredEnv">getRequiredEnv</a></li><li data-type='method' style='display: none;'><a href="module-utils_envLoader.html#.isDevelopment">isDevelopment</a></li><li data-type='method' style='display: none;'><a href="module-utils_envLoader.html#.isProduction">isProduction</a></li><li data-type='method' style='display: none;'><a href="module-utils_envLoader.html#.resolveEnvVars">resolveEnvVars</a></li><li data-type='method' style='display: none;'><a href="module-utils_envLoader.html#.resolveEnvVarsInObject">resolveEnvVarsInObject</a></li><li data-type='method' style='display: none;'><a href="module-utils_envLoader.html#.validateRequiredEnvVars">validateRequiredEnvVars</a></li></ul></li><li><a href="module-utils_environment-config.html">utils/environment-config</a></li><li><a href="module-utils_errors.html">utils/errors</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_errors.html#.classifyHttpError">classifyHttpError</a></li><li data-type='method' style='display: none;'><a href="module-utils_errors.html#.wrapError">wrapError</a></li></ul></li><li><a href="module-utils_free-api-router.html">utils/free-api-router</a></li><li><a href="module-utils_free-openrouter-helper.html">utils/free-openrouter-helper</a></li><li><a href="module-utils_global-scroll-controller.html">utils/global-scroll-controller</a></li><li><a href="module-utils_human-interaction.html">utils/human-interaction</a></li><li><a href="module-utils_human-timing.html">utils/human-timing</a></li><li><a href="module-utils_local-ollama-manager.html">utils/local-ollama-manager</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_local-ollama-manager.html#.ensureOllama">ensureOllama</a></li><li data-type='method' style='display: none;'><a href="module-utils_local-ollama-manager.html#.isOllamaRunning">isOllamaRunning</a></li><li data-type='method' style='display: none;'><a href="module-utils_local-ollama-manager.html#.startOllama">startOllama</a></li><li data-type='method' style='display: none;'><a href="module-utils_local-ollama-manager.html#~doesModelExist">doesModelExist</a></li><li data-type='method' style='display: none;'><a href="module-utils_local-ollama-manager.html#~isOllamaProcessRunning">isOllamaProcessRunning</a></li></ul></li><li><a href="module-utils_logger.html">utils/logger</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_logger.html#.createBufferedLogger">createBufferedLogger</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger.html#.createLogger">createLogger</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger.html#~initLogFile">initLogFile</a></li><li data-type='method' style='display: none;'><a href="module-utils_logger.html#~writeToLogFile">writeToLogFile</a></li></ul></li><li><a href="module-utils_metrics.html">utils/metrics</a></li><li><a href="module-utils_micro-interactions.html">utils/micro-interactions</a></li><li><a href="module-utils_mistake-engine.html">utils/mistake-engine</a></li><li><a href="module-utils_model-perf-tracker.html">utils/model-perf-tracker</a></li><li><a href="module-utils_motor-control.html">utils/motor-control</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_motor-control.html#~getXSelectors">getXSelectors</a></li><li data-type='method' style='display: none;'><a href="module-utils_motor-control.html#~smartSelector">smartSelector</a></li></ul></li><li><a href="module-utils_navigation-diversity.html">utils/navigation-diversity</a></li><li><a href="module-utils_proxy-agent.html">utils/proxy-agent</a></li><li><a href="module-utils_randomScrolling.html">utils/randomScrolling</a></li><li><a href="module-utils_randomZoom.html">utils/randomZoom</a></li><li><a href="module-utils_rate-limit-tracker.html">utils/rate-limit-tracker</a></li><li><a href="module-utils_request-dedupe.html">utils/request-dedupe</a></li><li><a href="module-utils_retry.html">utils/retry</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_retry.html#.withRetry">withRetry</a></li></ul></li><li><a href="module-utils_scroll-helper.html">utils/scroll-helper</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_scroll-helper.html#.getScrollMultiplier">getScrollMultiplier</a></li><li data-type='method' style='display: none;'><a href="module-utils_scroll-helper.html#.scroll">scroll</a></li><li data-type='method' style='display: none;'><a href="module-utils_scroll-helper.html#.scrollDown">scrollDown</a></li><li data-type='method' style='display: none;'><a href="module-utils_scroll-helper.html#.scrollRandom">scrollRandom</a></li><li data-type='method' style='display: none;'><a href="module-utils_scroll-helper.html#.scrollToBottom">scrollToBottom</a></li><li data-type='method' style='display: none;'><a href="module-utils_scroll-helper.html#.scrollToTop">scrollToTop</a></li><li data-type='method' style='display: none;'><a href="module-utils_scroll-helper.html#.scrollUp">scrollUp</a></li><li data-type='method' style='display: none;'><a href="module-utils_scroll-helper.html#.scrollWheel">scrollWheel</a></li></ul></li><li><a href="module-utils_scroll-humanizer.html">utils/scroll-humanizer</a></li><li><a href="module-utils_sentiment-analyzer-multi.html">utils/sentiment-analyzer-multi</a></li><li><a href="module-utils_sentiment-analyzers.html">utils/sentiment-analyzers</a></li><li><a href="module-utils_sentiment-data.html">utils/sentiment-data</a></li><li><a href="module-utils_sentiment-decision-engine.html">utils/sentiment-decision-engine</a></li><li><a href="module-utils_sentiment-guard.html">utils/sentiment-guard</a></li><li><a href="module-utils_sentiment-integration.html">utils/sentiment-integration</a></li><li><a href="module-utils_sentiment-service.html">utils/sentiment-service</a></li><li><a href="module-utils_session-phases.html">utils/session-phases</a></li><li><a href="module-utils_task-config-loader.html">utils/task-config-loader</a></li><li><a href="module-utils_temporal-awareness.html">utils/temporal-awareness</a></li><li><a href="module-utils_twitter-interaction-methods.html">utils/twitter-interaction-methods</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_twitter-interaction-methods.html#.executeQuoteMethod">executeQuoteMethod</a></li><li data-type='method' style='display: none;'><a href="module-utils_twitter-interaction-methods.html#.executeReplyMethod">executeReplyMethod</a></li></ul></li><li><a href="module-utils_twitter-reply-prompt.html">utils/twitter-reply-prompt</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_twitter-reply-prompt.html#.buildEnhancedPrompt">buildEnhancedPrompt</a></li><li data-type='method' style='display: none;'><a href="module-utils_twitter-reply-prompt.html#.getStrategyInstruction">getStrategyInstruction</a></li></ul></li><li><a href="module-utils_urlReferrerGenerator.html">utils/urlReferrerGenerator</a></li><li><a href="module-utils_utils.html">utils/utils</a></li><li><a href="module-utils_validator.html">utils/validator</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-utils_validator.html#.validateApiResponse">validateApiResponse</a></li><li data-type='method' style='display: none;'><a href="module-utils_validator.html#.validateBrowserConnection">validateBrowserConnection</a></li><li data-type='method' style='display: none;'><a href="module-utils_validator.html#.validatePayload">validatePayload</a></li><li data-type='method' style='display: none;'><a href="module-utils_validator.html#.validateTaskExecution">validateTaskExecution</a></li><li data-type='method' style='display: none;'><a href="module-utils_validator.html#~convertSchemaToZod">convertSchemaToZod</a></li></ul></li><li><a href="tasks_twitterActivity.html#.module:js">tasks/twitterActivity.js</a><ul class='methods'><li data-type='method' style='display: none;'><a href="tasks_twitterActivity.html#.module:js#~applyHumanizationPatch">applyHumanizationPatch</a></li></ul></li><li><a href="tasks_twitterFollow.html#.module:js">tasks/twitterFollow.js</a><ul class='methods'><li data-type='method' style='display: none;'><a href="tasks_twitterFollow.html#.module:js#~applyHumanizationPatch">applyHumanizationPatch</a></li></ul></li><li><a href="tasks_twitterFollowLikeRetweet.html#.module:js">tasks/twitterFollowLikeRetweet.js</a><ul class='methods'><li data-type='method' style='display: none;'><a href="tasks_twitterFollowLikeRetweet.html#.module:js#~applyHumanizationPatch">applyHumanizationPatch</a></li></ul></li><li><a href="tasks_twitterTweet.html#.module:js">tasks/twitterTweet.js</a><ul class='methods'><li data-type='method' style='display: none;'><a href="tasks_twitterTweet.html#.module:js#~applyHumanizationPatch">applyHumanizationPatch</a></li></ul></li><li><a href="tests_integration_agent-connector-health.module_test.html">tests/integration/agent-connector-health.test</a></li><li><a href="tests_integration_agent-connector.module_test.html">tests/integration/agent-connector.test</a></li><li><a href="tests_integration_circuit-breaker.module_test.html">tests/integration/circuit-breaker.test</a></li><li><a href="tests_integration_cloud-client.module_test.html">tests/integration/cloud-client.test</a></li><li><a href="tests_integration_profile-manager.module_test.html">tests/integration/profile-manager.test</a></li><li><a href="tests_integration_request-queue.module_test.html">tests/integration/request-queue.test</a></li><li><a href="tests_integration_task-config-loader.module_test.html">tests/integration/task-config-loader.test</a></li><li><a href="tests_test-multiline-tweet.module_js.html">tests/test-multiline-tweet.js</a></li><li><a href="tests_unit_ai-twitter-activity.module_test.html">tests/unit/ai-twitter-activity.test</a></li><li><a href="tests_unit_ai-twitterAgent.module_test.html">tests/unit/ai-twitterAgent.test</a></li><li><a href="tests_unit_ai-twitterAgent.real.module_test.html">tests/unit/ai-twitterAgent.real.test</a></li><li><a href="tests_unit_apiHandler.module_test.html">tests/unit/apiHandler.test</a></li><li><a href="tests_unit_async-queue.module_test.html">tests/unit/async-queue.test</a></li><li><a href="tests_unit_banner.module_test.html">tests/unit/banner.test</a></li><li><a href="tests_unit_circuit-breaker.module_test.html">tests/unit/circuit-breaker.test</a></li><li><a href="tests_unit_config-service.module_test.html">tests/unit/config-service.test</a></li><li><a href="tests_unit_discovery.module_test.html">tests/unit/discovery.test</a></li><li><a href="tests_unit_dockerLLM.module_test.html">tests/unit/dockerLLM.test</a></li><li><a href="tests_unit_engagement-limits.module_test.html">tests/unit/engagement-limits.test</a></li><li><a href="tests_unit_envLoader.module_test.html">tests/unit/envLoader.test</a></li><li><a href="tests_unit_global-scroll-controller.module_test.html">tests/unit/global-scroll-controller.test</a></li><li><a href="tests_unit_human-interaction.module_test.html">tests/unit/human-interaction.test</a></li><li><a href="tests_unit_humanization-utils.module_test.html">tests/unit/humanization-utils.test</a></li><li><a href="tests_unit_ixbrowser.module_test.html">tests/unit/ixbrowser.test</a></li><li><a href="tests_unit_logging-config.module_test.html">tests/unit/logging-config.test</a></li><li><a href="tests_unit_request-queue.module_test.html">tests/unit/request-queue.test</a></li><li><a href="tests_unit_retry.module_test.html">tests/unit/retry.test</a></li><li><a href="tests_unit_roxybrowser.module_test.html">tests/unit/roxybrowser.test</a></li><li><a href="tests_unit_scroll-helper.module_test.html">tests/unit/scroll-helper.test</a></li><li><a href="tests_unit_session-manager.module_test.html">tests/unit/session-manager.test</a></li><li><a href="tests_unit_validator.module_test.html">tests/unit/validator.test</a></li><li><a href="tools_composeTweet.module_js.html">tools/composeTweet.js</a><ul class='methods'><li data-type='method' style='display: none;'><a href="tools_composeTweet.module_js.html#~composeTweet">composeTweet</a></li><li data-type='method' style='display: none;'><a href="tools_composeTweet.module_js.html#~main">main</a></li><li data-type='method' style='display: none;'><a href="tools_composeTweet.module_js.html#~showQueueStatus">showQueueStatus</a></li><li data-type='method' style='display: none;'><a href="tools_composeTweet.module_js.html#~viewQueue">viewQueue</a></li></ul></li><li><a href="utils_config-manager%250D%250DThis%2520is%2520a%2520NEW%2520module%2520for%2520Phase%25202%2520improvements.%2520It%2520does%2520not%2520replace%2520existing%2520config%2520loaders%250Dbut%2520provides%2520a%2520more%2520robust%2520alternative%2520for%2520new%2520code.module_.html">utils/config-managerThis is a NEW module for Phase 2 improvements. It does not replace existing config loadersbut provides a more robust alternative for new code.</a></li></ul><h3>Global</h3><ul><li><a href="global.html#configDrivenReply">configDrivenReply</a></li><li><a href="global.html#ensureProfilesLoaded">ensureProfilesLoaded</a></li><li><a href="global.html#estimateConversationTokens">estimateConversationTokens</a></li><li><a href="global.html#estimateMessageTokens">estimateMessageTokens</a></li><li><a href="global.html#estimateTokens">estimateTokens</a></li><li><a href="global.html#formatEngagementLine">formatEngagementLine</a></li><li><a href="global.html#formatEngagementSummary">formatEngagementSummary</a></li><li><a href="global.html#generateProfiles">generateProfiles</a></li><li><a href="global.html#generateProgressBar">generateProgressBar</a></li><li><a href="global.html#getDefaultLoggingConfig">getDefaultLoggingConfig</a></li><li><a href="global.html#getLoggingConfig">getLoggingConfig</a></li><li><a href="global.html#loadProfiles">loadProfiles</a></li><li><a href="global.html#mathUtils">mathUtils</a></li><li><a href="global.html#postQuoteWithMethod">postQuoteWithMethod</a></li><li><a href="global.html#postReplyRandom">postReplyRandom</a></li><li><a href="global.html#postReplyWithFallback">postReplyWithFallback</a></li><li><a href="global.html#postReplyWithMethod">postReplyWithMethod</a></li><li><a href="global.html#resetLoggingConfig">resetLoggingConfig</a></li><li><a href="global.html#runAllEdgeCaseTests">runAllEdgeCaseTests</a></li><li><a href="global.html#runAllIntegrationTests">runAllIntegrationTests</a></li><li><a href="global.html#runAllTests">runAllTests</a></li><li><a href="global.html#runAllUnitTests">runAllUnitTests</a></li><li><a href="global.html#smartReply">smartReply</a></li><li><a href="global.html#takeScreenshot">takeScreenshot</a></li><li><a href="global.html#testStats">testStats</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">utils/ai-twitterAgent.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview AI-Enhanced Twitter Agent
 * Extends TwitterAgent with AI reply capability when diving into tweets
 * @module utils/ai-twitterAgent
 */

import { TwitterAgent } from './twitterAgent.js';
import { AIReplyEngine } from './ai-reply-engine.js';
import { AIQuoteEngine } from './ai-quote-engine.js';
import { AIContextEngine } from './ai-context-engine.js';
import { microInteractions } from './micro-interactions.js';
import { motorControl } from './motor-control.js';
import AgentConnector from '../core/agent-connector.js';
import { mathUtils } from './mathUtils.js';
import { entropy } from './entropyController.js';
import { engagementLimits } from './engagement-limits.js';
import { sessionPhases } from './session-phases.js';
import { sentimentService } from './sentiment-service.js';
import { buildEnhancedPrompt } from './twitter-reply-prompt.js';
import { scrollDown, scrollUp, scrollRandom } from './scroll-helper.js';
import { config } from './config-service.js';
import { DiveQueue } from './async-queue.js';
import { AIReplyAction } from './actions/ai-twitter-reply.js';
import { AIQuoteAction } from './actions/ai-twitter-quote.js';
import { LikeAction } from './actions/ai-twitter-like.js';
import { BookmarkAction } from './actions/ai-twitter-bookmark.js';
import { GoHomeAction } from './actions/ai-twitter-go-home.js';
import { ActionRunner } from './actions/index.js';
import { TWITTER_TIMEOUTS } from '../constants/twitter-timeouts.js';
import { HumanInteraction } from './human-interaction.js';
import { createBufferedLogger } from './logger.js';

/**
 * @deprecated Use config.getEngagementLimits() instead (supports env overrides)
 */
const DEFAULT_ENGAGEMENT_LIMITS = {
    replies: 3,
    retweets: 1,
    quotes: 1,
    likes: 5,
    follows: 2,
    bookmarks: 2
};

/**
 * Page states for diving operation control
 */
const PAGE_STATE = {
    HOME: 'HOME',                    // Home feed page
    DIVING: 'DIVING',               // Currently diving into a tweet
    TWEET_PAGE: 'TWEET_PAGE',       // Viewing a tweet page
    RETURNING: 'RETURNING'           // Returning from tweet to home
};

export class AITwitterAgent extends TwitterAgent {
    constructor(page, initialProfile, logger, options = {}) {
        super(page, initialProfile, logger);

        // Store full twitter config for action handlers (separate from profile config)
        this.twitterConfig = options.config || {};

        // ================================================================
        // DIVE LOCK MECHANISM - Prevents scroller interference
        // ================================================================
        this.pageState = PAGE_STATE.HOME;      // Current page state
        this.scrollingEnabled = true;           // Scrolling allowed flag
        this.operationLock = false;              // Operation in progress flag
        this.diveLockAcquired = false;           // Dive operation lock
        this.homeUrl = 'https://x.com/home';    // Home page URL

        // Log buffering for wait messages (prevent log spam)
        this.lastWaitLogTime = 0;               // Timestamp of last wait log
        this.waitLogInterval = 10000;           // Log wait messages every 10s

        // Initialize DiveQueue for race-condition-free tweet dives
        // Force sequential processing (maxConcurrent: 1) to prevent overlapping dives
        this.diveQueue = new DiveQueue({
            maxConcurrent: 1,
            maxQueueSize: 30,
            defaultTimeout: 20000,
            fallbackEngagement: false, // Disable autonomous fallbacks during AI dives
            replies: options.engagementLimits?.replies ?? 3,
            retweets: options.engagementLimits?.retweets ?? 1,
            quotes: options.engagementLimits?.quotes ?? 1,
            likes: options.engagementLimits?.likes ?? 5,
            follows: options.engagementLimits?.follows ?? 2,
            bookmarks: options.engagementLimits?.bookmarks ?? 2
        });

        // Quick mode flag for timeout scenarios
        this.quickModeEnabled = false;

        // Initialize AgentConnector for AI requests
        this.agentConnector = new AgentConnector();

        // Initialize AI Reply Engine with AgentConnector
        // Values come from config/settings.json  ai-twitterActivity.js  here
        this.replyEngine = new AIReplyEngine(this.agentConnector, {
            replyProbability: options.replyProbability ?? 0.50, // Default from settings.json
            maxRetries: options.maxRetries ?? 2
        });

        // Initialize AI Quote Engine with AgentConnector
        // Values come from config/settings.json  ai-twitterActivity.js  here
        this.quoteEngine = new AIQuoteEngine(this.agentConnector, {
            quoteProbability: options.quoteProbability ?? 0.50, // Default from settings.json
            maxRetries: options.maxRetries ?? 2
        });

        // Initialize Enhanced Context Engine for better AI replies
        this.contextEngine = new AIContextEngine({
            maxReplies: 30,
            sentimentThreshold: 0.3,
            includeMetrics: true
        });

        this.aiStats = {
            attempts: 0,
            replies: 0,
            skips: 0,
            safetyBlocks: 0,
            errors: 0
        };

        // Initialize engagement limits tracker
        const customLimits = options.engagementLimits || DEFAULT_ENGAGEMENT_LIMITS;
        this.engagementTracker = engagementLimits.createEngagementTracker(customLimits);

        // ================================================================
        // ENGAGEMENT TRACKER SYNCHRONIZATION
        // Override engagementTracker methods to delegate to DiveQueue
        // This ensures both systems use the same counters to prevent over-engagement
        // ================================================================
        const originalCanPerform = this.engagementTracker.canPerform.bind(this.engagementTracker);
        const originalRecord = this.engagementTracker.record.bind(this.engagementTracker);
        const originalGetProgress = this.engagementTracker.getProgress.bind(this.engagementTracker);
        const originalGetStatus = this.engagementTracker.getStatus.bind(this.engagementTracker);
        const originalGetSummary = this.engagementTracker.getSummary.bind(this.engagementTracker);

        // Override canPerform to check both trackers (conservative - requires both to allow)
        this.engagementTracker.canPerform = (action) => {
            const trackerAllows = originalCanPerform(action);
            const queueAllows = this.diveQueue.canEngage(action);
            return trackerAllows &amp;&amp; queueAllows;
        };

        // Override record to update both systems atomically
        this.engagementTracker.record = (action) => {
            // Only record if both allow it
            if (!originalCanPerform(action) || !this.diveQueue.canEngage(action)) {
                return false;
            }

            // Record in both systems
            const trackerResult = originalRecord(action);
            const queueResult = this.diveQueue.recordEngagement(action);

            // Return true only if both succeeded
            return trackerResult &amp;&amp; queueResult;
        };

        // Override getProgress to combine data from both
        this.engagementTracker.getProgress = (action) => {
            const trackerProgress = originalGetProgress(action);
            const queueProgress = this.diveQueue.getEngagementProgress()[action];

            // Use the more restrictive of the two
            if (queueProgress) {
                return `${queueProgress.current}/${queueProgress.limit}`;
            }
            return trackerProgress;
        };

        // Override getStatus to combine data from both
        this.engagementTracker.getStatus = () => {
            const trackerStatus = originalGetStatus();
            const queueProgress = this.diveQueue.getEngagementProgress();

            // Merge statuses, using DiveQueue data where available
            const mergedStatus = { ...trackerStatus };
            for (const [action, data] of Object.entries(queueProgress)) {
                if (mergedStatus[action]) {
                    mergedStatus[action].current = data.current;
                    mergedStatus[action].limit = data.limit;
                    mergedStatus[action].remaining = data.remaining;
                    mergedStatus[action].percentage = data.percentUsed + '%';
                }
            }
            return mergedStatus;
        };

        // Override getSummary to use DiveQueue data
        this.engagementTracker.getSummary = () => {
            const queueProgress = this.diveQueue.getEngagementProgress();
            const summary = [];
            for (const [action, data] of Object.entries(queueProgress)) {
                if (data.limit !== Infinity &amp;&amp; data.limit > 0) {
                    summary.push(`${action}: ${data.current}/${data.limit}`);
                }
            }
            return summary.join(', ') || originalGetSummary();
        };

        // Initialize Micro-Interactions handler
        this.microHandler = microInteractions.createMicroInteractionHandler({
            highlightChance: 0.03,
            rightClickChance: 0.02,
            logoClickChance: 0.05,
            whitespaceClickChance: 0.04,
            fidgetChance: 0.08,
            fidgetInterval: { min: 15000, max: 45000 }
        });

        // Initialize Motor Control handler
        this.motorHandler = motorControl.createMotorController({
            layoutShiftThreshold: 5,
            spiralSearchAttempts: 4,
            retryDelay: 100,
            maxRetries: 3,
            targetTimeout: 5000
        });

        // Session phase tracking
        this.sessionStart = Date.now();
        this.sessionDuration = 0;
        this.currentPhase = 'warmup';
        this.lastPhaseLogged = null;

        // Track processed tweets to avoid re-diving
        this._processedTweetIds = new Set();

        // Scroll tracking for exploration (fixes: re-diving same area, insufficient scroll)
        this._lastScrollY = 0;
        this._lastScrollTime = 0;
        this._minScrollPerDive = 400;  // Minimum pixels to scroll before diving
        this._scrollExplorationThreshold = 600;  // Exploration scroll distance

        // Initialize Action Handlers (stateful per browser instance)
        const actionInstances = {
            reply: new AIReplyAction(this),
            quote: new AIQuoteAction(this),
            like: new LikeAction(this),
            bookmark: new BookmarkAction(this),
            goHome: new GoHomeAction(this)
        };

        // Initialize Action Runner for smart probability redistribution
        this.actionRunner = new ActionRunner(this, actionInstances);

        // Keep individual actions accessible
        this.actions = actionInstances;

        // Initialize HumanInteraction for fallback methods
        this.humanInteraction = new HumanInteraction(page);

        // Initialize BufferedLogger for high-frequency logs
        this.queueLogger = createBufferedLogger('QueueMonitor', {
            flushInterval: 10000,  // Flush every 10 seconds
            maxBufferSize: 50,      // Max 50 entries before flush
            groupByLevel: true
        });

        this.engagementLogger = createBufferedLogger('EngagementTracker', {
            flushInterval: 30000,  // Flush every 30 seconds
            maxBufferSize: 20,
            groupByLevel: true
        });

        this.log(`[AITwitterAgent] Initialized (replyProbability: ${this.replyEngine.config.REPLY_PROBABILITY})`);
        this.log(`[AITwitterAgent] Engagement limits: ${this.engagementTracker.getSummary()}`);
        this.log(`[AITwitterAgent] Session phases: warmup(0-10%)  active(10-80%)  cooldown(80-100%)`);
        this.log(`[DiveLock] State management initialized: HOME (scrolling enabled)`);
        this.log(`[AITwitterAgent] Action handlers initialized: reply, quote, like, bookmark, goHome`);
    }

    // ================================================================
    // DIVE LOCK MECHANISM - State Management Methods
    // ================================================================

    /**
     * Start dive operation - acquires lock and disables scrolling
     * Prevents scroller interference during tweet diving
     */
    async startDive() {
        // Wait for any ongoing operations to complete
        let firstWait = true;
        while (this.operationLock) {
            const now = Date.now();

            // Only log every 10 seconds to prevent log spam
            if (firstWait || now - this.lastWaitLogTime >= this.waitLogInterval) {
                this.log(`[DiveLock]  Waiting for existing operation to complete... (${((now - this.lastWaitLogTime) / 1000).toFixed(0)}s since last check)`);
                this.lastWaitLogTime = now;
                firstWait = false;
            }

            await new Promise(resolve => setTimeout(resolve, 100));
        }

        // Acquire operation lock
        this.operationLock = true;
        this.diveLockAcquired = true;
        this.pageState = PAGE_STATE.DIVING;
        this.scrollingEnabled = false;
        this.lastWaitLogTime = 0;  // Reset wait log timestamp

        this.log(`[DiveLock]  Dive operation started - scrolling disabled (state: ${this.pageState})`);
        return true;
    }

    /**
     * End dive operation - releases lock and optionally returns to home
     * @param {boolean} success - Whether the dive was successful
     * @param {boolean} returnHome - Whether to return to home page
     */
    async endDive(success = true, returnHome = false) {
        if (returnHome) {
            this.pageState = PAGE_STATE.RETURNING;
            this.scrollingEnabled = false;

            try {
                // Navigate back to home
                await this._safeNavigateHome();
                // Reduced wait - let simulateReading() handle actual reading delay
                await this.page.waitForTimeout(500);

                // Verify we're on home page
                const currentUrl = this.page.url();
                if (currentUrl.includes('/home') || currentUrl === 'https://x.com/') {
                    this.log(`[DiveLock]  Successfully returned to home`);
                }
            } catch (error) {
                this.log(`[DiveLock] Warning: Failed to return to home: ${error.message}`);
            }

            // Reset to home state
            this.pageState = PAGE_STATE.HOME;
            this.scrollingEnabled = true;
        } else {
            // Just update state based on success
            this.pageState = success ? PAGE_STATE.TWEET_PAGE : PAGE_STATE.HOME;
        }

        // Release operation lock
        this.operationLock = false;
        this.diveLockAcquired = false;
        
        // Always re-enable scrolling when dive ends
        this.scrollingEnabled = true;

        this.log(`[DiveLock]  Dive operation ended (success: ${success}, state: ${this.pageState})`);
    }

    /**
     * Check if currently diving (operation in progress)
     */
    isDiving() {
        return this.operationLock &amp;&amp; this.pageState === PAGE_STATE.DIVING;
    }

    /**
     * Check if currently on tweet page
     */
    isOnTweetPage() {
        const url = this.page.url();
        return url.includes('/status/') || this.pageState === PAGE_STATE.TWEET_PAGE;
    }

    /**
     * Check if scrolling is allowed
     */
    canScroll() {
        return this.scrollingEnabled &amp;&amp; !this.operationLock;
    }

    /**
     * Get current page state
     */
    getPageState() {
        return {
            state: this.pageState,
            scrollingEnabled: this.scrollingEnabled,
            operationLock: this.operationLock,
            url: this.page.url()
        };
    }

    /**
     * Log current dive status
     */
    logDiveStatus() {
        const status = this.getPageState();
        this.log(`[DiveStatus] State: ${status.state}, Scrolling: ${status.scrollingEnabled}, Lock: ${status.operationLock}, URL: ${status.url}`);
    }

    /**
     * Safe navigation to home page
     */
    async _safeNavigateHome() {
        try {
            const currentUrl = this.page.url();
            if (currentUrl.includes('/home') || currentUrl === 'https://x.com/') {
                this.log('[DiveLock] Already on home page');
                return true;
            }

            // Use keyboard navigation first (Escape to close composer if open)
            await this.page.keyboard.press('Escape');
            await this.page.waitForTimeout(500);

            // Try to navigate to home
            await this.navigateHome();
            return true;
        } catch (error) {
            this.log(`[DiveLock] Navigation error: ${error.message}`);
            // Fallback: direct navigation
            try {
                await this.page.goto('https://x.com/home', { waitUntil: 'domcontentloaded', timeout: TWITTER_TIMEOUTS.NAVIGATION });
                return true;
            } catch (e) {
                this.log(`[DiveLock] Fallback navigation failed: ${e.message}`);
                return false;
            }
        }
    }

    /**
     * Wait for dive operation to complete
     */
    async waitForDiveComplete() {
        while (this.operationLock) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }

    /**
     * Check if session should continue (respecting dive operations)
     */
    shouldContinueSession() {
        if (this.operationLock) {
            this.log('[Session] Waiting for diving operation to complete...');
            return false;
        }
        return true;
    }

    /**
     * Perform idle cursor movement when scrolling is disabled
     * Maintains human-like behavior during dive operations
     */
    async performIdleCursorMovement() {
        try {
            const viewport = this.page.viewportSize() || { width: 1280, height: 720 };

            // Small random cursor movements for human-like behavior
            for (let i = 0; i &lt; 3; i++) {
                const x = Math.random() * (viewport.width - 200) + 100;
                const y = Math.random() * (viewport.height - 200) + 100;
                await this.page.mouse.move(x, y);
                await this.page.waitForTimeout(Math.random() * 1000 + 500);
            }
        } catch (error) {
            // Silent fail - cursor movement is optional
        }
    }

    /**
     * Debug logging - only logs when debug mode is enabled
     * @param {string} message - Message to log
     */
    logDebug(message) {
        this.log(`[DEBUG] ${message}`);
    }

    logWarn(message) {
        this.log(`[WARN] ${message}`);
    }

    /**
     * Update session phase based on elapsed time
     * Call this periodically during session
     */
    updateSessionPhase() {
        this.sessionDuration = Date.now() - this.sessionStart;
        const newPhase = sessionPhases.getSessionPhase(this.sessionDuration, this.sessionDuration * 1.25);

        if (newPhase !== this.currentPhase) {
            const phaseInfo = sessionPhases.getPhaseStats(newPhase);
            this.log(`[Phase] Transition: ${this.currentPhase}  ${newPhase} (${phaseInfo.description})`);
            this.currentPhase = newPhase;
        }

        return this.currentPhase;
    }

    /**
     * Get phase-modified probability for an action
     * Applies session phase modifiers to base probabilities
     */
    getPhaseModifiedProbability(action, baseProbability) {
        this.updateSessionPhase();
        const modifier = sessionPhases.getPhaseModifier(action, this.currentPhase);
        const adjusted = baseProbability * modifier;

        if (this.currentPhase !== 'active') {
            this.log(`[PhaseMod] ${action}: ${(baseProbability * 100).toFixed(1)}%  ${modifier.toFixed(2)} = ${(adjusted * 100).toFixed(1)}% (${this.currentPhase})`);
        }

        return adjusted;
    }

    /**
     * Get current session progress percentage
     */
    getSessionProgress() {
        this.sessionDuration = Date.now() - this.sessionStart;
        const estimatedTotal = this.sessionDuration * 1.25;
        return Math.min(100, (this.sessionDuration / estimatedTotal) * 100);
    }

    /**
     * Check if we're in cooldown phase (wind-down behavior)
     */
    isInCooldown() {
        this.updateSessionPhase();
        return this.currentPhase === 'cooldown';
    }

    /**
     * Check if we're in warmup phase (cautious behavior)
     */
    isInWarmup() {
        this.updateSessionPhase();
        return this.currentPhase === 'warmup';
    }

    /**
     * Trigger a micro-interaction during reading/pauses
     * Adds human fidgeting behaviors
     */
    async triggerMicroInteraction(context = 'reading') {
        try {
            const roll = Math.random();
            const actionThreshold = this.microHandler.config.highlightChance
                + this.microHandler.config.rightClickChance
                + this.microHandler.config.logoClickChance
                + this.microHandler.config.whitespaceClickChance;

            if (roll > actionThreshold) {
                this.log(`[Micro] No micro-interaction triggered (${context})`);
                return { success: false, reason: 'probability_skip' };
            }

            const result = await this.microHandler.executeMicroInteraction(this.page, {
                logger: {
                    info: (msg) => this.log(msg),
                    error: (msg) => this.log(`[Micro-Error] ${msg}`)
                }
            });

            if (result.success) {
                this.log(`[Micro] Executed ${result.type} (${context})`);
            }

            return result;
        } catch (error) {
            this.log(`[Micro] Error during micro-interaction: ${error.message}`);
            return { success: false, reason: error.message };
        }
    }

    /**
     * Text highlighting micro-interaction
     * Simulates humans highlighting interesting text
     */
    async highlightText(selector = 'article [data-testid="tweetText"]') {
        return await this.microHandler.textHighlight(this.page, {
            logger: {
                info: (msg) => this.log(msg),
                error: (msg) => this.log(`[Micro-Error] ${msg}`)
            },
            selector
        });
    }

    /**
     * Start background fidget loop during long reads
     */
    startFidgetLoop() {
        return this.microHandler.startFidgetLoop(this.page, {
            logger: {
                info: (msg) => this.log(msg),
                error: (msg) => this.log(`[Micro-Error] ${msg}`)
            }
        });
    }

    /**
     * Stop background fidget loop
     */
    stopFidgetLoop() {
        return this.microHandler.stopFidgetLoop();
    }

    /**
     * Override simulateFidget to use micro-interactions module
     * Replaces parent's TEXT_SELECT/MOUSE_WIGGLE/OVERSHOOT with:
     * - Text highlighting
     * - Random right-click
     * - Logo clicks
     * - Whitespace clicks
     */
    async simulateFidget() {
        try {
            const result = await this.microHandler.executeMicroInteraction(this.page, {
                logger: {
                    info: (msg) => this.log(msg.replace('[Micro]', '[Fidget]')),
                    error: (msg) => this.log(`[Fidget-Error] ${msg}`)
                }
            });

            if (!result.success) {
                // Commented out - too noisy
                // this.log(`[Fidget] Skipped: ${result.reason || 'no action'}`);
            }
        } catch (error) {
            this.log(`[Fidget] Error: ${error.message}`);
        }
    }

    /**
     * Smart Click using motor control
     * Uses continuous target tracking, overlap protection, and spiral recovery
     */
    async smartClick(context, options = {}) {
        const {
            verifySelector = null,
            timeout = 5000
        } = options;

        try {
            const result = await this.motorHandler.smartClick(this.page, null, {
                logger: {
                    info: (msg) => this.log(msg),
                    warn: (msg) => this.log(msg),
                    debug: (msg) => this.log(`[Motor-Debug] ${msg}`)
                },
                context,
                verifySelector,
                timeout
            });

            if (result.success) {
                this.log(`[Motor] Smart click: ${context} @ (${Math.round(result.x)}, ${Math.round(result.y)}${result.recovered ? ', recovered' : ''}${result.usedFallback ? ', fallback' : ''})`);
            } else {
                this.log(`[Motor] Smart click failed: ${result.reason}`);
            }

            return result;
        } catch (error) {
            this.log(`[Motor] Error: ${error.message}`);
            return { success: false, reason: error.message };
        }
    }

    /**
     * Click with smart selector fallback and verification
     */
    async smartClickElement(selector, fallbacks = [], options = {}) {
        const {
            verifySelector = null,
            verifyTimeout = 500
        } = options;

        try {
            const result = await this.motorHandler.smartClick(this.page, { primary: selector, fallbacks }, {
                logger: {
                    info: (msg) => this.log(msg),
                    warn: (msg) => this.log(msg),
                    debug: (msg) => this.log(`[Motor-Debug] ${msg}`)
                },
                verifySelector,
                verifyTimeout
            });

            if (result.success) {
                this.log(`[Motor] Clicked: ${result.selector} @ (${Math.round(result.x)}, ${Math.round(result.y)}${result.recovered ? ', recovered' : ''})`);
            }

            return result;
        } catch (error) {
            this.log(`[Motor] Click error: ${error.message}`);
            return { success: false, reason: error.message };
        }
    }

    /**
     * Override diveTweet to use split-phase processing
     * Phase 1: Scan (Find &amp; Extract) - Locked by simple boolean
     * Phase 2: Process (AI &amp; Action) - Locked by DiveQueue (Timeout monitored)
     */
    async diveTweet() {
        const diveId = `dive_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
        
        // PHASE 1: SCANNING (Quick, no heavy timeout needed)
        // --------------------------------------------------
        if (this.isScanning) {
            this.log(`[DiveLock]  Scan already in progress, skipping ${diveId}`);
            return false;
        }

        this.isScanning = true;
        
        try {
            this.log(`[DiveLock]  Starting SCAN phase for ${diveId}`);
            
            // Execute the dive logic. 
            // We pass a callback that wraps ONLY the AI/Action part in the heavy DiveQueue.
            // The rest of the function (scrolling, extracting) runs immediately.
            return await this._diveTweetWithAI(async (aiTask) => {
                 this.log(`[DiveQueue]  Entering AI Processing Queue for ${diveId}`);
                 return await this.diveQueue.addDive(
                    aiTask,
                    null, // No fallback for now
                    {
                        taskName: diveId,
                        timeout: TWITTER_TIMEOUTS.DIVE_TIMEOUT, // 120s timeout applies ONLY here
                        priority: 10
                    }
                );
            });

        } catch (error) {
            this.log(`[DiveLock]  Error in diveTweet: ${error.message}`);
            return false;
        } finally {
            this.isScanning = false;
            // Note: _diveTweetWithAI handles endDive() internally, 
            // but we ensure cleanup if something crashed before that.
            if (this.diveLockAcquired) {
                 await this.endDive(false, true);
            }
        }
    }

    /**
     * Internal method: diveTweet with AI reply (original logic)
     * Now includes dive locking to prevent scroller interference
     * @param {Function} queueWrapper - Optional wrapper for the AI execution phase
     */
    async _diveTweetWithAI(queueWrapper = null) {
        try {
            // ================================================================
            // ACQUIRE DIVE LOCK - Prevents scroller interference
            // ================================================================
            await this.startDive();

            // ENSURE EXPLORATION SCROLL - Prevent re-diving same area
            await this._ensureExplorationScroll();

            let targetTweet = null;

            // Find suitable tweet with increased scroll distance
            for (let attempt = 0; attempt &lt; 3; attempt++) {
                const tweets = this.page.locator('article[data-testid="tweet"]');
                const count = await tweets.count();

                if (count > 0) {
                    for (let i = 0; i &lt; Math.min(count, 10); i++) {
                        const t = tweets.nth(i);
                        const box = await t.boundingBox();
                        // Extended viewport range to catch more tweets
                        if (box &amp;&amp; box.height > 0 &amp;&amp; box.y > -100 &amp;&amp; box.y &lt; 1200) {
                            targetTweet = t;
                            // Reduced early break probability (0.4 -> 0.2) for more exploration
                            if (Math.random() > 0.2) break;
                        }
                    }
                }

                if (targetTweet) break;

                this.log('[Dive] No suitable tweets. Scrolling...');
                // Increased scroll distance (300 -> 600) with variance for natural behavior
                const variance = 0.85 + Math.random() * 0.3;
                const scrollAmount = Math.floor(600 * variance);
                await scrollDown(this.page, scrollAmount);
                await this.page.waitForTimeout(entropy.retryDelay(attempt));

                // Update scroll tracking
                this._lastScrollY = await this.page.evaluate(() => window.scrollY);
                this._lastScrollTime = Date.now();
            }

            if (!targetTweet) {
                this.log('[Dive] No suitable tweets found. Refreshing Home...');
                await this.page.goto('https://x.com/');
                await this.ensureForYouTab();
                // Release lock before returning
                await this.endDive(false, true);
                return;
            }

            // Get username from tweet for URL construction
            let username = 'unknown';
            try {
                const tweetTextEl = targetTweet.locator('[data-testid="tweetText"]').first();
                if (await tweetTextEl.count() > 0) {
                    const parent = await tweetTextEl.$x('..');
                    if (parent &amp;&amp; parent[0]) {
                        const link = await parent[0].$('a[href*="/"]');
                        if (link) {
                            const href = await link.getAttribute('href');
                            username = href?.replace(/^\/|\/$/g, '') || 'unknown';
                        }
                    }
                }
            } catch (e) {
                username = 'unknown';
            }

            // Determine click target
            let clickTarget = null;
            const timeStamp = targetTweet.locator('time').first();

            const tweetTextEl = targetTweet.locator('[data-testid="tweetText"]').first();

            if (await tweetTextEl.count() > 0 &amp;&amp; await tweetTextEl.isVisible()) {
                clickTarget = tweetTextEl;
                this.log('[Debug] Targeting tweet text body (Primary).');
            } else if (await timeStamp.count() > 0 &amp;&amp; await timeStamp.isVisible()) {
                const parentLink = timeStamp.locator('xpath=./ancestor::a[1]');
                clickTarget = (await parentLink.count() > 0) ? parentLink : timeStamp;
                this.log('[Debug] Targeting tweet permalink/time (Fallback).');
            } else {
                clickTarget = targetTweet;
                this.log('[Debug] Targeting entire tweet card (Last Resort).');
            }

            if (clickTarget) {
                await clickTarget.evaluate(el => el.scrollIntoView({ block: 'center', inline: 'center' }));
                await this.page.waitForTimeout(entropy.scrollSettleTime());

                const dbgBox = await clickTarget.boundingBox();
                this.log(`[Debug] Target: Box=${dbgBox ? `x:${Math.round(dbgBox.x)},y:${Math.round(dbgBox.y)}` : 'null'}`);

                this.log('[Attempt] Ghost Click on Permalink...');
                await this.humanClick(clickTarget, 'Tweet Permalink');
            }

            // Wait for navigation to tweet page
            let tweetUrl = '';
            let expanded = false;
            try {
                // Wait for URL to contain /status/
                await this.page.waitForURL('**/status/**', { timeout: TWITTER_TIMEOUTS.NAVIGATION });
                tweetUrl = this.page.url();
                this.log('[Success] Navigated to tweet page.');
                this.log(`[Debug] Tweet URL: ${tweetUrl}`);
                expanded = true;
            } catch (e) {
                this.log('[Fail] Ghost Click did not navigate. Retrying with NATIVE click...');
                if (clickTarget) {
                    await clickTarget.click({ force: true });
                }
                try {
                    await this.page.waitForURL('**/status/**', { timeout: TWITTER_TIMEOUTS.NAVIGATION });
                    tweetUrl = this.page.url();
                    this.log('[Success] Native Click navigated to tweet.');
                    expanded = true;
                } catch (e2) {
                    this.log('[Fail] Failed to expand tweet. Aborting dive.');
                    // Release lock before returning
                    await this.endDive(false, true);
                    return;
                }
            }

            if (!expanded) {
                await this.endDive(false, true);
                return;
            }

            // Skip if already processed this tweet
            const tweetIdMatch = tweetUrl &amp;&amp; tweetUrl.match(/status\/(\d+)/);
            if (tweetIdMatch) {
                const tweetId = tweetIdMatch[1];
                if (this._processedTweetIds.has(tweetId)) {
                    this.log(`[AI] Already processed tweet ${tweetId}, skipping...`);
                    await this.endDive(true, true);
                    return;
                }
                this._processedTweetIds.add(tweetId);
                this.log(`[AI] Tracking new tweet ${tweetId}`);
            }

            // ================================================================
            // EXTRACT TWEET CONTENT AFTER NAVIGATION (PRIMARY SOURCE)
            // ================================================================
            this.log('[AI] Extracting tweet content from full page...');

            // Wait for tweet content to fully load
            await this.page.waitForSelector('[data-testid="tweetText"]', { timeout: TWITTER_TIMEOUTS.ELEMENT_VISIBLE }).catch(() => { });
            await this.page.waitForTimeout(1000);  // Additional settle time

            // Extract FRESH tweet text AFTER navigation
            let tweetText = '';
            const freshTextEl = this.page.locator('[data-testid="tweetText"]').first();

            if (await freshTextEl.count() > 0) {
                tweetText = await freshTextEl.innerText().catch(() => '');
                this.log(`[AI] Extracted tweet text (${tweetText.length} chars)`);

                if (tweetText.length &lt; 10) {
                    this.log('[AI] Tweet text too short, trying alternative selectors...');
                    // Try alternative selectors
                    const alternatives = [
                        '[data-testid="tweetText"]',
                        '[lang] > div',
                        'article [role="group"]',
                        '.tweet-text'
                    ];

                    for (const selector of alternatives) {
                        const altEl = this.page.locator(selector).first();
                        if (await altEl.count() > 0) {
                            const altText = await altEl.innerText().catch(() => '');
                            if (altText.length > tweetText.length) {
                                tweetText = altText;
                                this.log(`[AI] Found better text (${altText.length} chars) with ${selector}`);
                            }
                        }
                    }
                }
            } else {
                this.log('[AI] WARNING: Could not find tweet text element!');
            }

            // Extract username from page URL
            if (username === 'unknown') {
                try {
                    const url = this.page.url();
                    const match = url &amp;&amp; url.match(/x\.com\/(\w+)\/status/);
                    if (match) username = match[1];
                } catch (e) { }
            }

            // Validate we have tweet text
            if (!tweetText || tweetText.length &lt; 5) {
                this.log('[AI] WARNING: Could not extract valid tweet text. Skipping AI reply.');
                // Still read the page and return normally
                await this._readExpandedTweet();
                await this.endDive(true, true);
                return;
            }

            // ================================================================
            // AI DECISION: Use Action Runner for smart probability redistribution
            // ================================================================
            let selectedAction = null;
            let actionSuccess = false;
            let enhancedContext = {};

            // 1. Select Action (Fast, probability based) - OUTSIDE QUEUE
            // This prevents holding the queue lock just to decide what to do
            selectedAction = this.actionRunner.selectAction();

            if (selectedAction) {
                this.log(`[AI-Engage] Selected: ${selectedAction.toUpperCase()}`);

                // 2. Pre-fetch Context (Heavy scrolling) - OUTSIDE QUEUE
                // This ensures we only block the queue for actual AI generation
                if (selectedAction === 'reply' || selectedAction === 'quote') {
                    this.log(`[AI-Engage] Pre-fetching context for ${selectedAction}...`);
                    try {
                        enhancedContext = await this.contextEngine.extractEnhancedContext(
                            this.page,
                            tweetUrl,
                            tweetText,
                            username
                        );
                    } catch (err) {
                        this.log(`[AI-Engage] Context extraction failed: ${err.message}`);
                    }
                }
            } else {
                this.log(`[AI-Engage] No action selected (all at limits or disabled)`);
            }

            // Define the AI logic as a standalone async function
            const executeAILogic = async () => {
                const action = selectedAction;
                let success = false;
                let reason = '';

                if (!action) {
                    // Already logged above
                } else {
                    const context = {
                        tweetText,
                        username,
                        tweetUrl,
                        enhancedContext: enhancedContext // Pass pre-fetched context
                    };

                    const result = await this.actionRunner.executeAction(action, context);
                    success = result.success &amp;&amp; result.executed;
                    reason = result.reason;

                    if (success) {
                        this.log(`[AI-Engage]  ${action} executed: ${reason}`);
                    } else if (!result.executed) {
                        this.log(`[AI-Engage]  ${action} skipped: ${reason}`);
                    } else {
                        this.log(`[AI-Engage]  ${action} failed: ${reason}`);
                    }
                }
                return { action, success };
            };

            // Execute via wrapper (Queue) or directly
            if (queueWrapper) {
                const wrapperResult = await queueWrapper(executeAILogic);
                if (wrapperResult.success) {
                    selectedAction = wrapperResult.result.action;
                    actionSuccess = wrapperResult.result.success;
                } else {
                     this.log(`[AI-Engage] Queue/AI failed: ${wrapperResult.error}`);
                     actionSuccess = false;
                }
            } else {
                // Legacy mode / Direct execution
                const res = await executeAILogic();
                selectedAction = res.action;
                actionSuccess = res.success;
            }

            // Store tweet context for Post-Dive engagement (if needed for fallbacks)
            this._lastTweetText = tweetText;
            this._lastUsername = username;
            this._lastTweetUrl = tweetUrl;

            // ================================================================
            // Read expanded tweet or navigate home immediately if successful
            // ================================================================
            if (actionSuccess) {
                this.log(`[Dive] Action successful, skipping reading phase and returning home...`);
            } else {
                await this._readExpandedTweet();
            }

            // ================================================================
            // RELEASE DIVE LOCK AND RETURN TO HOME
            // ================================================================
            // Only navigate home if action was NOT successful
            if (!actionSuccess) {
                await this.endDive(true, true);
            } else {
                // Action was successful, just release the lock
                await this.endDive(true, false);
            }

        } catch (error) {
            this.log('[Dive] Dive sequence failed: ' + error.message);
            // Release lock on error
            await this.endDive(false, true);
        }
    }

    /**
     * Quick fallback engagement when AI pipeline times out
     * Performs basic engagement without AI processing
     */
    async _quickFallbackEngagement() {
        try {
            this.log('[DiveQueue-Fallback] Executing quick engagement (no AI)...');

            const engagementRoll = Math.random();
            const engagementType = engagementRoll &lt; 0.4 ? 'like' :
                engagementRoll &lt; 0.7 ? 'bookmark' : 'none';

            if (engagementType === 'like') {
                if (this.diveQueue.canEngage('likes')) {
                    await this.handleLike();
                    this.diveQueue.recordEngagement('likes');
                    return { engagementType: 'like', success: true };
                }
            } else if (engagementType === 'bookmark') {
                if (this.diveQueue.canEngage('bookmarks')) {
                    await this.handleBookmark();
                    this.diveQueue.recordEngagement('bookmarks');
                    return { engagementType: 'bookmark', success: true };
                }
            }

            this.log('[DiveQueue-Fallback] No engagement performed (limits reached)');
            return { engagementType: 'none', success: true };

        } catch (error) {
            this.log(`[DiveQueue-Fallback] Engagement failed: ${error.message}`);
            return { engagementType: 'error', success: false, error: error.message };
        }
    }

    /**
         * Ensure sufficient exploration scroll before diving
         * Prevents re-diving into the same feed area
         */
    async _ensureExplorationScroll() {
        const currentY = await this.page.evaluate(() => window.scrollY);
        const docHeight = await this.page.evaluate(() => document.body.scrollHeight);
        const scrollDelta = currentY - this._lastScrollY;
        const timeSinceLastScroll = Date.now() - this._lastScrollTime;

        // If scrolled enough or near bottom, no need for extra scroll
        if (scrollDelta >= this._minScrollPerDive || currentY > docHeight - 1500) {
            return true;
        }

        // If at top (near 0), need to scroll significantly
        if (currentY &lt; 100) {
            this.log(`[Scroll] Starting from top, performing exploration scroll (${this._scrollExplorationThreshold}px)...`);
            // Scroll with variance (0.8x - 1.2x) for natural behavior
            const variance = 0.8 + Math.random() * 0.4;
            const scrollAmount = Math.floor(this._scrollExplorationThreshold * variance);
            await scrollDown(this.page, scrollAmount);
            await this.page.waitForTimeout(mathUtils.randomInRange(800, 1500));
            this._lastScrollY = await this.page.evaluate(() => window.scrollY);
            this._lastScrollTime = Date.now();
            return true;
        }

        return true;
    }

    /**
       * Internal method: diveTweet with AI reply (original logic)
       * Now includes dive locking to prevent scroller interference
         */
    async _diveTweetWithAI() {
        try {
            // ================================================================
            // ACQUIRE DIVE LOCK - Prevents scroller interference
            // ================================================================
            await this.startDive();

            // ENSURE EXPLORATION SCROLL - Prevent re-diving same area
            await this._ensureExplorationScroll();

            let targetTweet = null;

            // Find suitable tweet with increased scroll distance
            for (let attempt = 0; attempt &lt; 3; attempt++) {
                const tweets = this.page.locator('article[data-testid="tweet"]');
                const count = await tweets.count();

                if (count > 0) {
                    for (let i = 0; i &lt; Math.min(count, 10); i++) {
                        const t = tweets.nth(i);
                        const box = await t.boundingBox();
                        // Extended viewport range to catch more tweets
                        if (box &amp;&amp; box.height > 0 &amp;&amp; box.y > -100 &amp;&amp; box.y &lt; 1200) {
                            targetTweet = t;
                            // Reduced early break probability (0.4 -> 0.2) for more exploration
                            if (Math.random() > 0.2) break;
                        }
                    }
                }

                if (targetTweet) break;

                this.log('[Dive] No suitable tweets. Scrolling...');
                // Increased scroll distance (300 -> 600) with variance for natural behavior
                const variance = 0.85 + Math.random() * 0.3;
                const scrollAmount = Math.floor(600 * variance);
                await scrollDown(this.page, scrollAmount);
                await this.page.waitForTimeout(entropy.retryDelay(attempt));

                // Update scroll tracking
                this._lastScrollY = await this.page.evaluate(() => window.scrollY);
                this._lastScrollTime = Date.now();
            }

            if (!targetTweet) {
                this.log('[Dive] No suitable tweets found. Refreshing Home...');
                await this.page.goto('https://x.com/');
                await this.ensureForYouTab();
                // Release lock before returning
                await this.endDive(false, true);
                return;
            }

            // Get username from tweet for URL construction
            let username = 'unknown';
            try {
                const tweetTextEl = targetTweet.locator('[data-testid="tweetText"]').first();
                if (await tweetTextEl.count() > 0) {
                    const parent = await tweetTextEl.$x('..');
                    if (parent &amp;&amp; parent[0]) {
                        const link = await parent[0].$('a[href*="/"]');
                        if (link) {
                            const href = await link.getAttribute('href');
                            username = href?.replace(/^\/|\/$/g, '') || 'unknown';
                        }
                    }
                }
            } catch (e) {
                username = 'unknown';
            }

            // Determine click target
            let clickTarget = null;
            const timeStamp = targetTweet.locator('time').first();

            const tweetTextEl = targetTweet.locator('[data-testid="tweetText"]').first();

            if (await tweetTextEl.count() > 0 &amp;&amp; await tweetTextEl.isVisible()) {
                clickTarget = tweetTextEl;
                this.log('[Debug] Targeting tweet text body (Primary).');
            } else if (await timeStamp.count() > 0 &amp;&amp; await timeStamp.isVisible()) {
                const parentLink = timeStamp.locator('xpath=./ancestor::a[1]');
                clickTarget = (await parentLink.count() > 0) ? parentLink : timeStamp;
                this.log('[Debug] Targeting tweet permalink/time (Fallback).');
            } else {
                clickTarget = targetTweet;
                this.log('[Debug] Targeting entire tweet card (Last Resort).');
            }

            if (clickTarget) {
                await clickTarget.evaluate(el => el.scrollIntoView({ block: 'center', inline: 'center' }));
                await this.page.waitForTimeout(entropy.scrollSettleTime());

                const dbgBox = await clickTarget.boundingBox();
                this.log(`[Debug] Target: Box=${dbgBox ? `x:${Math.round(dbgBox.x)},y:${Math.round(dbgBox.y)}` : 'null'}`);

                this.log('[Attempt] Ghost Click on Permalink...');
                await this.humanClick(clickTarget, 'Tweet Permalink');
            }

            // Wait for navigation to tweet page
            let tweetUrl = '';
            let expanded = false;
            try {
                // Wait for URL to contain /status/
                await this.page.waitForURL('**/status/**', { timeout: TWITTER_TIMEOUTS.NAVIGATION });
                tweetUrl = this.page.url();
                this.log('[Success] Navigated to tweet page.');
                this.log(`[Debug] Tweet URL: ${tweetUrl}`);
                expanded = true;
            } catch (e) {
                this.log('[Fail] Ghost Click did not navigate. Retrying with NATIVE click...');
                if (clickTarget) {
                    await clickTarget.click({ force: true });
                }
                try {
                    await this.page.waitForURL('**/status/**', { timeout: TWITTER_TIMEOUTS.NAVIGATION });
                    tweetUrl = this.page.url();
                    this.log('[Success] Native Click navigated to tweet.');
                    expanded = true;
                } catch (e2) {
                    this.log('[Fail] Failed to expand tweet. Aborting dive.');
                    // Release lock before returning
                    await this.endDive(false, true);
                    return;
                }
            }

            if (!expanded) {
                await this.endDive(false, true);
                return;
            }

            // Skip if already processed this tweet
            const tweetIdMatch = tweetUrl &amp;&amp; tweetUrl.match(/status\/(\d+)/);
            if (tweetIdMatch) {
                const tweetId = tweetIdMatch[1];
                if (this._processedTweetIds.has(tweetId)) {
                    this.log(`[AI] Already processed tweet ${tweetId}, skipping...`);
                    await this.endDive(true, true);
                    return;
                }
                this._processedTweetIds.add(tweetId);
                this.log(`[AI] Tracking new tweet ${tweetId}`);
            }

            // ================================================================
            // EXTRACT TWEET CONTENT AFTER NAVIGATION (PRIMARY SOURCE)
            // ================================================================
            this.log('[AI] Extracting tweet content from full page...');

            // Wait for tweet content to fully load
            await this.page.waitForSelector('[data-testid="tweetText"]', { timeout: TWITTER_TIMEOUTS.ELEMENT_VISIBLE }).catch(() => { });
            await this.page.waitForTimeout(1000);  // Additional settle time

            // Extract FRESH tweet text AFTER navigation
            let tweetText = '';
            const freshTextEl = this.page.locator('[data-testid="tweetText"]').first();

            if (await freshTextEl.count() > 0) {
                tweetText = await freshTextEl.innerText().catch(() => '');
                this.log(`[AI] Extracted tweet text (${tweetText.length} chars)`);

                if (tweetText.length &lt; 10) {
                    this.log('[AI] Tweet text too short, trying alternative selectors...');
                    // Try alternative selectors
                    const alternatives = [
                        '[data-testid="tweetText"]',
                        '[lang] > div',
                        'article [role="group"]',
                        '.tweet-text'
                    ];

                    for (const selector of alternatives) {
                        const altEl = this.page.locator(selector).first();
                        if (await altEl.count() > 0) {
                            const altText = await altEl.innerText().catch(() => '');
                            if (altText.length > tweetText.length) {
                                tweetText = altText;
                                this.log(`[AI] Found better text (${altText.length} chars) with ${selector}`);
                            }
                        }
                    }
                }
            } else {
                this.log('[AI] WARNING: Could not find tweet text element!');
            }

            // Extract username from page URL
            if (username === 'unknown') {
                try {
                    const url = this.page.url();
                    const match = url &amp;&amp; url.match(/x\.com\/(\w+)\/status/);
                    if (match) username = match[1];
                } catch (e) { }
            }

            // Validate we have tweet text
            if (!tweetText || tweetText.length &lt; 5) {
                this.log('[AI] WARNING: Could not extract valid tweet text. Skipping AI reply.');
                // Still read the page and return normally
                await this._readExpandedTweet();
                await this.endDive(true, true);
                return;
            }

            // ================================================================
            // AI DECISION: Use Action Runner for smart probability redistribution
            // ================================================================
            const selectedAction = this.actionRunner.selectAction();
            let actionSuccess = false;

            if (!selectedAction) {
                this.log(`[AI-Engage] No action selected (all at limits or disabled)`);
            } else {
                this.log(`[AI-Engage] Selected: ${selectedAction.toUpperCase()}`);

                const context = {
                    tweetText,
                    username,
                    tweetUrl,
                    enhancedContext: {}
                };

                const result = await this.actionRunner.executeAction(selectedAction, context);
                actionSuccess = result.success &amp;&amp; result.executed;

                if (actionSuccess) {
                    this.log(`[AI-Engage]  ${selectedAction} executed: ${result.reason}`);
                } else if (!result.executed) {
                    this.log(`[AI-Engage]  ${selectedAction} skipped: ${result.reason}`);
                } else {
                    this.log(`[AI-Engage]  ${selectedAction} failed: ${result.reason}`);
                }
            }

            // Store tweet context for Post-Dive engagement (if needed for fallbacks)
            this._lastTweetText = tweetText;
            this._lastUsername = username;
            this._lastTweetUrl = tweetUrl;

            // ================================================================
            // Read expanded tweet or navigate home immediately if successful
            // ================================================================
            if (actionSuccess) {
                this.log(`[Dive] Action successful, skipping reading phase and returning home...`);
            } else {
                await this._readExpandedTweet();
            }

            // ================================================================
            // RELEASE DIVE LOCK AND RETURN TO HOME
            // ================================================================
            // ================================================================
            // RELEASE DIVE LOCK AND RETURN TO HOME
            // ================================================================
            // Only navigate home if action was NOT successful
            if (!actionSuccess) {
                await this.endDive(true, true);
            } else {
                // Action was successful, just release the lock
                await this.endDive(true, false);
            }

        } catch (error) {
            this.log('[Dive] Dive sequence failed: ' + error.message);
            // Release lock on error
            await this.endDive(false, true);
        }
    }

    /**
     * Read expanded tweet page (reading, media, replies, etc.)
     */
    async _readExpandedTweet() {
        // Text highlighting before reading
        if (Math.random() &lt; 0.15) {
            await this.highlightText().catch(() => { });
        }

        // Read main tweet
        const readTime = mathUtils.randomInRange(5000, 15000);
        this.log(`[Idle] Reading expanded tweet for ${readTime}ms...`);

        // During long reads, occasionally trigger micro-interactions
        const fidgetDuringRead = readTime > 8000;
        let fidgetInterval = null;

        if (fidgetDuringRead) {
            fidgetInterval = this.startFidgetLoop();
        }

        await this.page.waitForTimeout(readTime);

        if (fidgetInterval) {
            this.stopFidgetLoop();
        }

        // Optional micro-interaction after reading
        if (Math.random() &lt; 0.2) {
            await this.triggerMicroInteraction('post_read');
        }

        // Optional media
        if (mathUtils.roll(0.2)) {
            const media = this.page.locator('[data-testid="tweetPhoto"]').first();
            if (await media.count() > 0 &amp;&amp; await media.isVisible()) {
                this.log('[Action] Open media viewer');
                await this.humanClick(media, 'Media Viewer');
                const viewTime = mathUtils.randomInRange(5000, 12000);
                this.log(`[Media] Viewing media for ${(viewTime / 1000).toFixed(1)}s...`);
                await this.page.waitForTimeout(viewTime);
                await this.page.keyboard.press('Escape', { delay: mathUtils.randomInRange(50, 150) });
                await this.page.waitForTimeout(mathUtils.randomInRange(400, 900));
            }
        }

        // Read replies
        this.log('[Scroll] Reading replies...');
        await scrollRandom(this.page, 300, 600);
        await this.page.waitForTimeout(mathUtils.randomInRange(2000, 4000));

        // Return scroll
        await scrollRandom(this.page, 240, 660);
        await this.page.waitForTimeout(mathUtils.randomInRange(1000, 2000));

        // Note: Post-Dive engagement removed to favor strictly single-action-per-dive policy

        // Clear cached tweet context
        this._lastTweetText = null;
        this._lastUsername = null;
        this._lastTweetUrl = null;

        // Idle and return home
        await this.page.waitForTimeout(mathUtils.randomInRange(1200, 2400));
        await this.navigateHome();
        await this.page.waitForTimeout(mathUtils.randomInRange(1500, 3000));
    }

    /**
           * Override runSession to use dive queue and respect operation lock
           * Prevents scroller interference during tweet diving operations
           */
    async runSession(cycles = 10, minDurationSec = 0, maxDurationSec = 0) {
        this.log(`[AITwitterAgent] Starting AI-Enhanced Session with DiveQueue and Lock Management...`);

        // ================================================================
        // SETUP PHASE
        // ================================================================

        // Enable quick mode if we're in cooldown phase
        const originalDiveTweet = this.diveTweet.bind(this);

        // Wrap diveTweet to enable quick mode when needed
        this.diveTweet = async () => {
            try {
                if (this.isInCooldown() &amp;&amp; !this.quickModeEnabled) {
                    this.log('[DiveQueue] Enabling quick mode for cooldown phase');
                    this.diveQueue.enableQuickMode();
                    this.quickModeEnabled = true;
                }
                const result = await originalDiveTweet();
                return result;
            } catch (error) {
                this.log(`[DiveQueue] Wrapped diveTweet error: ${error.message}`);
                throw error;
            }
        };

        // Initialize session from parent
        this.log(`Starting Session on ${this.page.url()}`);

        if (minDurationSec > 0 &amp;&amp; maxDurationSec > 0) {
            const durationMs = mathUtils.randomInRange(minDurationSec * 1000, maxDurationSec * 1000);
            this.sessionEndTime = Date.now() + durationMs;
            this.log(`Session Timer Set: ${(durationMs / 1000).toFixed(1)}s`);
        } else {
            this.log(`Session Mode: Fixed Cycles (${cycles})`);
        }

        // Navigate to home if not already there
        if (!this.page.url().includes('home')) {
            await this.navigateHome();
        }

        // Theme enforcement - apply early to prevent flashing
        const theme = this.twitterConfig.theme || 'dark';
        if (theme) {
            this.log(`Enforcing theme: ${theme}`);
            await this.page.emulateMedia({ colorScheme: theme });
        }

        // Human-like session warmup
        await this.human.sessionStart();

        // Initial login check
        for (let i = 0; i &lt; 3; i++) {
            const isLoggedIn = await this.checkLoginState();
            if (isLoggedIn) break;

            if (i &lt; 2) {
                const delay = entropy.retryDelay(i, 5000);
                this.log(`[Validation] Login check failed (${i + 1}/3). Retrying in ${(delay / 1000).toFixed(1)}s...`);
                await this.page.waitForTimeout(delay);
            }
        }

        if (this.state.consecutiveLoginFailures >= 3) {
            this.log(' Aborting session: Not logged in (3 consecutive failures).');
            return;
        }

        // ================================================================
        // MAIN SESSION LOOP WITH OPERATION LOCK CHECKS
        // ================================================================

        while (true) {
            // ============================================================
            // CHECK END CONDITIONS
            // ============================================================

            // Check if should end session naturally
            const elapsed = Date.now() - this.sessionStart;
            if (this.human.session.shouldEndSession(elapsed)) {
                this.log(` Natural session end reached. Finishing...`);
                break;
            }

            // Check session timeout
            if (this.isSessionExpired()) {
                this.log(` Session Time Limit Reached. Finishing...`);
                break;
            }

            // Check login failures
            if (this.state.consecutiveLoginFailures >= 3) {
                this.log(` ABORTING: Detected 'Not Logged In' state 3 times consecutively.`);
                break;
            }

            // Check cycle limit
            if (!this.sessionEndTime &amp;&amp; this.loopIndex >= cycles) {
                this.log(`Session Cycle Limit Reached (${cycles}). Finishing...`);
                break;
            }

            this.loopIndex += 1;
            this.log(`--- Loop ${this.loopIndex} ${this.sessionEndTime ? '' : `of ${cycles}`} ---`);

            // ============================================================
            // HEALTH CHECK - Verify connection health before proceeding
            // ============================================================
            const healthCheckInterval = 10; // Check every 10 loops
            if (this.loopIndex % healthCheckInterval === 0) {
                this.log('[Health] Performing periodic health check...');
                const health = await this.performHealthCheck();

                if (!health.healthy) {
                    this.logWarn(`[Health] Unhealthy: ${health.reason}. Attempting recovery...`);
                    // Attempt recovery by navigating home
                    try {
                        await this.navigateHome();
                        await this.page.waitForTimeout(2000);
                        const retryHealth = await this.performHealthCheck();
                        if (!retryHealth.healthy) {
                            this.logWarn('[Health] Recovery failed, continuing with caution');
                        } else {
                            this.log('[Health] Recovery successful');
                        }
                    } catch (e) {
                        this.logWarn(`[Health] Recovery attempt failed: ${e.message}`);
                    }
                } else {
                    this.log('[Health] Connection healthy');
                }
            }

            // Boredom pause every 4th cycle
            if (this.loopIndex % 4 === 0 &amp;&amp; mathUtils.roll(0.25)) {
                await this.human.session.boredomPause(this.page);
            }

            // ============================================================
            // CHECK OPERATION LOCK BEFORE CONTINUING
            // ============================================================

            // Wait for diving operation to complete if lock is acquired
            let firstSessionWait = true;
            if (this.operationLock) {
                while (this.operationLock) {
                    const now = Date.now();

                    // Only log every 10 seconds to prevent log spam
                    if (firstSessionWait || now - this.lastWaitLogTime >= this.waitLogInterval) {
                        this.log(`[Session]  Waiting for diving operation to complete... (${((now - this.lastWaitLogTime) / 1000).toFixed(0)}s elapsed)`);
                        this.lastWaitLogTime = now;
                        firstSessionWait = false;
                    }

                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                this.log('[Session]  Diving operation completed, continuing session');
                this.lastWaitLogTime = 0;  // Reset wait log timestamp
            }

            // ============================================================
            // BURST MODE STATE MACHINE
            // ============================================================

            const now = Date.now();
            if (this.state.activityMode === 'BURST') {
                if (now > this.state.burstEndTime) {
                    this.state.activityMode = 'NORMAL';
                    this.log(' Burst Mode Ended. Returning to normal pace.');
                }
            } else if (this.state.activityMode === 'NORMAL') {
                if (!this.isFatigued &amp;&amp; mathUtils.roll(0.10)) {
                    this.state.activityMode = 'BURST';
                    const duration = mathUtils.randomInRange(30000, 60000);
                    this.state.burstEndTime = now + duration;
                    this.log(` >>> ENTERING BURST MODE! High intensity for ${(duration / 1000).toFixed(1)}s`);
                }
            }

            // ============================================================
            // SIMULATE READING (WITH SCROLL LOCK CHECK)
            // ============================================================

            if (this.operationLock) {
                // Skip reading during diving operations
                this.log('[Session] Skipping reading (diving operation in progress)');
            } else {
                await this.simulateReading();
                if (this.isSessionExpired()) break;
            }

            // ============================================================
            // DECISION LOGIC
            // ============================================================

            // Wait for lock again after reading with buffered logging
            let secondSessionWait = true;
            if (this.operationLock) {
                while (this.operationLock) {
                    const now = Date.now();

                    // Only log every 10 seconds to prevent log spam
                    if (secondSessionWait || now - this.lastWaitLogTime >= this.waitLogInterval) {
                        this.log(`[Session]  Waiting for diving operation after reading... (${((now - this.lastWaitLogTime) / 1000).toFixed(0)}s elapsed)`);
                        this.lastWaitLogTime = now;
                        secondSessionWait = false;
                    }

                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                this.lastWaitLogTime = 0;  // Reset wait log timestamp
            }

            // Check end conditions again
            if (this.isSessionExpired()) break;

            const p = this.normalizeProbabilities(this.twitterConfig.probabilities);
            const roll = Math.random();
            let cursor = 0;

            if (roll &lt; (cursor += p.refresh)) {
                this.log('[Branch] Refresh Feed');
                this.state.lastRefreshAt = Date.now();
                await this.navigateHome();
                await this.page.waitForTimeout(Math.max(50, mathUtils.gaussian(1500, 600)));
            } else if (roll &lt; (cursor += p.profileDive)) {
                await this.diveProfile();
            } else if (roll &lt; (cursor += p.tweetDive)) {
                await this.diveTweet();
                // endDive(true, true) already handles: navigate to home, wait 500ms, release lock
                // Just continue scrolling from home
                await this.simulateReading();
            } else {
                this.log('[Branch] Idle (Staring at screen)');
                const idleCfg = this.twitterConfig.timings?.actionSpecific?.idle || { mean: 5000, deviation: 2000 };
                const duration = Math.max(1000, mathUtils.gaussian(idleCfg.mean, idleCfg.deviation));
                await this.page.waitForTimeout(duration);
            }

            // Wind-down if under 20s remaining
            if (this.sessionEndTime &amp;&amp; (this.sessionEndTime - Date.now() &lt; 20000)) {
                this.log('Winding down session... Navigating Home and idling briefly.');
                await this.navigateHome();
                await this.page.waitForTimeout(mathUtils.randomInRange(1500, 3000));
                break;
            }

            // Human-like cycle complete
            await this.human.cycleComplete();
        }

        // ================================================================
        // CLEANUP PHASE
        // ================================================================

        // Wait for any pending operations with buffered logging
        let finalCleanupWait = true;
        if (this.operationLock) {
            while (this.operationLock) {
                const now = Date.now();

                // Only log every 10 seconds to prevent log spam
                if (finalCleanupWait || now - this.lastWaitLogTime >= this.waitLogInterval) {
                    this.log(`[Session]  Waiting for final diving operation to complete... (${((now - this.lastWaitLogTime) / 1000).toFixed(0)}s elapsed)`);
                    this.lastWaitLogTime = now;
                    finalCleanupWait = false;
                }

                await new Promise(resolve => setTimeout(resolve, 100));
            }
            this.lastWaitLogTime = 0;  // Reset wait log timestamp
        }

        // Session wrap-up
        await this.human.sessionEnd();

        // Flush buffered logs
        await this.flushLogs();

        this.log('Session Complete.');

        // Final stats are printed by ai-twitterActivity.js to avoid duplication
    }

    /**
     * Override simulateReading to respect scrolling lock
     * When diving operation is in progress, skip scrolling and perform idle cursor movement
     */
    async simulateReading() {
        // Check if scrolling is enabled
        if (!this.scrollingEnabled || this.operationLock) {
            this.log('[Idle] Scrolling disabled (diving operation in progress)');

            // Perform idle cursor movement for human-like behavior
            await this.performIdleCursorMovement();
            return;
        }

        // Continue with parent's simulateReading implementation
        await super.simulateReading();
    }

    /**
      * Get dive queue status for monitoring (uses BufferedLogger)
      */
    getQueueStatus() {
        const status = this.diveQueue.getFullStatus();

        // Use buffered logger for high-frequency queue status updates
        this.queueLogger.info(`Queue: ${status.queueLength} queued, ${status.activeCount} active, ${status.utilization}% utilized`);
        this.queueLogger.info(`Capacity: ${status.capacity}/${status.maxQueueSize}`);

        if (status.engagementLimits) {
            const limits = status.engagementLimits;
            this.queueLogger.info(`Limits: likes(${limits.likes.used}/${limits.likes.limit}) ` +
                `replies(${limits.replies.used}/${limits.replies.limit}) ` +
                `quotes(${limits.quotes.used}/${limits.quotes.limit}) ` +
                `bookmarks(${limits.bookmarks.used}/${limits.bookmarks.limit})`);
        }

        if (status.retryInfo &amp;&amp; status.retryInfo.pendingRetries > 0) {
            this.queueLogger.warn(`${status.retryInfo.pendingRetries} retries pending`);
        }

        return status;
    }

    /**
     * Check if queue is healthy
     */
    isQueueHealthy() {
        return this.diveQueue.isHealthy();
    }

    /**
     * Handle AI reply decision and execution
     * Flow: Probability check  Sentiment check  Enhanced Context  Reply
      */
    async handleAIReply(tweetText, username, options = {}) {
        const { url = '' } = options;

        // ================================================================
        // Check if this is a pre-validated reply from _diveTweetWithAI
        // If so, skip probability check and go directly to sentiment analysis
        // ================================================================
        if (options.action === 'reply') {
            this.log(`[AI-Replies] Pre-validated reply - skipping probability check`);
        } else {
            // Original flow - make decision here
            this.aiStats.attempts++;
            this.log(`[AI] Analyzing tweet from @${username}...`);
        }
        this.log(`[AI] Tweet URL: ${url}`);

        // ================================================================
        // STEP 1: Sentiment analysis (skip negative content)
        // ================================================================
        this.log(`[Sentiment] Analyzing tweet sentiment...`);
        const sentimentResult = sentimentService.analyze(tweetText);

        // Log basic sentiment (backward compatible)
        this.log(`[SentimentGuard] ${sentimentResult.isNegative ? ' NEGATIVE' : ' Neutral/Positive'} content (score: ${sentimentResult.score.toFixed(2)})`);

        // Log advanced dimensions
        this.log(`[Sentiment] Dimensions - Valence: ${sentimentResult.dimensions.valence.valence.toFixed(2)}, ` +
            `Arousal: ${sentimentResult.dimensions.arousal.arousal.toFixed(2)}, ` +
            `Dominance: ${sentimentResult.dimensions.dominance.dominance.toFixed(2)}, ` +
            `Sarcasm: ${sentimentResult.dimensions.sarcasm.sarcasm.toFixed(2)}`);

        // Log engagement recommendations
        if (sentimentResult.engagement.warnings.length > 0) {
            this.log(`[Sentiment] Warnings: ${sentimentResult.engagement.warnings.join(', ')}`);
        }

        if (sentimentResult.isNegative) {
            this.log(`[AI-Replies] Skipped (negative sentiment)`);
            this.aiStats.skips++;
            return;
        }

        // Check advanced risk factors
        if (sentimentResult.composite.riskLevel === 'high') {
            this.log(`[AI-Replies] Skipped (high risk: ${sentimentResult.composite.conversationType})`);
            this.aiStats.skips++;
            return;
        }

        // ================================================================
        // STEP 3: Enhanced Context Capture (metrics, sentiment, tone)
        // ================================================================
        this.log(`[AI-Context] Extracting enhanced context...`);
        const enhancedContext = await this.contextEngine.extractEnhancedContext(
            this.page,
            url,
            tweetText,
            username
        );

        this.log(`[AI-Context] Enhanced: sentiment=${enhancedContext.sentiment?.overall}, tone=${enhancedContext.tone?.primary}, engagement=${enhancedContext.engagementLevel}, ${enhancedContext.replies.length} replies`);

        // ================================================================
        // STEP 4: Generate reply with enhanced context
        // ================================================================

        // If pre-validated, skip shouldReply() call and generate reply directly
        if (options.action === 'reply') {
            const decision = await this.replyEngine.generateReply(tweetText, username, enhancedContext);

            if (decision.success &amp;&amp; decision.reply) {
                // Check engagement limits
                const canReply = this.engagementTracker.canPerform('replies') &amp;&amp; this.diveQueue.canEngage('replies');
                if (!canReply) {
                    this.log(`[AI-Replies] Skipped (engagement limit reached)`);
                    this.aiStats.skips++;
                    return;
                }
                this.log(`[AI-Replies] Generated reply: "${decision.reply.substring(0, 30)}..."`);
                await this.executeAIReply(decision.reply);
                this.aiStats.replies++;
                return;
            } else {
                this.log(`[AI-Replies] Failed to generate reply: ${decision.reason || 'unknown error'}`);
                this.aiStats.errors++;
                return;
            }
        }

        // Original flow - use shouldReply() for decision
        const decision = await this.replyEngine.shouldReply(tweetText, username, enhancedContext);

        // ================================================================
        // STEP 5: Execute decision
        // ================================================================
        switch (decision.decision) {
            case 'reply':
                // Check engagement limits from both systems
                const canReply = this.engagementTracker.canPerform('replies') &amp;&amp; this.diveQueue.canEngage('replies');
                if (!canReply) {
                    this.log(`[AI-Replies] Skipped (engagement limit reached - tracker: ${this.engagementTracker.canPerform('replies')}, queue: ${this.diveQueue.canEngage('replies')})`);
                    this.aiStats.skips++;
                    return;
                }
                this.log(`[AI-Replies] Generating reply: "${decision.reply?.substring(0, 30)}..."`);
                await this.executeAIReply(decision.reply);
                this.aiStats.replies++;
                break;

            case 'skip': {
                this.log(`[AI-Replies] Skipped (${decision.reason})`);
                this.aiStats.skips++;
                break;
            }

            default: {
                this.log(`[AI-Replies] Skipped (no decision)`);
                this.aiStats.skips++;
                break;
            }
        }
    }

    async executeAIReply(replyText) {
        try {
            this.log('[AI] Executing reply with human-like behavior...');

            // Use the new human-like reply engine
            const result = await this.replyEngine.executeReply(this.page, replyText);

            if (result.success) {
                this.log(`[AI] Reply posted successfully via ${result.method}`);
                this.state.replies++;

                // Record engagement in both systems
                if (this.engagementTracker.record('replies')) {
                    const progress = this.engagementTracker.getProgress('replies');
                    this.log(`[Engagement] ${progress} Replies posted`);
                }
            } else {
                this.logWarn(`[AI] Reply failed: ${result.reason} (method: ${result.method})`);
            }

            return result.success;

        } catch (error) {
            this.log(`[AI] Failed to post reply: ${error.message}`);
            return false;
        }
    }

    async executeAIQuote(quoteText, tweetUrl = '') {
        try {
            this.log('[AI] Executing quote with human-like behavior...');

            const result = await this.quoteEngine.executeQuote(this.page, quoteText);

            if (result.success) {
                this.log(`[AI] Quote posted successfully via ${result.method}`);
                this.state.quotes++;

                if (this.engagementTracker.record('quotes')) {
                    const progress = this.engagementTracker.getProgress('quotes');
                    this.log(`[Engagement] ${progress} Quotes posted`);
                }
            } else {
                this.logWarn(`[AI] Quote failed: ${result.reason} (method: ${result.method})`);
            }

            return result.success;

        } catch (error) {
            this.log(`[AI] Failed to post quote: ${error.message}`);
            return false;
        }
    }

    /**
     * Verify reply was posted by scanning DOM for reply content
     * @param {string} replyText - The text we attempted to post
     * @returns {Promise&lt;boolean>} True if reply found in DOM
     */
    async verifyReplyPosted(replyText) {
        try {
            // Get current page URL to verify we're still on tweet page
            const currentUrl = this.page.url();
            if (!currentUrl.includes('/status/')) {
                this.log('[Verify] No longer on tweet page');
                return false;
            }

            // Wait a bit for DOM to update
            await this.page.waitForTimeout(1000);

            // Look for the reply text in article elements (newly posted reply)
            const articles = await this.page.$$('article');
            this.log(`[Verify] Found ${articles.length} articles on page`);

            // Get the first few words of our reply to search for
            const searchWords = replyText.split(' ').slice(0, 5).join(' ').toLowerCase();
            this.log(`[Verify] Searching for: "${searchWords}"`);

            // Check each article for our reply text
            for (let i = 0; i &lt; Math.min(articles.length, 5); i++) {
                try {
                    const article = articles[i];
                    const textEl = await article.$('[data-testid="tweetText"], [dir="auto"]');
                    if (textEl) {
                        const articleText = await textEl.innerText().catch(() => '');
                        const articleTextLower = articleText.toLowerCase();

                        // Check if article contains our reply text (partial match)
                        if (articleTextLower.includes(searchWords) ||
                            searchWords.includes(articleTextLower.slice(0, 30))) {
                            this.log(`[Verify] Found reply in article ${i + 1}`);
                            return true;
                        }
                    }
                } catch (e) {
                    // Skip failed articles
                }
            }

            // Alternative: Look for reply count increase or new elements
            const replyBtn = this.page.locator('[data-testid="reply"]').first();
            const replyCount = await replyBtn.count();

            // Check if composer is closed (reply submitted)
            const composer = this.page.locator('[data-testid="tweetText"]').first();
            const composerCount = await composer.count();

            if (composerCount > 0) {
                const composerText = await composer.innerText().catch(() => '');
                // If composer is empty or cleared, reply was likely posted
                if (!composerText || composerText.trim().length === 0) {
                    this.log('[Verify] Composer cleared - reply likely posted');
                    return true;
                }
            }

            this.log('[Verify] Could not verify reply in DOM');
            return false;

        } catch (error) {
            this.log(`[Verify] Error checking reply: ${error.message}`);
            return false;
        }
    }

    /**
     * Ultra-human-like typing simulation
     * Mimics real human typing patterns to avoid detection
     */
    async humanTypingWithTypos(inputEl, text) {
        const chars = text.split('');

        // Keyboard layout for proximity typos
        const keyboardLayout = {
            'q': ['w', 'a', '1'], 'w': ['q', 'e', 'a', 's', '2'],
            'e': ['w', 'r', 'd', 's', '3', '4'], 'r': ['e', 't', 'f', 'g', '4', '5'],
            't': ['r', 'y', 'g', 'h', '5', '6'], 'y': ['t', 'u', 'h', 'j', '6', '7'],
            'u': ['y', 'i', 'j', 'k', '7', '8'], 'i': ['u', 'o', 'k', 'l', '8', '9'],
            'o': ['i', 'p', 'l', ';', '9', '0'], 'p': ['o', '[', "'", '0'],
            'a': ['q', 'w', 's', 'z'], 's': ['w', 'e', 'd', 'x', 'z', 'a'],
            'd': ['e', 'r', 'f', 'c', 'x', 's'], 'f': ['r', 't', 'g', 'v', 'c', 'd'],
            'g': ['t', 'y', 'h', 'b', 'v', 'f'], 'h': ['y', 'u', 'j', 'n', 'b', 'g'],
            'j': ['u', 'i', 'k', 'm', 'n', 'h'], 'k': ['i', 'o', 'l', ',', 'm', 'j'],
            'l': ['o', 'p', ';', ',', '.', 'k'], 'z': ['a', 's', 'x'], 'x': ['z', 'c', 'd', 's'],
            'c': ['x', 'v', 'f', 'd'], 'v': ['c', 'b', 'g', 'f'], 'b': ['v', 'n', 'h', 'g'],
            'n': ['b', 'm', 'j', 'h'], 'm': ['n', ',', 'j', 'k'],
            '0': ['9', 'p', 'o'], '1': ['2', 'q'], '2': ['1', '3', 'w', 'q'],
            '3': ['2', '4', 'e', 'w'], '4': ['3', '5', 'r', 'e'], '5': ['4', '6', 't', 'r'],
            '6': ['5', '7', 'y', 't'], '7': ['6', '8', 'u', 'y'], '8': ['7', '9', 'i', 'u'],
            '9': ['8', '0', 'o', 'i'],
            '.': [',', 'l', ';', '/'], ',': ['m', '.', 'k', 'j', 'n'],
            ';': ['l', "'", 'p', '/'], "'": [';', 'p', '[', ']'],
            '[': ['p', "'", ']', '\\'], ']': ['[', '\\'], '\\': [']'],
            '-': ['0', '=', '['], '=': ['-', '[', ']']
        };

        // Shift-required characters
        const shiftChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&amp;*()_+{}|:"&lt;>?~';

        // Track typing state
        let i = 0;
        let consecutiveErrors = 0;

        while (i &lt; chars.length) {
            const char = chars[i];
            const isUpperCase = char >= 'A' &amp;&amp; char &lt;= 'Z';
            const isShiftChar = shiftChars.includes(char);
            const isSpace = char === ' ';
            const isPunctuation = '.,!?;:;\'"-()[]{}'.includes(char);
            const isNewline = char === '\n';
            const prevChar = i > 0 ? chars[i - 1] : null;
            const nextChar = i &lt; chars.length - 1 ? chars[i + 1] : null;

            // Context-aware typing speed
            let baseDelay;

            // Position-based speed patterns
            const positionProgress = i / chars.length;
            const charsTyped = i;
            const charsRemaining = chars.length - i;

            if (charsTyped &lt; 3) {
                // Very slow start (finding keyboard)
                baseDelay = mathUtils.randomInRange(200, 400);
            } else if (charsTyped &lt; 10) {
                // Warming up
                baseDelay = mathUtils.randomInRange(120, 250);
            } else if (positionProgress > 0.8) {
                // Slowing down at end
                baseDelay = mathUtils.randomInRange(100, 200);
            } else {
                // Normal typing rhythm
                baseDelay = mathUtils.randomInRange(60, 150);
            }

            // Context adjustments
            if (isUpperCase || isShiftChar) {
                // Hold shift - takes extra time
                baseDelay += mathUtils.randomInRange(50, 150);
            }

            if (isSpace) {
                // Word boundary pause
                baseDelay += mathUtils.randomInRange(80, 200);

                // Sometimes longer pause between sentences
                if (prevChar === '.' || prevChar === '!' || prevChar === '?') {
                    baseDelay += mathUtils.randomInRange(200, 500);
                }
            }

            if (isPunctuation &amp;&amp; !isSpace) {
                // Punctuation pause
                baseDelay += mathUtils.randomInRange(30, 100);

                // Longer for sentence end
                if (char === '.' || char === '!' || char === '?') {
                    baseDelay += mathUtils.randomInRange(100, 300);
                }
            }

            if (isNewline) {
                baseDelay += mathUtils.randomInRange(200, 400);
            }

            // ERROR SIMULATION
            // Determine if we should make an error
            let makeError = false;
            let errorType = null;

            if (charsTyped >= 3 &amp;&amp; charsRemaining >= 2 &amp;&amp; consecutiveErrors &lt; 2) {
                const errorRoll = Math.random();

                // 8% base error rate
                if (errorRoll &lt; 0.08) {
                    makeError = true;

                    // Error type distribution:
                    // 40% - adjacent key
                    // 25% - double letter
                    // 20% - skipped letter
                    // 10% - transposition
                    // 5% - no error (just pause)
                    const errorRoll2 = Math.random();
                    if (errorRoll2 &lt; 0.40) errorType = 'adjacent';
                    else if (errorRoll2 &lt; 0.65) errorType = 'double';
                    else if (errorRoll2 &lt; 0.85) errorType = 'skip';
                    else if (errorRoll2 &lt; 0.95) errorType = 'transposition';
                    else errorType = 'pause';
                }
            }

            if (makeError &amp;&amp; errorType !== 'pause') {
                switch (errorType) {
                    case 'adjacent':
                        const charLower = char.toLowerCase();
                        const adjacent = keyboardLayout[charLower];
                        if (adjacent &amp;&amp; Math.random() &lt; 0.7) {
                            const wrongChar = adjacent[Math.floor(Math.random() * adjacent.length)];
                            // Type wrong char
                            await this.page.keyboard.type(wrongChar, { delay: baseDelay });
                            // Pause like human noticing
                            await this.page.waitForTimeout(mathUtils.randomInRange(80, 200));
                            // Backspace
                            await this.page.keyboard.press('Backspace', { delay: mathUtils.randomInRange(40, 100) });
                            // Brief pause before correct
                            await this.page.waitForTimeout(mathUtils.randomInRange(30, 80));
                            // Type correct
                            await this.page.keyboard.type(char, { delay: baseDelay + mathUtils.randomInRange(20, 60) });
                            consecutiveErrors++;
                        } else {
                            await this.page.keyboard.type(char, { delay: baseDelay });
                        }
                        break;

                    case 'double':
                        // Type the same char twice by accident
                        if (Math.random() &lt; 0.6) {
                            await this.page.keyboard.type(char, { delay: baseDelay });
                            await this.page.waitForTimeout(mathUtils.randomInRange(20, 60));
                            await this.page.keyboard.type(char, { delay: baseDelay });
                            await this.page.waitForTimeout(mathUtils.randomInRange(50, 150));
                            // Backspace once to fix
                            await this.page.keyboard.press('Backspace', { delay: mathUtils.randomInRange(40, 100) });
                            consecutiveErrors++;
                        } else {
                            await this.page.keyboard.type(char, { delay: baseDelay });
                        }
                        break;

                    case 'skip':
                        // Type next char instead of current (transposition)
                        if (i &lt; chars.length - 1 &amp;&amp; Math.random() &lt; 0.5) {
                            const nextCharTyped = chars[i + 1];
                            await this.page.keyboard.type(nextCharTyped, { delay: baseDelay });
                            await this.page.waitForTimeout(mathUtils.randomInRange(50, 120));
                            // Notice and correct
                            await this.page.keyboard.press('Backspace', { delay: mathUtils.randomInRange(40, 100) });
                            // Type correct char
                            await this.page.keyboard.type(char, { delay: baseDelay + mathUtils.randomInRange(20, 80) });
                            consecutiveErrors++;
                        } else {
                            await this.page.keyboard.type(char, { delay: baseDelay });
                        }
                        break;

                    case 'transposition':
                        // Type char in wrong order (like "teh" for "the")
                        // Handle naturally as skip + adjacent
                        await this.page.keyboard.type(char, { delay: baseDelay });
                        consecutiveErrors++;
                        break;
                }
            } else if (errorType === 'pause') {
                // Human paused while typing (thinking)
                await this.page.waitForTimeout(mathUtils.randomInRange(300, 800));
                await this.page.keyboard.type(char, { delay: baseDelay });
            } else {
                // Normal typing - add slight variation
                await this.page.keyboard.type(char, {
                    delay: baseDelay + mathUtils.randomInRange(-10, 20)
                });
                consecutiveErrors = 0;
            }

            // Random "thinking pause" - 3% chance during typing
            if (Math.random() &lt; 0.03 &amp;&amp; charsTyped > 5 &amp;&amp; charsRemaining > 5) {
                await this.page.waitForTimeout(mathUtils.randomInRange(200, 600));
            }

            // Micro mouse movements (hand adjustment) - 5% chance
            if (Math.random() &lt; 0.05) {
                const dx = mathUtils.randomInRange(-20, 20);
                const dy = mathUtils.randomInRange(-10, 10);
                await this.page.mouse.move(dx, dy, { steps: 2 });
            }

            i++;
        }

        // Final human touch - sometimes cursor moves away at end
        await this.page.waitForTimeout(mathUtils.randomInRange(100, 300));
    }

    /**
          * Handle fallback action when AI skips
          */
    async handleFallback(action) {
        try {
            switch (action) {
                case 'bookmark':
                    // Check engagement limits from both systems
                    const canBookmark = this.engagementTracker.canPerform('bookmarks') &amp;&amp; this.diveQueue.canEngage('bookmarks');
                    if (!canBookmark) {
                        this.log('[AI-Fallback] Bookmark limit reached, skipping');
                        return;
                    }

                    const bm = this.page.locator('button[data-testid="bookmark"]').first();
                    if (await bm.count() > 0 &amp;&amp; await bm.isVisible()) {
                        this.log('[AI-Fallback] Bookmarking tweet');
                        await this.humanClick(bm, 'Bookmark');

                        if (this.engagementTracker.record('bookmarks')) {
                            const progress = this.engagementTracker.getProgress('bookmarks');
                            this.log(`[Engagement] ${progress} Bookmarks used`);
                        }

                        // Also record in dive queue
                        if (this.diveQueue.canEngage('bookmarks')) {
                            this.diveQueue.recordEngagement('bookmarks');
                            const queueProgress = this.diveQueue.getEngagementProgress();
                            this.log(`[DiveQueue-Engagement] Bookmarks: ${queueProgress.bookmarks.current}/${queueProgress.bookmarks.limit}`);
                        }
                    }
                    break;

                case 'like':
                    await this.handleLike();
                    break;

                case 'none':
                default:
                    this.log('[AI-Fallback] No action taken');
                    break;
            }
        } catch (error) {
            this.log(`[AI-Fallback] Error: ${error.message}`);
        }
    }

    /**
          * Handle like button - Robust implementation with smart selectors and fallbacks
          * Optionally accepts tweetText for sentiment analysis
          */
    async handleLike(tweetText = null) {
        try {
            // ================================================================
            // SENTIMENT CHECK - Skip likes on negative content
            // ================================================================
            if (tweetText) {
                const sentimentResult = sentimentService.analyze(tweetText);
                if (!sentimentResult.engagement.canLike) {
                    this.log(`[Sentiment]  Skipping like on negative content ` +
                        `(risk: ${sentimentResult.composite.riskLevel}, ` +
                        `toxicity: ${sentimentResult.dimensions.toxicity.toxicity.toFixed(2)})`);
                    return;
                }
            }

            // Check engagement limits from both systems
            const canLike = this.engagementTracker.canPerform('likes') &amp;&amp; this.diveQueue.canEngage('likes');
            if (!canLike) {
                this.log('[Like] Limit reached, skipping');
                return;
            }

            // ================================================================
            // SMART SELECTOR WITH FALLBACKS (using HumanInteraction)
            // ================================================================
            const likeSelectors = [
                'button[data-testid="like"][role="button"]',
                '[data-testid="like"]',
                '[aria-label="Like"]',
                'svg[aria-label*="Like"]',
                'button:has-text("Like"):not([aria-label*="Unlike"])'
            ];

            const likeResult = await this.humanInteraction.findWithFallback(likeSelectors, { visible: true, timeout: 5000 });

            if (!likeResult) {
                this.log('[Like]  Could not find like button with any selector');
                return;
            }

            const likeButton = likeResult.element;
            const selectedSelector = likeResult.selector;

            // Check if already liked
            const unlikeSelectors = [
                'button[data-testid="unlike"][role="button"]',
                '[data-testid="unlike"]',
                '[aria-label="Unlike"]',
                '[aria-label*="Liked"]'
            ];

            const unlikeResult = await this.humanInteraction.findWithFallback(unlikeSelectors, { visible: true, timeout: 1000 });
            if (unlikeResult) {
                this.log(`[Skip] Tweet is ALREADY LIKED (found: ${unlikeResult.selector})`);
                return;
            }

            // ================================================================
            // PRE-CLICK VERIFICATION
            // ============================================================================================

            // Wait for element to be stable
            let stableCount = 0;
            const maxStableAttempts = 10;
            let lastBoundingBox = null;

            while (stableCount &lt; 3 &amp;&amp; stableCount &lt; maxStableAttempts) {
                try {
                    const bbox = await likeButton.boundingBox();
                    if (bbox) {
                        if (lastBoundingBox) {
                            const dx = Math.abs(bbox.x - lastBoundingBox.x);
                            const dy = Math.abs(bbox.y - lastBoundingBox.y);
                            if (dx &lt; 3 &amp;&amp; dy &lt; 3) {
                                stableCount++;
                            } else {
                                stableCount = 0;
                            }
                        }
                        lastBoundingBox = bbox;
                    }
                } catch { }

                if (stableCount &lt; 3) {
                    await this.page.waitForTimeout(100);
                    stableCount++;
                }
            }

            // Check aria-label to confirm not already liked
            try {
                const ariaLabel = await likeButton.getAttribute('aria-label') || '';
                if (ariaLabel.toLowerCase().includes('unlike') || ariaLabel.toLowerCase().includes('liked')) {
                    this.log(`[Skip] Tweet already liked (aria-label: ${ariaLabel})`);
                    return;
                }
            } catch { }

            // Verify element is actionable (not covered by overlay)
            const isActionable = await this.isElementActionable(likeButton);
            if (!isActionable) {
                this.log('[Like]  Element may be covered, trying scroll adjustment...');
                try {
                    await likeButton.scrollIntoViewIfNeeded();
                    await this.page.waitForTimeout(500);
                } catch { }
            }

            // ================================================================
            // EXECUTE CLICK
            // ================================================================
            this.log(`[Action]  Like (selector: ${selectedSelector})`);

            // Try humanClick first, then fallback to native
            try {
                await this.humanClick(likeButton, 'Like Button');
            } catch (e) {
                this.log(`[Like] humanClick failed: ${e.message}, using native click...`);
                try {
                    await likeButton.click({ timeout: TWITTER_TIMEOUTS.ELEMENT_CLICKABLE });
                } catch (e2) {
                    this.log(`[Like] Native click failed: ${e2.message}`);
                    return;
                }
            }

            // ================================================================
            // POST-CLICK VERIFICATION &amp; TRACKING
            // ================================================================
            await this.page.waitForTimeout(mathUtils.randomInRange(1000, 2000));

            // Check if like was registered (button should now show "Unlike")
            let likeRegistered = false;
            for (const selector of unlikeSelectors) {
                try {
                    const el = this.page.locator(selector).first();
                    if (await el.isVisible().catch(() => false)) {
                        likeRegistered = true;
                        break;
                    }
                } catch { }
            }

            if (likeRegistered) {
                this.log(`[Like]  Successfully liked tweet`);

                // Record engagement
                if (this.engagementTracker.record('likes')) {
                    const progress = this.engagementTracker.getProgress('likes');
                    this.log(`[Engagement] ${progress} Likes given`);
                }
            } else {
                this.log(`[Like]  Like may not have registered`);
            }

            // Return to home page to continue main loop
            await this.navigateHome();
            await this.page.waitForTimeout(mathUtils.randomInRange(1500, 3000));

        } catch (error) {
            this.log(`[Like]  Error: ${error.message}`);
        }
    }

    /**
          * Handle bookmark button - Robust implementation with smart selectors and fallbacks
          */
    async handleBookmark() {
        try {
            // Check engagement limits from both systems
            const canBookmark = this.engagementTracker.canPerform('bookmarks') &amp;&amp; this.diveQueue.canEngage('bookmarks');
            if (!canBookmark) {
                this.log('[Bookmark] Limit reached, skipping');
                return;
            }

            // ================================================================
            // SMART SELECTOR WITH FALLBACKS (using HumanInteraction)
            // ================================================================
            const bookmarkSelectors = [
                'button[data-testid="bookmark"]',
                '[data-testid="bookmark"]',
                '[aria-label="Bookmark"]',
                'svg[aria-label*="Bookmark"]',
                'button:has-text("Bookmark")'
            ];

            const bookmarkResult = await this.humanInteraction.findWithFallback(bookmarkSelectors, { visible: true, timeout: 5000 });

            if (!bookmarkResult) {
                this.log('[Bookmark]  Could not find bookmark button with any selector');
                return;
            }

            const bm = bookmarkResult.element;
            const selectedSelector = bookmarkResult.selector;

            // Check if already bookmarked
            const removeBookmarkSelectors = [
                'button[data-testid="removeBookmark"]',
                '[data-testid="removeBookmark"]',
                '[aria-label="Remove Bookmark"]',
                '[aria-label="Bookmark saved"]'
            ];

            const removeResult = await this.humanInteraction.findWithFallback(removeBookmarkSelectors, { visible: true, timeout: 1000 });
            if (removeResult) {
                this.log(`[Skip] Tweet ALREADY bookmarked (found: ${removeResult.selector})`);
                return;
            }

            // ================================================================
            // PRE-CLICK VERIFICATION
            // ================================================================

            // Wait for element to be stable
            let stableCount = 0;
            const maxStableAttempts = 10;
            let lastBoundingBox = null;

            while (stableCount &lt; 3 &amp;&amp; stableCount &lt; maxStableAttempts) {
                try {
                    const bbox = await bm.boundingBox();
                    if (bbox) {
                        if (lastBoundingBox) {
                            const dx = Math.abs(bbox.x - lastBoundingBox.x);
                            const dy = Math.abs(bbox.y - lastBoundingBox.y);
                            if (dx &lt; 3 &amp;&amp; dy &lt; 3) {
                                stableCount++;
                            } else {
                                stableCount = 0;
                            }
                        }
                        lastBoundingBox = bbox;
                    }
                } catch { }

                if (stableCount &lt; 3) {
                    await this.page.waitForTimeout(100);
                    stableCount++;
                }
            }

            // Verify element is actionable (not covered by overlay)
            const isActionable = await this.isElementActionable(bm);
            if (!isActionable) {
                this.log('[Bookmark]  Element may be covered, trying scroll adjustment...');
                try {
                    await bm.scrollIntoViewIfNeeded();
                    await this.page.waitForTimeout(500);
                } catch { }
            }

            // ================================================================
            // EXECUTE CLICK
            // ================================================================
            this.log(`[Action]  Bookmark (selector: ${selectedSelector})`);

            // Try humanClick first, then fallback to native
            try {
                await this.humanClick(bm, 'Bookmark Button');
            } catch (e) {
                this.log(`[Bookmark] humanClick failed: ${e.message}, using native click...`);
                try {
                    await bm.click({ timeout: TWITTER_TIMEOUTS.ELEMENT_CLICKABLE });
                } catch (e2) {
                    this.log(`[Bookmark] Native click failed: ${e2.message}`);
                    return;
                }
            }

            // ================================================================
            // POST-CLICK VERIFICATION &amp; TRACKING
            // ================================================================
            await this.page.waitForTimeout(mathUtils.randomInRange(1000, 2000));

            // Check if bookmark was registered
            let bookmarkRegistered = false;
            for (const selector of removeBookmarkSelectors) {
                try {
                    const el = this.page.locator(selector).first();
                    if (await el.isVisible().catch(() => false)) {
                        bookmarkRegistered = true;
                        break;
                    }
                } catch { }
            }

            if (bookmarkRegistered) {
                this.log(`[Bookmark]  Successfully bookmarked tweet`);

                if (this.engagementTracker.record('bookmarks')) {
                    const progress = this.engagementTracker.getProgress('bookmarks');
                    this.log(`[Engagement] ${progress} Bookmarks saved`);
                }
            } else {
                this.log(`[Bookmark]  Bookmark may not have registered`);
            }

            // Return to home page to continue main loop
            await this.navigateHome();
            await this.page.waitForTimeout(mathUtils.randomInRange(1500, 3000));

        } catch (error) {
            this.log(`[Bookmark]  Error: ${error.message}`);
        }
    }

    /**
     * Handle AI Quote Tweet decision and execution
     * Flow: Probability check  Generate quote  Click Retweet  Select Quote  Type  Post
      */
    async handleAIQuote(tweetText, username, options = {}) {
        const { url = '' } = options;

        // ================================================================
        // Check if this is a pre-validated quote from _diveTweetWithAI
        // ================================================================
        if (options.action === 'quote') {
            this.log(`[AI-Quote] Pre-validated quote - proceeding with generation`);
        } else {
            this.log(`[AI-Quote] Analyzing tweet from @${username}...`);
        }
        this.log(`[AI-Quote] Tweet URL: ${url}`);

        // ================================================================
        // NOTE: Probability check was done by the caller (handleAIEngage)
        // Proceed directly to sentiment analysis
        // ================================================================

        // ================================================================
        // STEP 1: Sentiment analysis (skip negative content)
        // ================================================================
        this.log(`[Sentiment] Analyzing tweet sentiment...`);
        const sentimentResult = sentimentService.analyze(tweetText);

        // Log basic sentiment (backward compatible)
        this.log(`[SentimentGuard] ${sentimentResult.isNegative ? ' NEGATIVE' : ' Neutral/Positive'} content (score: ${sentimentResult.score.toFixed(2)})`);

        // Log advanced dimensions
        this.log(`[Sentiment] Dimensions - Valence: ${sentimentResult.dimensions.valence.valence.toFixed(2)}, ` +
            `Arousal: ${sentimentResult.dimensions.arousal.arousal.toFixed(2)}, ` +
            `Dominance: ${sentimentResult.dimensions.dominance.dominance.toFixed(2)}, ` +
            `Sarcasm: ${sentimentResult.dimensions.sarcasm.sarcasm.toFixed(2)}`);

        if (sentimentResult.isNegative) {
            this.log(`[AI-Quote] Skipped (negative sentiment)`);
            return;
        }

        // Check advanced risk factors
        if (sentimentResult.composite.riskLevel === 'high') {
            this.log(`[AI-Quote] Skipped (high risk: ${sentimentResult.composite.conversationType})`);
            return;
        }

        // ================================================================
        // STEP 2: Engagement limits check
        // ================================================================
        if (!this.engagementTracker.canPerform('quotes')) {
            this.log(`[AI-Quote] Skipped (engagement limit reached)`);
            return;
        }

        // ================================================================
        // STEP 3: Extract context (replies) for better AI quotes
        // ================================================================
        this.log(`[AI-Context] Loading replies for quote context...`);
        const enhancedContext = await this.contextEngine.extractEnhancedContext(
            this.page,
            url,
            tweetText,
            username
        );

        this.log(`[AI-Context] Enhanced: sentiment=${enhancedContext.sentiment?.overall}, tone=${enhancedContext.tone?.primary}, ${enhancedContext.replies.length} replies`);

        // ================================================================
        // STEP 5: Generate AI quote
        // ================================================================
        this.log(`[AI-Quote] Generating quote tweet...`);

        const quoteResult = await this.quoteEngine.generateQuote(tweetText, username, {
            url,
            sentiment: sentimentResult.composite?.engagementStyle || 'neutral',
            tone: sentimentResult.composite?.conversationType || 'neutral',
            engagement: 'low',
            replies: enhancedContext.replies
        });

        if (!quoteResult.success || !quoteResult.quote) {
            const reason = quoteResult.reason || 'unknown';
            this.log(`[AI-Quote]  Failed to generate quote (reason: ${reason})`);
            return;
        }

        // ================================================================
        // STEP 5: Display AI result BEFORE executing
        // ================================================================
        this.log(`[AI-Quote] AI QUOTE: "${quoteResult.quote}"`);

        // Execute quote with human-like behavior (uses 4 methods randomly)
        const result = await this.quoteEngine.executeQuote(this.page, quoteResult.quote);

        if (result.success) {
            if (this.engagementTracker.record('quotes')) {
                const progress = this.engagementTracker.getProgress('quotes');
                this.log(`[Engagement] ${progress} Quotes posted`);
            }
            this.log(`[AI-Quote] Quote tweet posted successfully via ${result.method}`);

            // Additional verification: ensure composer is closed before proceeding
            this.log(`[AI-Quote] Verifying quote completion...`);
            let composerClosed = false;
            for (let i = 0; i &lt; 5; i++) {
                try {
                    const composerVisible = await this.page.locator('[data-testid="tweetTextarea_0"]').isVisible().catch(() => false);
                    if (!composerVisible) {
                        composerClosed = true;
                        this.log(`[AI-Quote] Composer verified closed`);
                        break;
                    }
                    await this.page.waitForTimeout(1000);
                } catch (e) {
                    composerClosed = true;
                    this.log(`[AI-Quote] Composer verification error (treating as closed): ${e.message}`);
                    break;
                }
            }

            if (!composerClosed) {
                this.log(`[AI-Quote]  Composer may still be open, attempting to close...`);
                try {
                    await this.page.keyboard.press('Escape');
                    await this.page.waitForTimeout(500);
                } catch (e) { }
            }
        } else {
            this.log(`[AI-Quote] Quote tweet failed: ${result.reason} (method: ${result.method})`);
        }
    }

    /**
      * Get AI stats
      */
    getAIStats() {
        const actionStats = {};
        if (this.actions) {
            for (const [name, action] of Object.entries(this.actions)) {
                actionStats[name] = action.getStats();
            }
        }

        return {
            ...this.aiStats,
            successRate: this.aiStats.attempts > 0
                ? ((this.aiStats.replies / this.aiStats.attempts) * 100).toFixed(1) + '%'
                : '0%',
            actions: actionStats
        };
    }

    /**
          * Get action stats
          */
    getActionStats() {
        if (this.actionRunner) {
            return this.actionRunner.getStats();
        }
        const stats = {};
        if (this.actions) {
            for (const [name, action] of Object.entries(this.actions)) {
                stats[name] = action.getStats();
            }
        }
        return stats;
    }

    /**
      * Perform health check on browser connection
      * Returns health status and attempts recovery if needed
      */
    async performHealthCheck() {
        try {
            // Get browser context
            const context = this.page.context();
            const browser = context.browser();

            if (!browser || !browser.isConnected()) {
                this.logWarn('[Health] Browser disconnected, attempting recovery...');
                return { healthy: false, reason: 'browser_disconnected' };
            }

            // Check page responsiveness
            const pageHealth = await this.page.evaluate(() => {
                return {
                    readyState: document.readyState,
                    title: document.title,
                    hasBody: !!document.body
                };
            }).catch(() => ({
                readyState: 'error',
                title: '',
                hasBody: false,
                error: 'Page evaluation failed'
            }));

            if (pageHealth.readyState !== 'complete' &amp;&amp; pageHealth.readyState !== 'interactive') {
                this.logWarn('[Health] Page not fully loaded, attempting recovery...');
                return { healthy: false, reason: 'page_not_ready' };
            }

            // Check if still on expected domain
            const currentUrl = this.page.url();
            if (!currentUrl.includes('x.com') &amp;&amp; !currentUrl.includes('twitter.com')) {
                this.logWarn(`[Health] Unexpected URL: ${currentUrl}, navigating home...`);
                await this.navigateHome();
                return { healthy: false, reason: 'unexpected_url' };
            }

            return { healthy: true, pageState: pageHealth.readyState };

        } catch (error) {
            this.logWarn(`[Health] Health check failed: ${error.message}`);
            return { healthy: false, reason: error.message };
        }
    }

    /**
      * Log current engagement status
      */
    getActionStats() {
        if (this.actionRunner) {
            return this.actionRunner.getStats();
        }
        const stats = {};
        if (this.actions) {
            for (const [name, action] of Object.entries(this.actions)) {
                stats[name] = action.getStats();
            }
        }
        return stats;
    }
    //Get engagement stats
    getEngagementStats() {
        return {
            tracker: this.engagementTracker.getStatus(),
            summary: this.engagementTracker.getSummary(),
            usageRate: this.engagementTracker.getUsageRate()
        };
    }
    //Log current engagement status      
    logEngagementStatus() {
        const status = this.engagementTracker.getStatus();
        for (const [action, data] of Object.entries(status)) {
            const emoji = data.remaining === 0 ? '' :
                parseFloat(data.percentage) >= 80 ? '' : '';
            this.engagementLogger?.info(`[Engagement] ${emoji} ${action}: ${data.current}/${data.limit} (${data.percentage} used)`);
        }
    }

    //Flush all buffered loggers (call during cleanup)
      
    async flushLogs() {
        this.log('[Logger] Flushing buffered logs...');
        await Promise.all([
            this.queueLogger.shutdown(),
            this.engagementLogger.shutdown()
        ]);
        this.log('[Logger] All buffered logs flushed');
    }
    //Finalize engagement logger entry   
}
export default AITwitterAgent;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> on Sat Feb 14 2026 11:39:38 GMT+0700 (Indochina Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
